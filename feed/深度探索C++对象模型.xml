<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Adoo's blog</title><link href="http://www.roading.org/" rel="alternate"></link><link href="http://www.roading.org/feed/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.xml" rel="self"></link><id>http://www.roading.org/</id><updated>2011-12-09T22:03:00+08:00</updated><entry><title>《深度探索C++对象模型》笔记汇总</title><link href="http://www.roading.org//develop/cpp/%e3%80%8a%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b%e3%80%8b%e7%ac%94%e8%ae%b0%e6%b1%87%e6%80%bb.html" rel="alternate"></link><updated>2011-12-09T22:03:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-09:/develop/cpp/%e3%80%8a%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b%e3%80%8b%e7%ac%94%e8%ae%b0%e6%b1%87%e6%80%bb.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E6%80%BB%E7%BB%93%E4%BA%A6%E4%B8%BA%E5%BC%95%E8%A8%80.html"&gt;01. 总结——亦为引言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第1章 关于对象(Object Lessons)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E5%AF%B9%E8%B1%A1%E9%9D%A2%E9%9D%A2%E8%A7%82.html"&gt;02. C++对象面面观&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第2章 构造函数语意学(The Semantics of constructors)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%B7%B1%E5%85%A5c%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.html"&gt;03. 深入C++构造函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88copy-constuctor%EF%BC%89.html"&gt;04. 拷贝构造函数(Copy Constructor)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96%E5%92%8C%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97.html"&gt;05. 命名返回值优化和成员初始化队列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第3章 Data语意学（The Semantics of Data）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F.html"&gt;06. C++类对象的大小&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/vc%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%87%86%E5%88%99%EF%BC%88memory-alignment%EF%BC%89.html"&gt;07. VC内存对齐准则（Memory alignment）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98.html"&gt;08. C++对象的数据成员&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第4章 Function语意学（The Semantics of Function）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E4%B9%8B%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.html"&gt;09. C++之成员函数调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0virtual-member-functions.html"&gt;10. C++之虚函数(Virtual Member Functions)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第5章 构造、解构、拷贝 语意学（Semantics of Construction，Destruction，and Copy）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E5%87%A0%E7%82%B9%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html"&gt;11. 几点类设计原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%9E%84%E9%80%A0%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E6%9E%90%E6%9E%84%E8%AF%AD%E6%84%8F%E5%AD%A6.html"&gt;12. 构造、复制、析构语意学&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第6章 执行期语意学（Runting Semantics）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/new-expression%E3%80%81operator-new-%E5%92%8C-placement-new%E4%B8%89%E4%B8%AA%E5%A6%9E%EF%BC%88new%EF%BC%89%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%881%EF%BC%89.html"&gt;13. new expression、operator new 和 placement new——三个“妞（new）”的故事（1）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/new-expression%E3%80%81operator-new-%E5%92%8C-placement-new%E4%B8%89%E4%B8%AA%E5%A6%9E%EF%BC%88new%EF%BC%89%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%882%EF%BC%89.html"&gt;14. new expression、operator new 和 placement new——三个“妞（new）”的故事（2）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/new-expression%E3%80%81operator-new-%E5%92%8C-placement-new%E4%B8%89%E4%B8%AA%E5%A6%9E%EF%BC%88new%EF%BC%89%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%883%EF%BC%89.html"&gt;15. new expression、operator new 和 placement new——三个“妞（new）”的故事（3）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84.html"&gt;16. 对象的构造和析构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E4%B8%B4%E6%97%B6%E6%80%A7%E5%AF%B9%E8%B1%A1temporary-objects.html"&gt;17. 临时性对象(Temporary Objects)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第7章 站在对象模型的类端（On the Cusp of the Object Model）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%A8%A1%E6%9D%BF%E4%BA%8C%E4%BA%8B.html"&gt;18. 模板二事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/eh-rtti.html"&gt;19. EH &amp;amp; RTTI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Inside The C++ Object Model"></category><category term="笔记"></category></entry><entry><title>总结·亦为引言</title><link href="http://www.roading.org//develop/cpp/%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b/%e6%80%bb%e7%bb%93%e4%ba%a6%e4%b8%ba%e5%bc%95%e8%a8%80.html" rel="alternate"></link><updated>2011-12-09T21:39:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-09:/develop/cpp/%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b/%e6%80%bb%e7%bb%93%e4%ba%a6%e4%b8%ba%e5%bc%95%e8%a8%80.html</id><summary type="html">&lt;p&gt;《深度探索C++对象模型》终于在昨天写完了最后一篇笔记，前前后后花费了一个
月左右，期间学到了很多，很感激书的作者和译者。之后的日子，可以将精力转
回《算法导论》和一些非技术类的书上来了。&lt;/p&gt;
&lt;p&gt;11月11号开始看《深度探索C++对象模型》一书，到二十八号看完，共计花费了十
八天。不过到做完全书的笔记则是昨天的事了。期间也算是反复阅读，中英文版本
对照，虽然不能说事深掘至微末，但也能算掌握了主络，倒是令我自己满意。&lt;/p&gt;
&lt;p&gt;期间花费的心力精神自不必说，但收获欢欣也实在不少。得益于 Lippman
的大师技艺，书中很多地方使我有拨云见日的豁然，一些原以为晦涩高超的技巧，
其真实面目暴力且直接。这本书不厚，但可以深掘的东西实在不少，以至于某些
时候，我不得不停下思路，以免难以自拔。&lt;/p&gt;
&lt;p&gt;当然，在这个行业来说，这本书毕竟有点“远古”，读这本书的时候，必须保持着
清晰的头脑，不能迷信作者和译者——虽然他们都是值得尊敬的人物。需要抱有怀
疑精神，更需要多动手编码验证一番。原书的疏漏笔误之处着实不少，这要多谢
译者侯捷一一指正。但或许正因为这个原因，无端膨胀了译者的自信，毕竟指点
一个大师的错误是一件如此刺激的事情。这无端膨胀的自信，同样带来了一些问
题——一些原本正确之处，被做了错误的更正。可见，于技术学习来说，谨慎谦虚，
何其重要。&lt;/p&gt;</summary><category term="Inside The C++ Object Model"></category></entry><entry><title>EH &amp; RTTI</title><link href="http://www.roading.org//develop/cpp/eh-rtti.html" rel="alternate"></link><updated>2011-12-08T22:24:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-08:/develop/cpp/eh-rtti.html</id><summary type="html">&lt;h3&gt;异常处理(Exception Handling)&lt;/h3&gt;
&lt;p&gt;C++的 exception handling 有三个主要的子句组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个throw子句。它在程序的某处丢出一个exception，被丢出的exception可以是内建类
    型，也可以是自定义类型。——抛出exception组件。&lt;/li&gt;
&lt;li&gt;一个或多个 catch 子句。 每一个 catch 子句都是一个 exception handler。每个子句
    可以处理一种类型(也包括其继承类)的exception，在大括号中包含处理代码。——专治各
    种不服组件。每一个catch子句都可以用来处理某种exception。&lt;/li&gt;
&lt;li&gt;一个 try 区段。用大括号包围一系列语句，这些语句有可能抛出exception，从而引发
    catch 子句的作用。——逮捕各种 exception 组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当一个 exception 被抛出后，控制权从函数调用中被释放，寻找一个吻合的catch子句，如
果各层调用都没有吻合的catch子句，&lt;code&gt;terminate()&lt;/code&gt;将被调用。在控制权被放弃后，堆栈中
的每一个函数调用也被出栈，这个过程称为unwinding the stack(关于 stack unwinding ,
可以参考《C++ Primer》第四版之 17.1.2 Stack Unwinding)，在每一个函数被出栈之前,其
局部变量会被摧毁。&lt;/p&gt;
&lt;p&gt;异常抛出有可能带来一些问题，比方在一块内存的lock和unlock内存之间，或是在new和
delete之间的代码抛出了异常，那么将导致本该进行的unlock或delete操作不能进行。解决
方法之一是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt;  &lt;span class="nf"&gt;mumble&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arena&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
   &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="n"&gt;smLock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;arena&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
      &lt;span class="c1"&gt;// ...  &lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;  
   &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="n"&gt;smUnLock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;arena&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
      &lt;span class="n"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
      &lt;span class="n"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="p"&gt;}&lt;/span&gt;  
   &lt;span class="n"&gt;smUnLock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;arena&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
   &lt;span class="n"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在函数被出栈之前，先截住异常，在unlock和delete之后再将异常原样抛出。new expression
的调用不用包括在try块之内是因为，不论在new operator调用时还是构造函数调用时抛出异
常，都会在抛出异常之前释放已分配好的资源，所以不用再调用delete 。&lt;/p&gt;
&lt;p&gt;另一个办法是，将这些资源管理的问题，封装在一个类对象中，由析构函数释放资源，这样就
不需要对代码进行上面那样的处理——利用函数释放控制权之前会析构所有局部对象的原理。&lt;/p&gt;
&lt;p&gt;在对单个对象构造过程中抛出异常，会只调用已经构造好的base class object或member class
 object的析构函数。同样的道理，适用于数组身上，如果在调用构造函数过程中抛出异常，那
 么之前所有被构造好的元素的析构函数被调用，对于抛出异常的该元素，则遵循关于单个对象
 构造的原则，然后释放已经分配好的内存。&lt;/p&gt;
&lt;p&gt;只有在一个catch子句评估完毕并且知道它不会再抛出exception后，真正的exception object
才会被释放。关于 catch子句使用引用还是使用对象来捕获异常，省略。&lt;/p&gt;
&lt;h3&gt;执行期类型识别（Runtime Type Identification RTTI）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;RTTI 只支持多态类，也就是说没有定义虚函数是的类是不能进行 RTTI的。&lt;/li&gt;
&lt;li&gt;对指针进行&lt;code&gt;dynamic_cast&lt;/code&gt;失败会返回NULL ,而对引用的话，识别会抛出
    &lt;code&gt;bad_cast exception&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;typeid 可以返回&lt;code&gt;const type_info&amp;amp;&lt;/code&gt;，用以获取类型信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于1是因为RTTI的实现是通过vptr来获取存储在虚函数表中的&lt;code&gt;type_info*&lt;/code&gt; ，事实上为非多
态类提供RTTI,也没有多大意义。 2的原因在于指针可以被赋值为0，以表示 no object，但是
引用不行。关于3，虽然第一点指出RTTI只支持多态类，但&lt;code&gt;typeid&lt;/code&gt;和&lt;code&gt;type_info&lt;/code&gt;同样可用于
内建类型及所有非多态类。与多态类的差别在于，非多态类的&lt;code&gt;type_info&lt;/code&gt;对象是静态取得(所
以不能叫“执行期类型识别”)，而多态类的是在执行期获得。&lt;/p&gt;
&lt;p&gt;参考：深度探索C++对象模型&lt;/p&gt;</summary><category term="EH"></category><category term="Inside The C++ Object Model"></category><category term="RTTI"></category></entry><entry><title>模板二事</title><link href="http://www.roading.org//develop/cpp/%e6%a8%a1%e6%9d%bf%e4%ba%8c%e4%ba%8b.html" rel="alternate"></link><updated>2011-12-07T17:00:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-07:/develop/cpp/%e6%a8%a1%e6%9d%bf%e4%ba%8c%e4%ba%8b.html</id><summary type="html">&lt;h3&gt;模板的实例化&lt;/h3&gt;
&lt;p&gt;一个模板只有被使用到，才会被实例化，否则不会被实例化。对于一个实例化
后的模板来说，未被调用的成员函数将不会被实例化，只有成员函数被使用时，
C++标准才要求实例化他们。其原因，有两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间和时间效率的考虑，如果模板类中有100个成员函数，对某个特定类型
    只有2个函数会被使用，针对另一个特定类型只会使用3个，那么如果将剩
    余的195个函数实例化将浪费大量的时间和空间。&lt;/li&gt;
&lt;li&gt;使模板有最大的适用性。并不是实例化出来的每个类型都支持所有模板的全
    部成员函数所需要的运算符。如果只实例化那些真正被使用的成员函数的话，
    那么原本在编译期有错误的类型也能够得到支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以明确的要求在一个文件中将整个类模板实例化：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;template&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以显示指定实例化一个模板类的成员函数：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;template&lt;/span&gt; &lt;span class="n"&gt;float&lt;/span&gt; &lt;span class="n"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或是针对一个模板函数：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;template&lt;/span&gt; &lt;span class="n"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;模板的错误报告，使用模板并遇到错误的大概都深有体会，那就是一个灾难。&lt;/p&gt;
&lt;h3&gt;模板的名称决议&lt;/h3&gt;
&lt;p&gt;一开始先要区分两种意义,一种是C++ 标准所谓的“scope of the template
definition”，直译就是“定义模板的范围”。另一种是C++标准所谓的“scope of 
the temlate instantiation”，可以直译为“实例化模板的范围”。&lt;/p&gt;
&lt;p&gt;第一种情况：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// scope of the template definition&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;ScopeRules&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
   &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;invariant&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="n"&gt;_member&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;_val&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
   &lt;span class="p"&gt;}&lt;/span&gt;

   &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;type_dependent&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;_member&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
   &lt;span class="p"&gt;}&lt;/span&gt;  
   &lt;span class="c1"&gt;// ...  &lt;/span&gt;
&lt;span class="nl"&gt;private:&lt;/span&gt;  
   &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;_val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;_member&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二种情况:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//scope of the template instantiation  &lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;// ...  &lt;/span&gt;
&lt;span class="n"&gt;ScopeRules&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sr0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;sr0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invariant&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;sr0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_dependent&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在“scope of the template instantiation ”中 两个foo()都声明在此 scope
中。猜猜sr0.invariant() 中调用的是哪个foo()函数，出乎意料，实际调用的
是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;extern&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看上去，应该调用：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;extern&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;毕竟，_val 的类型是 int 类型，它们才完全匹配。而 sr0.type_dependent()
中调用的却在我们意料之中，调用的是:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;extern&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;诸上所述,看上去或合理或不合理的选择，原因在于:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;template 之中， 对于一个非成员名字的决议结果是根据这个 name
的使用是否与“用以实例化该模板的参数类型”有关来决定name。如果其使用互
不相干，那么就以“scope of the template dclaration”来决定name。如果其
使用的互相关联，那么就以“scope of the template
instantiation”来决定name.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于上面这一段话我的理解比较粗鲁且直接：在模板中，一个非成员名字的决议
在于它适不适合在当前决议，当它完全与实例化模板的参数的类型无关的时候，
就可以在当前决议下来；如果有关的话，则认为不适合在当前决议下来，将被推
迟到实例化这个模板实例化的时候来决议。为什么以与实例化的类型相关不相关
来区别适不适合当前决议？一个与实例化类型无关的名字，如果推迟到实例化的
时候来决议，将使模板的设计者无所适从，一个模板的设计者能容忍一个与实例
化类型无关的名字在他的模板中表现出当前不具有的含义吗？当然不行，那种场
面，估计没有一个模板设计者能够hold住。相反，对于一个与实例化类型有关的
名字，天生就应该可以根据实例化模板的不同类型表现出不同含义，如果其名字
早在模板定义时被决议出来，那就该轮到模板的使用者hold不住了。当然所上完
全属一家之言，呸，连一家之言都不算，怎么敢自称“家”。如有不同理解，可当
我一派胡言，如果你聊发善心，可以对我赐教一二，当聆听受教。&lt;/p&gt;
&lt;p&gt;参考：深度探索C++对象模型&lt;/p&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category><category term="template instantiation"></category></entry><entry><title>临时性对象(Temporary Objects)</title><link href="http://www.roading.org//develop/cpp/%e4%b8%b4%e6%97%b6%e6%80%a7%e5%af%b9%e8%b1%a1temporary-objects.html" rel="alternate"></link><updated>2011-12-06T17:48:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-06:/develop/cpp/%e4%b8%b4%e6%97%b6%e6%80%a7%e5%af%b9%e8%b1%a1temporary-objects.html</id><summary type="html">&lt;h3&gt;何时生成临时对象&lt;/h3&gt;
&lt;p&gt;对于一个下面这样的程序片段：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;死板一点来讲，它应当产生一个临时对象用来存储a+b的结果，然后以临时对
象作为初值调用拷贝构造函数初始化对象c。而实际上编译器更愿意直接调用
拷贝构造函数的方式将a+b的值放到c中，这样就不需要临时对象，和它的构造
函数和拷贝构造函数的调用了。&lt;/p&gt;
&lt;p&gt;更进一步，如果operator +的定义符合NRV优化的条件，那么NRV优化的开启，
将使得拷贝构造函数的调用和named object的析构函数都免了。期间详情可
以参见”&lt;a href="http://www.roading.org/?p=544"&gt;NRV优化&lt;/a&gt;”。也就是说对于上面那种情形在我们的代码中是不产生
临时对象的。但是对于一个情况非常类似的赋值操作语句&lt;code&gt;c = a+b&lt;/code&gt;，却有很
大的差别，那个临时变量是不能省的&lt;/p&gt;
&lt;p&gt;不能忽略临时对象，反而导致如下过程：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Pseudo C++ code  &lt;/span&gt;
&lt;span class="c1"&gt;// T temp = a + b;  &lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// @1 [^注1]&lt;/span&gt;

&lt;span class="c1"&gt;// c = temp  &lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// @2  &lt;/span&gt;
&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在代码@1处，表明以拷贝构造函数或NRV方式将结果保存的临时对象中。为什
么不能省略那个临时对象，比如直接这样：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这不是更高效，更简洁的方式吗？不行，其原因在于，拷贝构造函数、析构
函数以及赋值操作符都可以由使用者提供，没有人能保证，析构函数加拷贝
构造函数的组合和赋值操作符具有相同的含义。所以：&lt;code&gt;T c=a+b&lt;/code&gt;总是比
&lt;code&gt;c = a + b&lt;/code&gt;更有效率。&lt;/p&gt;
&lt;p&gt;对于一个没有出现目标对象的表达式&lt;code&gt;a + b&lt;/code&gt;,那么产生一个临时对象来存储
运算结果，则是非常必要的。&lt;/p&gt;
&lt;h3&gt;临时对象的生命周期&lt;/h3&gt;
&lt;p&gt;很多时候，产生临时对象是必不可少的，但是何时摧毁一个临时对象才是最
佳行为呢？过早或过晚都不太适合，过早有可能使得程序错误，过晚的话又
使得资源没有得到及时回收。对于下面的程序：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;world &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;s3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;by Adoo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;s3&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;显然保存&lt;code&gt;s1+s2&lt;/code&gt;结果的临时对象，如果在与s3进行加法之前析构，将会带来
大麻烦。于是C++标准中有一条：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;临时性对象的摧毁应当作为造成产生这个临时对象的完整表达式的最后
一个步骤。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整的表达式，是指涵括的表达式中最外围的那个。我们再看上面那个字符
串相加的表达式，当计算完成，而cout还未调用，此时我们析构掉存储最终
结果的临时对象，岂不悲剧。其实上面的规定还有两个例外：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;凡含有表达式执行结果的临时性对象，应该保存到Object的初始化操作
    完成为止。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果临时性对象被绑定与一个引用，临时对象将残留，直至被初始化的
    引用的生命结束，或直到临时对象的生命周期结束——视哪一种情况先达
    到，对应于这种情况：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:注1"&gt;
&lt;p&gt;侯捷认为此处为 Lippman 的错误，他认为应该为
&lt;code&gt;temp.operator + ( a, b )&lt;/code&gt;但我以为是侯捷并没有理解Lippman的意思，回
顾一下,《深度探索对象模型》2.3讲到的返回值初始化(Return Value 
Initialization)——返回值将作为一个额外的参数提供给函数，来传回函数内
部的值，也就是说对于一个 operator + 操作符
&lt;code&gt;T T::operator+ (const T&amp;amp; right)&lt;/code&gt;将转化为
&lt;code&gt;void T::operator+ (T &amp;amp;result ,const T&amp;amp; right)&lt;/code&gt;所以&lt;code&gt;temp=a+b&lt;/code&gt;是
&lt;code&gt;a.operator+( temp, b )&lt;/code&gt;还是&lt;code&gt;temp.operator+( a, b )&lt;/code&gt;自然不言而喻。&amp;#160;&lt;a href="#fnref:注1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category><category term="笔记"></category></entry><entry><title>对象的构造和析构</title><link href="http://www.roading.org//develop/cpp/%e5%af%b9%e8%b1%a1%e7%9a%84%e6%9e%84%e9%80%a0%e5%92%8c%e6%9e%90%e6%9e%84.html" rel="alternate"></link><updated>2011-12-06T13:35:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-06:/develop/cpp/%e5%af%b9%e8%b1%a1%e7%9a%84%e6%9e%84%e9%80%a0%e5%92%8c%e6%9e%90%e6%9e%84.html</id><summary type="html">&lt;p&gt;一般而言，构造函数被安插在对象的定义处，而析构函数被安插在对象生命
周期结束前：&lt;/p&gt;
&lt;p&gt;:::C++
  // Pseudo C++ Code&lt;br /&gt;
  {&lt;br /&gt;
     Point point;&lt;br /&gt;
     // point.Point::Point() 一般被安插在这儿&lt;br /&gt;
     ...&lt;br /&gt;
     // point.Point::~Point() 一般被安插在这儿 
  }&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;当代码有一个以上的离开点的时候，析构函数则必须放在对象被构造之后的每
一个离开点之前。因此，尽可能将对象定义在接近要使用的地方，可以减少不
必要的构造对象和析构对象的代码被插入到自己的代码当中。&lt;/p&gt;
&lt;h3&gt;全局对象&lt;/h3&gt;
&lt;p&gt;一个全局对象，c++保证它在&lt;code&gt;main()&lt;/code&gt;在第一次使用它之前将其构造，而在
&lt;code&gt;main()&lt;/code&gt;结束之前，将之析构掉。C规定一个全局对象只能被一个常量表达式
(编译期可知)赋初值。而构造函数显然不是一个常量表达式。虽然全局对象在
编译期被即被置为0，但真正的构造工作却需要直到程序激活后才能进行，而
这个过程就是所谓的静态初始化。我是这样理解，但我不保证正确，因为全局
变量，被放在data segment (数据段)，data segment是在编译期已经布置好
的，但构造函数的结果在编译期不能评估，因此先将对象的内容设置为0，存
储在数据段，而等到程序激活时，这时候就可以通过构造函数对在数据段的全
局对象进行初始化了，而这就是所谓的静态初始化。&lt;/p&gt;
&lt;p&gt;静态初始化的对象有一些缺点：如果构造函数支持异常机制，那么遗憾的是对
象的构造函数的调用，无法被放置与try块中，我们知道一个没有得到catch的
异常默认的调用&lt;code&gt;terminate()&lt;/code&gt;函数。也就是说一个全局对象在构造过程中抛出
异常，将导致程序的终结，而更悲剧的是，你还无法来捕获并处理这个异常。
另一点在于，在不同文件中定义的全局变量，构造顺序有规则吗？我不知道。
即使有规则，如果不同的构造顺序对程序有影响的话，那么有多琐碎复杂…&lt;/p&gt;
&lt;p&gt;Lippman甚至建议：根本就不要使用那些需要静态初始化的全局对象。真的非要
一个全局对象，而且这个对象还需要静态初始化？那么我的方法是，用一个函
数封装一个静态局部对象，也是一样的效果嘛。&lt;/p&gt;
&lt;h3&gt;局部静态对象(Local Static Object)&lt;/h3&gt;
&lt;p&gt;下面一段代码：&lt;/p&gt;
&lt;p&gt;:::C++
  const Matrix&amp;amp;  identity()
  {&lt;br /&gt;
          static Matrix mat_identity;&lt;br /&gt;
          // ...&lt;br /&gt;
          return mat_identity;&lt;br /&gt;
  }&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;因为静态语意保证了 mat_identity 在整个程序周期都存在，而不会在函数
&lt;code&gt;identity()&lt;/code&gt;退出时被析构，所以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mat_identity的构造函数只能被施行一次，虽然identity()可以被调用
    多次。&lt;/li&gt;
&lt;li&gt;mat_identity 的析构函数只能被施行一次，虽然identity()可以被调用
    多次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么 mat_identity的构造函数和析构函数到底在什么时候被调用？答案是:
mat_identity的构造函数只有在第一次被调用时在被施行，而在整个程序退出
之时按构造相反的顺序析构局部静态对象。&lt;/p&gt;
&lt;h3&gt;对象数组(Array of Objects)&lt;/h3&gt;
&lt;p&gt;对于定义一个普通的数组，例如：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="n"&gt;knots&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实际上背后做的工作则是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分配充足的内存以存储10个Point元素；&lt;/li&gt;
&lt;li&gt;为每个Point元素调用它们的默认构造函数(如果有的话，且不论是合成的还
    是显式定义的)。编译器一般以一个或多个函数来完成这个任务。当数组的
    生命周期结束的时候，则要逐一调用析构函数，然后回收内存，编译器同样
    一个或多个函数来完成任务。这些函数完成什么功能，大概都能猜得出来。
    而关于细节，不必要死扣了，每个编译器肯定都有些许差别。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：Lippman 的两本书《深度探索C++对象模型》和《C++ Primer》。&lt;/p&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category><category term="笔记"></category></entry><entry><title>new expression、operator new和placement new——三个“妞（new）”的故事（3）</title><link href="http://www.roading.org//develop/cpp/new-expression%e3%80%81operator-new-%e5%92%8c-placement-new%e4%b8%89%e4%b8%aa%e5%a6%9e%ef%bc%88new%ef%bc%89%e7%9a%84%e6%95%85%e4%ba%8b%ef%bc%883%ef%bc%89.html" rel="alternate"></link><updated>2011-12-05T15:49:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-05:/develop/cpp/new-expression%e3%80%81operator-new-%e5%92%8c-placement-new%e4%b8%89%e4%b8%aa%e5%a6%9e%ef%bc%88new%ef%bc%89%e7%9a%84%e6%95%85%e4%ba%8b%ef%bc%883%ef%bc%89.html</id><summary type="html">&lt;h3&gt;placement operator new&lt;/h3&gt;
&lt;p&gt;placement operator new用来在指定地址上构造对象，要注意的是，它并不分配内存，仅仅是
对指定地址调用构造函数。其调用方式如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;point3d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;观其名字可知，它是operator new的一个重载版本。它的实现方式异常简单，传回一个指针即
可：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;site_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不必要惊讶于它的简单，《深度探索C++对象模型》中Lippman告诉我们，它有另一半重要的工
作是被扩充而来。我在想，扩充一个类中定义的placement operator new还好说，但是要如何
扩充一个库中提供的placement operator new呢？毕竟它要放之四海而皆准，我原以为这其中
有什么高超的技巧。后来我则坚信根本就没有什么扩充，placement operator new 也并不强
大。&lt;/p&gt;
&lt;p&gt;我先明确调用了 placement operator new ：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如我所料，输出结果显示（我在&lt;code&gt;point&lt;/code&gt;的默认构造函数和placement operator new中间各输
出一句不同的话），此时 point的默认构造函数并不会被调用。然后我通过new expression
的方式来间接调用placement operator new：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个时候 point 的默认的构造函数被调用了。可见 placement operator new并没有什么奇特
的地方，它与一般的operator new不同处在于，它不会申请内存。它也不会在指定的地址调用
构造函数，而调用构造函数的的全部原因在于new expression总是先调用一个匹配参数的
operator new然后再调用指定类型的匹配参数的构造函数，而说到底 placement operator new
也是一个 operator new。&lt;/p&gt;
&lt;p&gt;通过一个placement operator new构建的一个对象，如果你使用delete来撤销对象，那么其内
存也被回收，如果想保存内存而析构对象，好的办法是显示调用其析构函数。&lt;/p&gt;
&lt;p&gt;看一份代码：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;fooBar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
   &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Base::f() invoked  &lt;/span&gt;
   &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
   &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 1  &lt;/span&gt;
   &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// which f() invoked?  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述两个类的大小相同，因此将Derived对象放在 Base对象中是安全的，但是在最后一句代码
中 b.f()调用的是哪一个类的f()。答案是Base::f() 的。虽然此时b中存储的实际上是一个
Derived对象，但是，通过一个对象来调用虚函数，将被静态决议出来，虚函数机制不会被启用。&lt;/p&gt;
&lt;p&gt;参考：Lippman 的两本书《深度探索C++对象模型》和《C++ Primer》。&lt;/p&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category><category term="笔记"></category></entry><entry><title>new expression、operator new和placement new——三个妞（new）的故事（2）</title><link href="http://www.roading.org//develop/cpp/new-expression%e3%80%81operator-new-%e5%92%8c-placement-new%e4%b8%89%e4%b8%aa%e5%a6%9e%ef%bc%88new%ef%bc%89%e7%9a%84%e6%95%85%e4%ba%8b%ef%bc%882%ef%bc%89.html" rel="alternate"></link><updated>2011-12-05T15:19:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-05:/develop/cpp/new-expression%e3%80%81operator-new-%e5%92%8c-placement-new%e4%b8%89%e4%b8%aa%e5%a6%9e%ef%bc%88new%ef%bc%89%e7%9a%84%e6%95%85%e4%ba%8b%ef%bc%882%ef%bc%89.html</id><summary type="html">&lt;h3&gt;两个 delete 后的问题&lt;/h3&gt;
&lt;p&gt;最近在网上看到两个关于指针 delete 后的问题。第一种情况：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// p为什么能delete两次，而程序运行的时候还不报错。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二种情况：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;//delete后对*p进行再赋值居然也可以（他的平台上运行并没有引发什么错误）？&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在回答这两个问题之前，我们先想想delete p; 这一语句意味着什么？p指向一个地址，以该
地址为起始地址保存有一个&lt;code&gt;int&lt;/code&gt;变量（虽然该变量并没有进行初始化），&lt;code&gt;delete p&lt;/code&gt;之后&lt;code&gt;p&lt;/code&gt;
所指向的地址空间被释放，也就是说这个&lt;code&gt;int&lt;/code&gt;变量的生命结束，但是&lt;code&gt;p&lt;/code&gt;仍旧是一个合法的指
针，它仍旧指向原来的地址，而且该地址仍旧代表着一个合法的程序空间。与&lt;code&gt;delete&lt;/code&gt;之前唯
一的不同是，你已经丧失了那快程序空间的所有权。这带来一个什么样的问题？你租了一间储
物室（&lt;code&gt;int* p = new int;&lt;/code&gt;），后来退租了（&lt;code&gt;delete p;&lt;/code&gt;），但你却保存了出入该储物室的
钥匙（指针&lt;code&gt;p&lt;/code&gt;）没有归还。拥有这片钥匙，你或许什么都不做，这自然没有问题。但是：&lt;/p&gt;
&lt;p&gt;你或许出于好心，又跑过去告诉房东，“Hi！这储物室已经退租了（第一种情况）”。哦噢，会
发生什么？我们假设此时这个房子已经有了新的租客。愚笨的房东直接相信了你的话，认为这
个储物室空着，把它又租给新的人。于是一间只能给一个人用的储物室，却租给了两个人，再
之后各种难以预料的情况就会发生。&lt;/p&gt;
&lt;p&gt;又或许，你很无耻，你虽然退租，但却想用你的钥匙依旧享有储物室的使用权（第二种情况），
结果呢，你存在这间储物室的东西可能会被现在的租客丢掉，而你也可能把他的东西丢掉，腾
出空间来放你的。&lt;/p&gt;
&lt;p&gt;回到上面的程序上来，毫无疑问的是上面的程序在语法上来讲是合乎规范的，但是暗藏着很大
的逻辑错误，不论你对一块已经释放的内存再度&lt;code&gt;delete&lt;/code&gt;，还是再度给它赋值，都暗含着很大
的危险，因为当你delete后，就代表着将这块内存归还。而这块被归还的内存很可能已经被再
度分配出去，此时不论是你再度&lt;code&gt;delete&lt;/code&gt;还是重新赋值，都将破坏其它代码的数据，同时你存
储在其中的数据也很容易被覆盖。至于报不报错，崩不崩溃，这取决于有一个怎么样的“房东”，
聪明且负责的“房东”会阻止你上述的行为——终止你的程序，懒惰的房东，则听之任之。&lt;/p&gt;
&lt;p&gt;上述情况下的指针p被称为野指针——指向了一块“垃圾内存”，或者说指向了一块不应该读写的
内存。避免野指针的好方法是，当一个指针变为野指针的时候，马上赋值为&lt;code&gt;NULL&lt;/code&gt;，其缘由在
于，你可以很容易的判断一个指针是否为&lt;code&gt;NULL&lt;/code&gt;,却难以抉择其是否为野指针。而且，&lt;code&gt;delete&lt;/code&gt;
一个空指针，不会做任何操作，因此总是安全的。&lt;/p&gt;
&lt;h3&gt;不用一个基类指针指向派生类数组？&lt;/h3&gt;
&lt;p&gt;《深度探索C++对象模型》中指出，不要用一个基类指针指向派生类的数组。因为在他的
cfront中的&lt;code&gt;vec_delete&lt;/code&gt;是根据被删除指针的类型来调用析构函数——也就是说虚函数机制在这
儿不起作用了。照这样的思路来说，对一个派生类的数组依次调用其基类的析构函数，显然大
多时候不能正确析构——派生类一般大于其基类。但是我感兴趣的一点是，这么多年过去了，这
样一个不太合理的设计是否有所改进呢？说它不太合理是，以C++编程者的思路，在这样一种情
况下，它应该支持多态，而且在这种情况下支持多态并不需要太复杂的机制和代价。我在vc++
2008和vc++ 2010下的结果是：是的，有与cfront不同，它支持多态。&lt;/p&gt;
&lt;p&gt;我的测试代码如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
       &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
           &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;point::~point()&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;point3d&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;point3d&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;point3d::~point3d()&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;point3d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;pause&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出的结果，也令人满意：&lt;/p&gt;
&lt;p&gt;&lt;img alt="VC输出的结果" src="http://www.roading.org/images/2011-12/image_thumb1.png" /&gt;&lt;/p&gt;
&lt;p&gt;确实调用了派生类的析构函数，而非基类的析构函数。&lt;/p&gt;
&lt;p&gt;即使如此，是否能安心的使用一个基类指针指向派生类数组？我不太安心！——对于基类的析构
函数是否为虚函数没有把握。所以最好还是不要把一个基类的指针指向派生类数组。非得这么
做？那么我认为&lt;code&gt;delete&lt;/code&gt;的时候将之类类型转换为派生类就差不多了，可以这样:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;point3d&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;似乎不必要像Lippman说的这样：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;ix&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;elem_count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;ix&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;  
   &lt;span class="n"&gt;Point3d&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt; &lt;span class="n"&gt;ix&lt;/span&gt; &lt;span class="p"&gt;];&lt;/span&gt;  
   &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考：Lippman 的两本书《深度探索C++对象模型》和《C++ Primer》。&lt;/p&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category><category term="笔记"></category></entry><entry><title>new expression、operator new 和 placement new——三个妞（new）的故事（1）</title><link href="http://www.roading.org//develop/cpp/new-expression%e3%80%81operator-new-%e5%92%8c-placement-new%e4%b8%89%e4%b8%aa%e5%a6%9e%ef%bc%88new%ef%bc%89%e7%9a%84%e6%95%85%e4%ba%8b%ef%bc%881%ef%bc%89.html" rel="alternate"></link><updated>2011-12-02T23:35:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-02:/develop/cpp/new-expression%e3%80%81operator-new-%e5%92%8c-placement-new%e4%b8%89%e4%b8%aa%e5%a6%9e%ef%bc%88new%ef%bc%89%e7%9a%84%e6%95%85%e4%ba%8b%ef%bc%881%ef%bc%89.html</id><summary type="html">&lt;p&gt;之前虽然一直知道有new expression、operator new和placement new，但对于这三个“new”,
却不甚了了，这些天从《深度探索C++对象模型》读到new和delete，特意结合《C++ Primer》
写下这篇笔记，以作总结。三个虽然都是“妞”（new），但每个妞都不相同各有各的特点，各
有各的风味，本文重点在于总结比较这三个“妞”，但期间也不忘提一提推倒这三个“妞”的哥们
——delete。&lt;/p&gt;
&lt;h3&gt;new expression 和 operator new&lt;/h3&gt;
&lt;p&gt;一个看起来很简单的new expression运算，其实暗含一些步骤，像这样的一次简单运用：
&lt;code&gt;int *p=new int (5)&lt;/code&gt;实际上包含着两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用一个合适的operator new实体分配足够的未类型化的内存。&lt;/li&gt;
&lt;li&gt;调用合适的构造函数初始化这块内存，当然&lt;code&gt;int&lt;/code&gt;没有构造函数，但是会进行赋值操作：
    &lt;code&gt;*p=5&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由此可见：new expression和operator new完全不是一回事，但关系不浅——operator new 为
new expression分配内存。&lt;/p&gt;
&lt;p&gt;摘录一下 《C++ primer》关于对比new expression 和 operator new的一小段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;标准库函数 operator new和 operator delete 的命名容易让人误解。与其他operator 函
数（如 &lt;code&gt;operator=&lt;/code&gt;）不同，这些函数没有重载new或delete expression，实际上，我们
不能重定义new或delete expression的行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这段话有两个要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;operator new和operator delete不是new expression和delete expression的重载，它
    们完全是另外的一个独立的东西，具有不同的语意，这与operator +是对+ expression
    的重载不同。&lt;/li&gt;
&lt;li&gt;new expression和delete expression是不能被重载的，可以看出它们与普通的
    expression 不同。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;operator new其实也是可以直接利用的，譬如当我们只想分配内存，而不愿意进行初始化的
时候，我们就可以直接用operator new 来进行。用法如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;newelements&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;标准库重载有两个版本的operator new，分别为单个对象和数组对象服务，单个对象版本的
提供给分配单个对象new expression调用，数组版的提供给分配数组的 new expression 调
用：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// allocate an object&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// allocate an array&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以分别重载这两个版本，来定义我们自己的分配单个对象或对象数组的内存方式。当
我们自己在重载operator new时，不一定要完全按照上面两个版本的原型重载，唯一的两个
要求是：返回一个&lt;code&gt;void*&lt;/code&gt;类型和第一个参数的类型必须为&lt;code&gt;size_t&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;还要注意的是，在类中重载的operator new和operator delete是隐式静态的，因为前者运
行于对象构造之前，后者运行与对象析构之后，所以他们不能也不应该拥有一个this指针来
存取数据。另外，new expression 默认调用的是单参数的operator new——上面声明的那种，
而其它不同形式的重载，则只能显式调用了。&lt;/p&gt;
&lt;p&gt;delete expression与new expression相对应，而operator delete则与operator new对应。
依上所述，则不难推断出关于delete expression和operator delete之间的关系以及一些特
性，此略。&lt;/p&gt;
&lt;p&gt;当使用new expression来动态分配数组的时候，Lippman在《深度探索C++对象模型》中指出：
当分配的类型有一个默认构造函数的时候，new expression将调用一个所谓的&lt;code&gt;vec_new()&lt;/code&gt;函
数来分配内存，而不是operator new内存。但我在VC ++ 2010 上测试的结果却是，不论有没
有构造函数，new expression都是调用operator new来分配内存，并在此之后，调用默认构
造函数逐个初始化它们，而不调用所谓的&lt;code&gt;vec_new()&lt;/code&gt;，也许cfront确实离我们有点遥远。&lt;/p&gt;
&lt;p&gt;参考：Lippman 的两本书《深度探索C++对象模型》和《C++ Primer》。&lt;/p&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category><category term="笔记"></category></entry><entry><title>构造、复制、析构语意学</title><link href="http://www.roading.org//develop/cpp/%e6%9e%84%e9%80%a0%e3%80%81%e5%a4%8d%e5%88%b6%e3%80%81%e6%9e%90%e6%9e%84%e8%af%ad%e6%84%8f%e5%ad%a6.html" rel="alternate"></link><updated>2011-12-01T22:04:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-01:/develop/cpp/%e6%9e%84%e9%80%a0%e3%80%81%e5%a4%8d%e5%88%b6%e3%80%81%e6%9e%90%e6%9e%84%e8%af%ad%e6%84%8f%e5%ad%a6.html</id><summary type="html">&lt;p&gt;一种所谓的Plain OI’Data声明形式：&lt;/p&gt;
&lt;p&gt;:::C++
  struct Point {
      float x,y,z;
  };&lt;/p&gt;
&lt;p&gt;概念上来讲，对于一段这样的C++代码,编译器会为之合成一个默认构造函数、
复制构造函数、析构函数、赋值操作符。然而实际上编译器会分析这段代码，
并给&lt;code&gt;Point&lt;/code&gt;贴上Plain OI’Data标签。编译器在此后对于&lt;code&gt;Point&lt;/code&gt;的处理与在
C中完全一样,也就是说上述的函数都不会被合成。可见概念上应当由编译器
合成的函数，并不一定会合成，编译器只有在必要的时候才会合成它们。由此
一来，原本在观念上应该调用这些函数的地方实质上不会调用，而是用其它的
方法来完成上面的功能，比方复制控制会用bitwise copy。&lt;/p&gt;
&lt;h3&gt;对象构造语意学&lt;/h3&gt;
&lt;p&gt;无继承情况下的对象构造：略。&lt;/p&gt;
&lt;h3&gt;单继承体系下的对象构造&lt;/h3&gt;
&lt;p&gt;对于简单定义的一个对象&lt;code&gt;T object;&lt;/code&gt;,很明显它的默认构造函数会被调用（被
编译器合成的或用户提供的）。但是一个构造函数究竟做了什么，就显得比较
复杂了——编译器给了它很多的隐藏代码。编译器一般会做如下扩充操作&lt;sup id="fnref:注1"&gt;&lt;a href="#fn:注1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用所有虚基类的构造函数，从左到右，从最深到最浅：&lt;ul&gt;
&lt;li&gt;如果该类被列于成员初始化列表中，任何明确明确指定的参数，都应
    该被传递过来。若没有列入成员初始化列表中，虚基类的一个默认构
    造函数被调用（有的话）。&lt;/li&gt;
&lt;li&gt;此外，要保证虚基类的偏移量在执行期可存取，对于使用vbptr来实现
    虚基类的编译器来说，满足这点要求就是对vbptr的初始化。&lt;/li&gt;
&lt;li&gt;然而，只有在类对象代表着“most-derived class”时，这些构造函数才
    可能会被调用。一些支持这个行为的代码会被放进去&lt;sup id="fnref:注2"&gt;&lt;a href="#fn:注2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;（直观点说
    就是，虚基类的构造由最外层类控制)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用所有基类构造函数，依声明顺序：&lt;ul&gt;
&lt;li&gt;如果该基类被列入了成员初始化队列，那么所有明确指定的参数，应该
    被传递过来。&lt;/li&gt;
&lt;li&gt;没有列入的话，那么调用其默认构造函数，如果有的话。&lt;/li&gt;
&lt;li&gt;如果该基类是第二顺位或之后的基类，this 指针必须被调整。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正确初始化vptr,如果有的话。&lt;/li&gt;
&lt;li&gt;调用没有出现在初始化成员列表中的member object的默认构造函数，如果
    有的话。&lt;/li&gt;
&lt;li&gt;记录在成员初始化队列中的数据成员初始化操作以声明的顺序被放进构造函
    数中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;虚拟继承下的构造抑制&lt;/h3&gt;
&lt;p&gt;有如下继承体系：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://www.roading.org/images/2011-12/image_thumb.png" /&gt;&lt;/p&gt;
&lt;p&gt;根据c++ 语法，Point 的初始化应有most-derived class来施行。也就是说当
Vertex3d为most-derived class的时候，应当由它的构造函数来调用Point的构
造函数初始化Point子对象，Vertex3d的子对象的构造函数对于Point的调用则
应当抑制。如果没有抑制会怎么样?当我们定义&lt;code&gt;Vertex3d cv;&lt;/code&gt;时，Vertex3d的
构造函数中调用Point的构造函数、而随之调用它的子对象，Point3d和Vertex的
构造函数中也调用了Point的构造函数。先不说，对于同一个子对象进行三次初
始化是否有效率，更重要的是，这将不可避免的带来错误。由Vertex3d指定的子
对象Point的值，会被覆盖掉。&lt;/p&gt;
&lt;p&gt;编译器通常使用一个条件变量来表示是否为most-derived class,各构造函数根
据这个条件变量来决定是否调用虚基类的构造函数，因此通过控制这个条件变量，
就可以抑制非most-derived class调用虚基类的构造函数。当然也有其它的方法
来做同样的事。&lt;/p&gt;
&lt;h3&gt;对象复制语意学&lt;/h3&gt;
&lt;p&gt;设计一个类，并考虑到要以一个对象指定给另一个对象时，有三种选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么都不做，采用编译器提供默认行为（bitwise copy或者由编译器合成
    一个）。&lt;/li&gt;
&lt;li&gt;自己提供一个赋值运算符操作。&lt;/li&gt;
&lt;li&gt;明确拒绝将一个对象指定给另一个对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于第三点，只要将赋值操作符声明为private，且不定义它就可以了。对于第
二点，只有在第一点的行为不安全或不正确，或你特别想往其中插入点东西的时
候。&lt;/p&gt;
&lt;p&gt;以下四种情况 copy assignment operator(还是用它的英文名，感觉顺畅点)，不
具有bitwise copy语意，也就是说这些情况下，编译器要合成copy assignment 
operator而不能依靠bitwise copy来完成赋值操作，这四种情况与构造函数、
&lt;a href="http://www.roading.org/develop/cpp/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88copy-constuctor%EF%BC%89.html"&gt;拷贝构造函数&lt;/a&gt;的情况类似，原因可以参考它们的。四种情况如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类包含有定义了copy assignment operator的class object成员。&lt;/li&gt;
&lt;li&gt;类的基类有copy assignment operator。&lt;/li&gt;
&lt;li&gt;类声明有任何虚函数的时候（问题同样会出现在由继承类对象向基类对象拷贝
    的时候）。&lt;/li&gt;
&lt;li&gt;当class继承体系中有虚基类时。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在虚拟继承情况下，copy assignment opertator会遇到一个不可避免的问题，
virtual base class subobject的复制行为会发生多次，与前面说到的在虚拟继承
情况下虚基类被构造多次是一个意思，不同的是在这里不能抑制非most-derived 
class 对virtual base class 的赋值行为。&lt;/p&gt;
&lt;p&gt;安全的做法是把虚基类的赋值放在最后，避免被覆盖。&lt;/p&gt;
&lt;h3&gt;对象析构语意学&lt;/h3&gt;
&lt;p&gt;只有在基类拥有析构函数，或者object member拥有析构函数的时候，编译器才为类
合成析构函数，否则都被视为不需要。&lt;/p&gt;
&lt;p&gt;析构的顺序正好与构造相反：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本身的析构函数被执行。&lt;/li&gt;
&lt;li&gt;以声明的相反顺序调用member object 的析构函数，如果有的话。&lt;/li&gt;
&lt;li&gt;重设vptr 指向适当的基类的虚函数表，如果有的话。&lt;/li&gt;
&lt;li&gt;以声明相反的顺序调用上一层的析构函数，如果有的话。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果当前类是 most-derived
    class，那么以构造的相反顺序调用虚基类的析构函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;侯捷的译文为：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果class object是最底层（most-derived）的class,其constructors可能被调用；
某些用以支持这个行为的机制必须被放进来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;我认为，Lippman在这一句上要说的是，虚基类的构造函数只能由most-derived class
调用，而为了支持这一机制，需要插入一些代码来抑制非most-derived class对虚基类
构造函数的调用。同时说一点，5.4的标题个人以为应该译为“对象的效率”而非“对象的
功能”——原标题为：Object Efficency。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:注1"&gt;
&lt;p&gt;下面的叙述顺序看似与原书的顺序不一样。实际顺序并没有被调整，很多个
    “在此之前”的叙述并不适合我，我喜欢很直白的方式，按顺序来。书中的方
    式在于，从最浅显的步骤入手，然后告诉你，做这步之前，你还该做点什么。&amp;#160;&lt;a href="#fnref:注1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:注2"&gt;
&lt;p&gt;这一点上我参考英文版后，感觉侯大大的翻译并没有完全表达Lippman的原意，
所以，我以对原文的理解写下这点。Lippman的原文为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;These constructors, however, may be invoked if, and only if, the class
object represents the "most-derived class." Some mechanism supporting
this must be put into place.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#fnref:注2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category><category term="笔记"></category></entry></feed>