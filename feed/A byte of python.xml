<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Adoo's blog</title><link href="http://www.roading.org/" rel="alternate"></link><link href="http://www.roading.org/feed/A%20byte%20of%20python.xml" rel="self"></link><id>http://www.roading.org/</id><updated>2012-05-03T16:05:00+08:00</updated><entry><title>Python 基础入门笔记(5)</title><link href="http://www.roading.org//develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b05.html" rel="alternate"></link><updated>2012-05-03T16:05:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-05-03:/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b05.html</id><summary type="html">&lt;h3&gt;Pickle&lt;/h3&gt;
&lt;p&gt;python 支持一些常见模式的文件处理方式，通过read 、readline或 write
函数来读写文件，同时它还支持几种模式的读写方式，这些并没有什么特别的，略去不说。
不过python的文件处理还有一个非常有用的功能——Pickle。&lt;/p&gt;
&lt;p&gt;Pickle是python标准库提供的一个模块，它能将任意对象存储到一个文件中，
并还能从这个文件中恢复这个对象，比如：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pickle&lt;/span&gt;

&lt;span class="n"&gt;fruitlist&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;apple&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;mango&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;carrot&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;file.ob&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#将对象 fruitlist 存储到文件file.ob中&lt;/span&gt;
&lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fruitlist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;fruitlist&lt;/span&gt;
&lt;span class="c"&gt;#从文件中读取对象&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;storedlist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;storedlist&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;异常处理（Exceptions）&lt;/h3&gt;
&lt;p&gt;python 中也采用try…catch 类似的语句来捕获错误。看一个例子：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Enter something --&amp;gt; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;EOFError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Why did you do an EOF on me?&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;KeyboardInterrupt&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;You cancelled the operation.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;You entered {0}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; 
&lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;This statement must be printed&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把有可能引发错误的语句放在 try 块中，except子句则用来处理有可能发生的错误和异常。
except子句可以处理单一的错误或异常，也可以是一组包括在圆括号内的错误/异常。
如果没有给出错误或异常的名称，它会处理所有的错误和异常。
如果一个错误或异常没有被处理，那么python 将会终止程序并打印出错误信息。
else 子句在没有错误或异常出现的情况下才会被执行。
finally子语句则保证不管是有无异常出现它都会执行。我不禁意淫，如果C++中的异常处理也有这样一个语句块就美妙了
——把资源释放的代码放到这个语句块中间那是再好不过了。&lt;/p&gt;
&lt;p&gt;可以用 raise 语句来抛出异常，如 raise EOFError。 raise 语句类似C++ 中的
throw 语句。同样能被raise的异常和错误必须是直接或间接继承自 Exception类。&lt;/p&gt;
&lt;h3&gt;后记&lt;/h3&gt;
&lt;p&gt;a byte of python 是本不错的 python介绍书。对，是一本介绍书，而不是入门书。
够精简，也够易懂，你大可以花大半天一口气看完这本书，使你对python 有一个大致的了解。
看完这本书，python对不对你的胃口，应该就清楚了。这之后再慎重的决定要不要更深入的学习一下
python 。老实说，这本书我是认为不值得写什么笔记的，但它却让我完全喜欢上了python
，让我决定要深入学习一下它。但近来琐事缠身，是抽不出时间来系统的学习python 的。
至于何时能安排出比较系统的时间来学习 python？一两个月之后，又或许是半年之后，亦未可知。
于是才有了写点笔记的打算，留待真正开始学习python的时候能够快速的温习一下。&lt;/p&gt;
&lt;p&gt;参考：a byte of python –v1.92(for python 3.0)&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Thu 03 May 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b05.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="python"></category><category term="笔记"></category></entry><entry><title>Python 基础入门笔记(4)</title><link href="http://www.roading.org//develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b04.html" rel="alternate"></link><updated>2012-05-02T17:12:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-05-02:/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b04.html</id><summary type="html">&lt;p&gt;作为一门面向对象语言，类和对象是 python的一个重要的概念。关于什么是面向对象和什么是面向对象过程，这里不做赘言。
面向对象基本思想上python 并没有和C++有太大异同，这里主要对一些语法和细节上的东西做一些记录。但 python 与 C++
在对象的范围上有很大不同， python的对象定义更广义——&lt;strong&gt;python认为万物皆对象，即便类也是一个对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 python中数据成员被称为字段(fields)，而函数成员被称为方法。依照我一贯的理解，数据成员用来描述对象的属性，而函数成员可以被看作对象的行为。&lt;/p&gt;
&lt;p&gt;python中对象的字段既可以是其它类型的对象&lt;strong&gt;也可以是与自己相同类型的对象&lt;/strong&gt;。这种对象的自包含看上去很奇怪，理论上这一点是无法实现的
——如果一个A类型的对象包含了另一个A类型的对象，那么被A类型包含的那个对象也应该包含一个A类型的对象，这种包含关系将无止境。
而python之所以支持，这不得不说 python的另一特性——&lt;strong&gt;在 python中变量实质上是一个对对象的引用，而不是对象本身。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面定义了一个简单的类,之后的文字将围绕这个例子来展开。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;population&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;                 &lt;span class="c"&gt;#标记1&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;           &lt;span class="c"&gt;#标记2&lt;/span&gt;
        &lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;population&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__del__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;population&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sayHi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I&amp;#39;m&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    
    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;                &lt;span class="c"&gt;#标记3&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;howMany&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;            
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The population is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;population&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;&lt;strong&gt;类变量和实例变量&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Person类中标记1定义了一个类变量，所谓类变量是指这个变量是属于类的，等同于C++中类的静态数据成员。类变量的引用应通过类名进行,如
Person.population .&lt;/p&gt;
&lt;p&gt;实例变量指的是这个变量是属于实例的，如标记2所在行中的name。在类的成员函数中所有的类变量应通过类名引用，而所有的成员变量应通过
self引用,否则将定义一个新的变量或引起引用错误。&lt;/p&gt;
&lt;h3&gt;__init__方法和__del__方法&lt;/h3&gt;
&lt;p&gt;__init__方法用来对对象的初始化，一些初始化操作应该放在这个方法中。它与C++中的构造函数作用类似。
__init__方法在实例化一个新对象被实例化时调用。另外实例化一个新对象时，实参列表是被传给__init__调用。如
Person 类的对象创建应当是这样的： p=Person('Adoo')——__init__除 self外只有一个参数。&lt;/p&gt;
&lt;p&gt;__del__方法则在一个对象被删除时调用，因为垃圾收集器的原因这个方法的调用时机并不能被确定。如果想显式调用它，那么用一条
del 语句删除相应的对象。&lt;/p&gt;
&lt;h3&gt;方法(Methods)&lt;/h3&gt;
&lt;p&gt;python中成员函数的第一个参数是一个特殊的参数，它引用对象本身，一般将之命名为self 。
这个self 其实完全相当于C++ 中的 this 指针。self在成员函数的调用时与C++中this一样不需要被显示赋值，
编译器会自动将调用成员函数的对象作为第一个参数。如&lt;code&gt;obj.func(arg)&lt;/code&gt;这样的调用实际上被转化为类似&lt;code&gt;obj.func(object1,arg)&lt;/code&gt;的调用了。&lt;/p&gt;
&lt;p&gt;howMany函数实际上是一个静态方法，它属于类的方法而不是属于对象的的方法，这好比C++中的静态函数。定义方式，可以注意标签3。
这里howMany是没有参数的，但假如它有参数的话，它的第一个参数也不会被当作对象的引用，它没有self引用。
一个静态方法的定义除了可以在函数之前加@staticmethod 标签，还可以通过这样的形式：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;howMany&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt; 
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The population is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;population&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;howMany&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;staticmethod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;howMany&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要注意的几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类中的所有成员默认是公有的，但是所有以双下划线开头命名的成员被认为是为私有成员。&lt;/li&gt;
&lt;li&gt;关于继承，私有成员不会被继承。python支持单继承也支持多继承。
    在类名后面用一对圆括号将基类名括起来，表示该类是一个继承自基类的类。
    如果是多继承则将基类之间用逗号隔开。&lt;/li&gt;
&lt;li&gt;还是关于继承，如果继承类没有定义自己的__init__方法，那么会继承基类的__init__方法，如果继承类定义了__init__方法，那么在继承类的__init__方法中基类的__init__方法并不会被自动调用，必须显示调用它，这是与C++不同的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：a byte of python –v1.92(for python 3.0)&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Wed 02 May 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b04.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="python"></category><category term="面向对象"></category><category term="笔记"></category></entry><entry><title>Python 基础入门笔记(3)——内建数据结构</title><link href="http://www.roading.org//develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b03.html" rel="alternate"></link><updated>2012-05-01T15:11:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-05-01:/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b03.html</id><summary type="html">&lt;p&gt;Python 有四个内建的数据结构——list、tuple、dictionary、set。&lt;/p&gt;
&lt;h3&gt;列表（List）&lt;/h3&gt;
&lt;p&gt;list 是一个可以在其中存储一系列项目的数据结构。list
的项目之间需用逗号分开，并用一对中括号括将所有的项目括起来，以表明这是一个
list 。下例用以展示 list 的一些基本操作：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#定义一个 list 对象 shoplist：&lt;/span&gt;
&lt;span class="n"&gt;shoplist&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;mango&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;apple&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;bananaa&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="c"&gt;#获得一个 shoplist 的长度&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Shoplist have&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shoplist&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;items&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#访问shoplist中的对象&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The 3rd item in shoplist is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;shoplist&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="c"&gt;#往 shoplist 中插入对象&lt;/span&gt;
&lt;span class="n"&gt;shoplist&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;pear&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#从 shoplist 中删除一个项目&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;shoplist&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="c"&gt;#对 shoplist 进行排序&lt;/span&gt;
&lt;span class="n"&gt;shoplist&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;#遍历整个shoplist中的项目&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;These items are :&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;shoplist&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shoplist&lt;/span&gt; &lt;span class="n"&gt;have&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt;
&lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="n"&gt;rd&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;shoplist&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;bananaa&lt;/span&gt;
&lt;span class="n"&gt;These&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;apple&lt;/span&gt; &lt;span class="n"&gt;bananaa&lt;/span&gt; &lt;span class="n"&gt;pear&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于上面的代码有几点要注意的是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以往 shoplist 中加入任何类型的对象，也就是说，并不要求一个 list
    中的项目具有相同类型。你甚至可以往 shoplist 中插入一个list。&lt;/li&gt;
&lt;li&gt;排序函数作用于本身，
    而不是返回一个副本，这与字符串类型是不同的，因为字符串不可修改。&lt;/li&gt;
&lt;li&gt;print 函数的end关键字参数用来指定输入完成之后的输出，默认是换行符，上面的代码用空格符替代换行符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;元组(Tuple)&lt;/h3&gt;
&lt;p&gt;Tuple 在用法与概念上与 list 没有多大差别，可以将 tuple 看做是一个只读版list。也就是说tuple一经定义便不能被修改——不能添加和删除对象，也不能修改tuple中的对象。&lt;/p&gt;
&lt;p&gt;tuple中的项同样应该用逗号分开，并用圆括号将这些项目括起来以表是是一个tuple。这个圆括号是可选的，也就是说可以用以下两种方式定义一个tuple:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;tuple1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;apple&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;banana&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;tuple2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;apple&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;banana&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不过省掉那对圆括号不见得是什么好的习惯。另外当tuple只有一个项时，第一项之后必须有一个逗号，该情况下应该这样定义&lt;code&gt;mytuple=('apple',)&lt;/code&gt;。这似乎是一个古怪的约束，但是假如没有这个逗号，不带括号定义的tuple就变成了&lt;code&gt;mytuple='apple'&lt;/code&gt;这明显具有二义性。&lt;/p&gt;
&lt;h3&gt;字典(Dictionary)&lt;/h3&gt;
&lt;p&gt;字典可以看做是一组键-值(key-value)对的集合。键必须是唯一的，而每一个键关联着一个值。key必须是一个不可变的对象(如：tuple、数值型、字符串)。还要注意的是，在字典中的键值对并没有以任何方式进行排序。&lt;/p&gt;
&lt;p&gt;一个字典的定义应该照这样的格式&lt;code&gt;d={key1 : value1, key2 : value2, key3:vlue3}&lt;/code&gt;。键和值之间用冒号分隔，而键值对之间用逗号相隔，再用大括号将所有的键值对括起来。一些基本操作如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#字典的定义&lt;/span&gt;
&lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Swaroop&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;swaroop@swaroopch.com&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="s"&gt;&amp;#39;Larry&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;larry@wall.org&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="s"&gt;&amp;#39;Matsumoto&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;matz@ruby-lang.org&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="s"&gt;&amp;#39;Spammer&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;spammer@hotmail.com&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;#通过键来获取值&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Swaroop&amp;#39;s address is&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Swaroop&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="c"&gt;#删除一个键值对&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Swaroop&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="c"&gt;#遍历字典&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;contact {0} at {1}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c"&gt;#往字典中增加一个键值对&lt;/span&gt;
&lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Adoo&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;liuxiaodongxiao@hotmail.com&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;#判断字典中是否存在某键,也可以用 if ab.has_key(&amp;#39;Adoo&amp;#39;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Adoo&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Adoo&amp;#39;s address is&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Adoo&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出的结果为：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Swaroop&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;swaroop&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;swaroopch&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;
&lt;span class="n"&gt;contact&lt;/span&gt; &lt;span class="n"&gt;Matsumoto&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;matz&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;ruby&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;lang&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;org&lt;/span&gt;
&lt;span class="n"&gt;contact&lt;/span&gt; &lt;span class="n"&gt;Larry&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;larry&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;wall&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;org&lt;/span&gt;
&lt;span class="n"&gt;contact&lt;/span&gt; &lt;span class="n"&gt;Spammer&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;spammer&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;hotmail&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;
&lt;span class="n"&gt;Adoo&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;liuxiaodongxiao&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;hotmail&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;序列(Sequences)&lt;/h3&gt;
&lt;p&gt;上面介绍的三种内建数据结构都是序列，索引操作是序列的一个基本操作。通过下标操作可以直接访问序列中的对象。上面虽然已经演示了下标操作——队列和元组用数字下标，字典用关键字下标。&lt;/p&gt;
&lt;p&gt;序列的下标是从0开始的，上面的例子中只使用了下标为正数的情况，其实下标还可以为负数，如-1,-2,-3…。负数下标表示的意义为反方向的位置，如&lt;code&gt;shoplist[-1]&lt;/code&gt;返回的是shoplist的倒数第一个项目。&lt;/p&gt;
&lt;p&gt;序列不但支持负数下标还支持双下标，这对双下标表示一个区间。如shoplist[0:3]返回的是一个hoplist中从下标为1到下标为3之前的子序列副本。注意这个区间是一对半闭半开的区间。这种操作被称作切片操作(slicing operation)。如果切片操作的第二个下标超出了序列的范围，那么切片操作会到序列的末尾终止。切片操作中的两个下标都有默认值，第一个的默认值为0，第二个的大小为序列的长度。&lt;/p&gt;
&lt;p&gt;还可以给切片操作提供第三个参数，第三个参数代表切片操作的步长，它的默认值是1。步长代表了项与项之间的间距，比方&lt;code&gt;name[0:10:3]&lt;/code&gt;,返回的就是name中下标为0，3，6，9组成的子序列。&lt;/p&gt;
&lt;h3&gt;集合(set)&lt;/h3&gt;
&lt;p&gt;集合是无序简单对象的聚集。当你只关注一个对象是否存在于聚集中，而不管它存在的顺序或在出现的次数时，则适宜用集合。基本功能：判断是否是集合的成员、一个集合是不是另一个集合的子集、获取两个集合的交集等等。实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#定义一个集合,要使用set函数&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;briza&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;russia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;india&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="c"&gt;#判断对象是否在集合中&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;india&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;india is in ?&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;india&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="c"&gt;#往集合中添加对象&lt;/span&gt;
&lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;china&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#从集合中删除对象&lt;/span&gt;
&lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;russia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#求两个集合的交集，也可以使用 s.intersection(sc)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出的结果：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;india&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;True&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;briza&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;india&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考：a byte of python –v1.92(for python 3.0)&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Tue 01 May 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b03.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="data structure"></category><category term="python"></category><category term="笔记"></category></entry><entry><title>Python 基础入门笔记(2)——函数、模块和包</title><link href="http://www.roading.org//develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b02%e5%87%bd%e6%95%b0%e3%80%81%e6%a8%a1%e5%9d%97%e5%92%8c%e5%8c%85.html" rel="alternate"></link><updated>2012-04-29T15:27:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-04-29:/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b02%e5%87%bd%e6%95%b0%e3%80%81%e6%a8%a1%e5%9d%97%e5%92%8c%e5%8c%85.html</id><summary type="html">&lt;p&gt;函数、模块和包对于代码的复用都有非常重要的意义，当然面向对象中的类其实在代码的复用性上也有举足轻重的地位。前天睡前看了《a byte of python》中关于函数、模块和包的这个部分，今天又查了查官网文档以及网上的其它一些资料，把一些疑惑给解决。现在写一下关于这部分的笔记，用以加强记忆同时以备后用。&lt;/p&gt;
&lt;h3&gt;函数&lt;/h3&gt;
&lt;p&gt;python 中用关键字def来定义函数。一个完整的函数定义应该以关键字def
开始后面紧跟着函数名和用括号括起来的形参列表，并以一个冒号作为该行的结尾，紧跟着则是函数的代码块。实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;printMax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;is maximin&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;is equal to&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;is maximum&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Python同样支持为参数提供一个默认值&lt;/strong&gt;，函数在调用时有默认值的形参是可选的，也就是说这样的参数可以不用给它提供实参。这在很多情况下都非常有用，比方一个窗口的创建函数——拥有很多形参来设定窗口的属性，但通常创建一个窗口可能只有两三个属性需要特别设定，其它都可以用默认值。Python的默认参数与C++的默认参数我感觉是一样的。都要求提供默认值的形参处于形参队列的末尾，换句话说，提供默认值得形参之后不能有不提供默认值的形参。其原因在于在调用函数时，用实参对形参赋值一般都是按位置顺序进行的。&lt;/p&gt;
&lt;p&gt;说到“实参对形参赋值一般是按位置顺序进行的(这样的参数叫做位置参数，译自positional arguments)”，则不能不提一提&lt;strong&gt;关键字参数（Keyword Aruguments）。&lt;/strong&gt;所谓关键字参数是指，可以显示的按形参名赋值实参，而并非根据形参的位置顺序。比方&lt;code&gt;printMax(b=5,a=10)&lt;/code&gt;。当然，这个例子并没有体现出关键字参数的价值，其价值在于可以明确指出参数的角色。比方有一个文件内容拷贝函数&lt;code&gt;copyFile(to,from)&lt;/code&gt; ——将文件 from 中的内容拷贝到文件to中。使用类似的函数的时候，使用者必须记住参数的顺序，但如果支持关键字参数的话，则不必关心位置顺序，将正确的文件名赋值给正确的形参就OK。&lt;/p&gt;
&lt;p&gt;python 中&lt;strong&gt;可变形参(VarArgs Parameters)&lt;/strong&gt;的概念非常清晰，在一个函数之前加上&lt;code&gt;*&lt;/code&gt;号或者&lt;code&gt;**&lt;/code&gt;号就表示这个形参代表了个数不确定的参数，如&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;resultprint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的代码将会输出：15。 函数sum的形参number之前有&lt;code&gt;*&lt;/code&gt;号标记，表明number是一个可变形参，实际代表的参数数目由调用时传入的实参数目决定。原理很简单，一个可变形参，如numbers, 会将从它那一点开始的所有&lt;strong&gt;位置实参(positional arguments)&lt;/strong&gt;收集为一个 numbers列表。形参之前用两个星号&lt;code&gt;**&lt;/code&gt;标记，同样表示一个可变形参，只是双星号的可变形参是将将从它自己开始的位置实参都收集为一个字典(dictionary)。队列(list)和字典(dictionary)都是python提供的基本数据结构。有趣的一点是 python
中的可变形参并不一定要放在形参队列的末尾，这就带来了一种副产品
Keywords-only parameters，请看:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;desc&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;desc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但上面的例子中的 desc形参只能以关键字参数的方式进行调用了。调用方法如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#正确的调用&lt;/span&gt;
&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;desc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The sum of my salary is：&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#错误的调用，实参&amp;#39;The sum of my salary is：&amp;#39;也会被收入numbers中&lt;/span&gt;
&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The sum of my salary is：&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果一个函数没有提供显示的返回语句，python 会隐式的提供一条返回语句
return None 。None 是 python 中的一个特殊类型，表示没有任何东西。&lt;/p&gt;
&lt;h3&gt;模块&lt;/h3&gt;
&lt;p&gt;python既支持python语言写的模块同时也支持多种其它语言写的模块。这儿只看最简单的python写的模块，而不管其它。&lt;strong&gt;一个扩展名为.py的文件其实就是一个python模块&lt;/strong&gt;。模块能被其它程序导入并使用它的功能，例如下面对准库的使用：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#file: C:\Users\Adoo-\Desktop\using_sys.pyimport sys&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The command line arguments are:&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;The PYTHONPATH is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;C:&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;Users&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;Adoo&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;Desktop&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;using_sys&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pyThe&lt;/span&gt; &lt;span class="n"&gt;PYTHONPATH&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Users&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Adoo&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Desktop&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Python32&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Lib&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;idlelib&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;windows&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;SYSTEM32&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;python32&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zip&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Python32&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;DLLs&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Python32&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Python32&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Python32&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;site&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;packages&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上例中用一条import语句来告诉python我们想使用sys模块。对于一个使用用python
编写的模块而言，当python执行 &lt;strong&gt;import 语句时,python 解释器会从sys.path中列出的路径中查找&lt;/strong&gt;，如果找到了就会执行模块中包含的语句，然后这个模块就可以用了。模块的初始化操作只会在第一次被导入时执行。模块被导入后就可以通过点操作符来使用模块中的函数或变量，如sys.argv或
sys.path。&lt;/p&gt;
&lt;p&gt;要注意，要使用一个模块，必须确保这个模块所在的路径包含在sys.path中。所以，要么将你的模块复制到sys.path列出的路径中的一个去，要么把你的模块路径加入到sys.path中。执行文件所在的当前路径会被自动添加到sys.path中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;form … import 语句：&lt;/strong&gt;用 from sys import argv语句可以直接导入sys模块中的argv变量，而且只导入argv.此时sys中的argv可以直接使用，而不用通过sys.argv的方式引用。使用&lt;code&gt;from sys import *&lt;/code&gt;语句可以导入sys中的所有公有的和非双下划线开头的名字，不过这肯定不是一种好的习惯——容易造成名字冲突，如C++中的using namespace 语句。&lt;/p&gt;
&lt;p&gt;模块中&lt;strong&gt;内置一个&lt;code&gt;__name__&lt;/code&gt;属性&lt;/strong&gt;。如果一个模块是被&lt;code&gt;import&lt;/code&gt; 的, 那么
&lt;code&gt;__name__&lt;/code&gt;的值通常为去除模块扩展名的文件名。如果模块式独立运行的(也就是说它是主模块)&lt;code&gt;__name__&lt;/code&gt;的值将是'&lt;code&gt;__main__'。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;导入一个模块相对来说比较费时，所以 Python提供了一种&lt;strong&gt;以.pyc为扩展名的按字节编译的文件&lt;/strong&gt;.当模块被第一次导入时，如果python具有当前路径的写入权限，.pyc
文件会被创建在与模块文件相同路径下。有.pyc文件将会非常有利，当下次从其它程序再导入这个模块时，会快得多。因为导入模块的一些必要处理已经做好了。另外.pyc文件也是平台无关的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dir()函数返回包含指定模块中所有名字的队列（list）&lt;/strong&gt;，注意用 import 语句导入的名字也在其中。在不提供参数给dir()的情况下，将返回包含当前模块的所有名字的队列。dir()函数其实可以作用于任何对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以用一个del 语句删除一个变量或者名字&lt;/strong&gt;，被&lt;code&gt;del&lt;/code&gt;删除的名字或变量，在之后的语句里将不可以被访问。&lt;/p&gt;
&lt;h3&gt;包&lt;/h3&gt;
&lt;p&gt;包其实就是用文件夹将模块组织起来，不过文件夹下必须要一个__init__.py文件，只有文件夹下有一个名为__init__.py的文件，该文件夹才会被当作一个包看待。但__init__.py文件可以是空的。&lt;/p&gt;
&lt;p&gt;可以用 &lt;code&gt;from…import…&lt;/code&gt;语句来导入包中的相关模块。要注意的一点是，假如有一个名为package的包，那么&lt;code&gt;from package import *&lt;/code&gt;语句并不会如你想象的导入包中所有模块。它只导入在__init__.py中__all__属性中所列出的模块。例如，当__init__.py中__all__的定义如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;__all__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;mould1&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;moudle2&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;moudle3&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么，from package import * 只会导入mould1、moudle2和moudle3三个模块。&lt;/p&gt;
&lt;p&gt;参考：a byte of python –v1.92(for python 3.0) 以及pyhon.org关于python3.2的很小部分文档。以及这篇博客：&lt;a href="http://pydoing.blogspot.com/2011/02/python-package.html"&gt;http://pydoing.blogspot.com/2011/02/python-package.html&lt;/a&gt;&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Sun 29 April 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b02%e5%87%bd%e6%95%b0%e3%80%81%e6%a8%a1%e5%9d%97%e5%92%8c%e5%8c%85.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="python"></category><category term="代码组织"></category><category term="笔记"></category></entry><entry><title>Python 基础入门笔记(1)</title><link href="http://www.roading.org//develop/python/python-%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%80%e7%ac%94%e8%ae%b01.html" rel="alternate"></link><updated>2012-04-24T17:25:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-04-24:/develop/python/python-%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%80%e7%ac%94%e8%ae%b01.html</id><summary type="html">&lt;h3&gt;内建类型&lt;/h3&gt;
&lt;p&gt;python 中提供的内建类型大概与C++中提供的相仿，却更简洁。&lt;/p&gt;
&lt;p&gt;数值方面的内建类型有整型、浮点型、和复数类型三种。在C++中虽然也有复数类型，但却是由标准库提供的。另外，python中整数的表示就是整形，没有如C++中的长整型短整形之说。浮点数的表示也没有浮点型和双精度型的区分。&lt;/p&gt;
&lt;p&gt;字符串则可以分为字符串(string)和原生字符串(raw string)两种类型。可以如同
C++ 一般用一对双引号来指定一个字符串，如 "This is a
string"。在python中单引号(‘)与双引号(“)拥有相同的功能——一对单引号也可以表示一个字符串，如&lt;code&gt;'This is a string'&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于一个多行的字符串，可以用转义字符来表示，例如&lt;code&gt;'This is the first line.\nThis is the second line.'&lt;/code&gt;，但是python同时提供了一种更友好的方式，用三引号('''或""")来表示一个多行的字符串，如：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39; this is a multi-line string.&lt;/span&gt;
&lt;span class="sd"&gt;this is the second line.&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;what your name ?&amp;quot; I asked.&lt;/span&gt;
&lt;span class="sd"&gt;he said &amp;quot;My name is ***&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面介绍有单引号、双引号、三引号三种引号。当用其中一种来指定一个字符串时，可以在字符串中直接使用另外两种引号，例如上面的多行字符串中可以直接使用
&lt;code&gt;"&lt;/code&gt;，而无需写成 &lt;code&gt;/"&lt;/code&gt;。这是因为字符串可以找到正确的结尾，而不会被提前截断。&lt;/p&gt;
&lt;p&gt;字符串无需再赘言，原生字符串可以在字符串之前加上一个r或者R来表示，例如&lt;code&gt;r'\nThis is a raw string'&lt;/code&gt;。原生字符串不会对字符串进行任何特殊处理，例如&lt;code&gt;r'\nThis is a raw string'&lt;/code&gt;中的&lt;code&gt;\n&lt;/code&gt;不会被转义处理，而是直接代表&lt;code&gt;\&lt;/code&gt;和&lt;code&gt;n&lt;/code&gt;两个字符。&lt;/p&gt;
&lt;p&gt;python 没有char类型。&lt;/p&gt;
&lt;h3&gt;变量&lt;/h3&gt;
&lt;p&gt;python的变量命名规则与C++类似。定义上却有很大不同，定义一个python变量，直接给它赋值就可以了，并不需要声明它的数据类型，变量的类型决定于初始化它的对象类型。C++11中的&lt;code&gt;auto&lt;/code&gt;关键词有类似作用，不过实质上是不一样的。实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&amp;#39; this is a multi-line string.&lt;/span&gt;
&lt;span class="s"&gt;this is the second line.&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;python中一切事物皆为对象，即便是内建类型也是对象，这是与C++不同的。&lt;/p&gt;
&lt;h3&gt;代码书写约定&lt;/h3&gt;
&lt;p&gt;python
隐式约定每一物理行表示一行语句，所以python中的一行语句写完不需以分号结束，虽然在语句末尾加上分号也无伤大雅，但画蛇添足的事多做无益。但是如果要将多行语句写在同一物理行，那么则必须用逗号分开。如果某行语句过长，想写在两行，则可以使用连接符&lt;code&gt;\\&lt;/code&gt;。实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#将多条语句写在同一物理行&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#将一行语句写在多个物理行。&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;this is a string. &lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;
&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;continue&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当行中使用了圆括号、方括号或波形括号的时候，不需要用&lt;code&gt;\\&lt;/code&gt;来连接多行,这种情况被称为隐式行连接。&lt;/p&gt;
&lt;p&gt;缩进：每行开始的缩进在python中相当重要，python中并不用大括号或者begin、end类似的关键词来界定语句块，缩进才是它的标准。换言之，行首的缩进量决定了语句的分组，同一层级的语句必须要有相同的缩进量。python支持空格符和制表符来表示缩进，但确保只使用其中一种来表示缩进，千万不要混搭使用。&lt;/p&gt;
&lt;h3&gt;表达式&lt;/h3&gt;
&lt;p&gt;python的一些操作符大体上与C++一致，下面罗列几种与C++有差异的操作符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乘法运算&lt;code&gt;*&lt;/code&gt;，对字符串也能进行乘法运算，如&lt;code&gt;'a'*3&lt;/code&gt; 返回&lt;code&gt;'aaa'&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;求幂运算符&lt;code&gt;**&lt;/code&gt;，&lt;code&gt;x**y&lt;/code&gt; 表示求x的y此幂，例如&lt;code&gt;2**3&lt;/code&gt;的返回值为8.&lt;/li&gt;
&lt;li&gt;除法运算&lt;code&gt;/&lt;/code&gt;，与C++不同,整数之间的除法会返回小数，如1/2返回小数0.5而不是0.&lt;/li&gt;
&lt;li&gt;floor division(地板除？)运算符&lt;code&gt;//&lt;/code&gt; ，返回&lt;code&gt;x//y&lt;/code&gt;结果中的整数部分。如&lt;code&gt;6//5&lt;/code&gt;返回1.&lt;/li&gt;
&lt;li&gt;按位异或操作符&lt;code&gt;\^&lt;/code&gt;,如&lt;code&gt;3\^2&lt;/code&gt;返回1，&lt;code&gt;5\^3&lt;/code&gt;返回6。&lt;/li&gt;
&lt;li&gt;按位反转操作符&lt;code&gt;\~&lt;/code&gt;，一元运算。&lt;code&gt;\~x&lt;/code&gt;返回&lt;code&gt;-(x+1)&lt;/code&gt;，也就是说&lt;code&gt;\~5&lt;/code&gt;的结果为-6.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;not&lt;/code&gt;运算符，一元运算，求逻辑非。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;and&lt;/code&gt;运算符，求逻辑与，对应C++中&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;or&lt;/code&gt;运算符，求逻辑或，对应C++中&lt;code&gt;||&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运算符的与表达式的更多介绍: &lt;a href="http://www.python.org/\~gbrandl/build/html/reference/expressions.html"&gt;http://www.python.org/\~gbrandl/build/html/reference/expressions.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;运算符在表达式的优先级列表: &lt;a href="http://www.python.org/\~gbrandl/build/html/reference/expressions.html"&gt;http://www.python.org/\~gbrandl/build/html/reference/expressions.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;控制流&lt;/h3&gt;
&lt;p&gt;python
有一种分支结构语句——if语句。但不存在switch语句。两种循环结构语句——while
和for语句，没有do …while语句。有点奇妙的是所有者三种语句都提供一个可选的else分支语句，没错不仅if语句有else分支，while与for也有else分支。&lt;/p&gt;
&lt;p&gt;if语句中可以将一个嵌套的if…else…if…else语句合并成if…elif…else语句，后者可以很好的替代switch语句。if语句的实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;
&lt;span class="n"&gt;guess&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Enter a number:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt; 
   &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;you guessed it&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="err"&gt;   &lt;/span&gt; 
   &lt;span class="n"&gt;prinnt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;no, it is a little higher than that&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="err"&gt;  &lt;/span&gt;
   &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;no it is a little lower than that&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实际上相当于：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;22&lt;/span&gt;
&lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Enter a number:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;you guessed it&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;no, it is a little higher than that&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;no it is a little lower than that&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要注意两点：
&lt;em&gt;   判断表达式不需要括号;
&lt;/em&gt;   每一个分支语句之前需要冒号。&lt;/p&gt;
&lt;p&gt;python中循环结构的一个比较鲜明的特点就是多了一个else分支，这个else在循环完成后执行。&lt;/p&gt;
&lt;p&gt;while循环的实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;count: {0}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;The while loop is over.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;for循环的实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;i:{0}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the for loop is over&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从语法上来讲，for与while给了我一些不同的感觉，虽然都是循环控制语句，但给人的感觉是while更趋向于条件控制的循环，而for则更倾向于迭代循环。&lt;/p&gt;
&lt;p&gt;python中也有break与continue语句与C++中的没有区别。要注意的是如果循环是以break语句跳出的话，那么else分支也会被跳过。&lt;/p&gt;
&lt;p&gt;注：这篇笔记我主要重点记录一些 python在语法上与C++的一些异同点，以及我认为自己需要留意的地方，所以他仅仅是一篇笔记。&lt;/p&gt;
&lt;p&gt;参考：a byte of python –v1.92(for python 3.0) 以及pyhon.org关于python3.2的很小部分文档。&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Tue 24 April 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/python/python-%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%80%e7%ac%94%e8%ae%b01.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="python"></category><category term="笔记"></category></entry></feed>