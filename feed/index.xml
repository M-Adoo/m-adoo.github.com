<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Adoo's blog</title><link href="http://www.roading.org/" rel="alternate"></link><link href="http://www.roading.org/feed/index.xml" rel="self"></link><id>http://www.roading.org/</id><updated>2012-12-25T03:30:00+08:00</updated><entry><title>未半</title><link href="http://www.roading.org/essaies/less_than_half_of_year.html" rel="alternate"></link><updated>2012-12-25T03:30:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-12-25:essaies/less_than_half_of_year.html</id><summary type="html">&lt;p&gt;来珠海也近半年了，半年来并没有太大的不顺。大概却正因为这顺利，让我恍然
未觉的过了半年。时间过得如此悄无声息，让我战战栗生出了一股惶恐来。每过
一月，或又仅有一旬，当我注意到桌上的台历忘了翻动，又或者电脑上的日期让
我觉得陌生时，我总觉得我应该静下来好好想想，生活是不是驶往我期待的方向。&lt;/p&gt;
&lt;p&gt;我原来想到“半”不免就生出一股沮丧来。半年的时间，便如同朝暮一般，来时的
景象，朋友间的相约，路上的拥挤，犹在眼前。冬夏之替，也只如隔一日。但任
我觉得只是短短的意象，却又是实打实的半年，我只恨这半年没有留下更多点记
忆，能做多点想做的事情。&lt;/p&gt;
&lt;p&gt;若单单是这偶尔感由心生的点点悲哀的话，也不会叫我如何的。便是一觉睡来也
就揭过，如何能令我这心思粗鄙，心间缺少玲珑的人时时挂怀呢？&lt;/p&gt;
&lt;p&gt;叫我忧心的却另有其它几样小事。&lt;/p&gt;
&lt;p&gt;我来时极想做的几件事一件也没能做成，极想看的几本书一本也没有去看。前几
日又恰巧读到了知堂的一段笔记——“转瞬仲冬，学术无进，而马齿渐增，不觉恧
然”——这是多么和我相像的一种心情。我所虑的又不止于此。我原来像做的事、
想看的书，半年之后依旧，只是时间已过半年。我只怕十年八载之后，依旧如现
在这般想法，然后感叹十年转瞬。我太怕在安逸中老去，忘却了我来这世界的初
衷，相反，我倒更愿意哪怕在困境中前行，却能一直砥砺品行，让自己铭记最初
的想法。&lt;/p&gt;
&lt;p&gt;知堂那段话让我心生共鸣之外，也令我“不觉恧然”，他那段日记大概十三四岁所
记，而这样的道理，我却明白的晚了许多。&lt;/p&gt;
&lt;p&gt;除却知堂那段话，却又有一段零碎的梦也触动了我的神经。这段梦是近断时间做
的，哪天晚上也记不得了，这梦可说平凡无奇，却又有些怪诞不经。我梦见了不
知是回到了小学，还是初中时代，端坐在教室读书，周身同学连我在内，却并没
有回归童颜，都是一副大人模样。这样不讲逻辑的事情，出现在梦中，本是在平
常不过，但我坚信，它是要叫我明白逝者如斯，不可回追的道理，也是要叫我明
白，物是人非，沧海桑田的残酷。&lt;/p&gt;
&lt;p&gt;下午，我再无法抑制这种情感的上升，于是打开了编辑器。编辑器中有一条“未
半”的标题、一条“2012-12-16 07：30”的时间戳、一句“我来珠海也近半年了”的
开头。十七号写下一个“未半”的标题，一是心里感叹半年过得太快，但距离半年
尚差几日，可以说是“未半”。再则，若是倒过来看，“半”也就成了“未”，掺杂点
未来的意为，也能带股生气来。今日已是二十五，半年也足足有了，无所谓“未
半”了。我于是又慎重的关了编辑器，拿出笔和纸，记下上文。&lt;/p&gt;
&lt;p&gt;十二月二十五日于莲山巷。&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          周二 25 十二月 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.orgessaies/less_than_half_of_year.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="随笔"></category></entry><entry><title>载酒买花年少事，浑不似，旧心情</title><link href="http://www.roading.org//essaies/lonely.html" rel="alternate"></link><updated>2012-09-14T00:00:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-09-14:/essaies/lonely.html</id><summary type="html">&lt;p&gt;当我打开记事本想写点什么的时候，写一个怎样的题目却让我犯难。难在我
并无什么特别的要求，标题党？我不需要夺人眼球。做点概括？我也并没有
要具体写点什么东西。我想大概这篇短文并不需要一个标题。不过，鉴于这
个世界有这么多长着脑袋却并没有什么用处的脑残们，我认为我的这篇短文
也配拥有一个标题，尽管它或许并没有太大的用处。&lt;/p&gt;
&lt;p&gt;好在我并不是太纠结的人。随意从桌头抽出一本书，然后随意翻开一页，从
里面取一句，足矣。老实说，我不太喜欢宋词——长短句，浅唱低吟，听着好
听，但更像是为诉苦叫春量身定做的，你若读这两种题材的词句，总能分外
打动人心。不过，说来世界总是奇妙的，随便挑捡的这句话，却也能称了我
的心情。&lt;/p&gt;
&lt;p&gt;写这篇短文我打算了很久，迟迟不能动笔的原因在于，我每天在上班之前十
五分钟的想法，被八个钟头的编程抹去。而晚上，有太多事情排不上号，而
这甚至连事情都算不上。一天的大部分时间里，我大概和我面前的那台机器
一般无二，但沉重的心情总在梦醒时分汹涌而来。我不是感情细腻的家伙，
也尽管一再坚信自己能忍耐寂寞、孤独与不被承认。但却越来越发觉，这个
世界存在着人类挣脱不掉的孤独，你安心忍耐也好，你拼命挣扎也罢，它总
能抓住机会爆发。&lt;/p&gt;
&lt;p&gt;会有这么一段日子，我们有太多想做的事情，却没有时间去做了。上半年为
还这样告诫自己：“诸般烦恼，只因想的太多，做的太少。”一个背身的功夫，
有太多的事情，不是不去做，而是你迟缓的脚步再难跟上时间的步伐。时间
慢慢会教会人，或者说逼迫人做一些取舍，你只能叹息，还是叹息。时间也
会做出一些决定，你或者接受，或者反抗了之后接受。&lt;/p&gt;
&lt;p&gt;生活总会有许多意想不到的困难，我当然明白这一切，待再回头时不过是一
抹轻笑，并不能算得了多大的难处。只是假如硬要在浮华的世界中寻找清静，
却并不容易真的得到内心的安宁。&lt;/p&gt;
&lt;p&gt;大概每个人都需要一个哑巴辛格当朋友，他总用睿智的眼神告诉你他能理解
你所说，却从不言语。&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          周五 14 九月 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/essaies/lonely.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="随笔"></category></entry><entry><title>Python 基础入门笔记(5)</title><link href="http://www.roading.org//develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b05.html" rel="alternate"></link><updated>2012-05-03T16:05:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-05-03:/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b05.html</id><summary type="html">&lt;h3&gt;Pickle&lt;/h3&gt;
&lt;p&gt;python 支持一些常见模式的文件处理方式，通过read 、readline或 write
函数来读写文件，同时它还支持几种模式的读写方式，这些并没有什么特别的，略去不说。
不过python的文件处理还有一个非常有用的功能——Pickle。&lt;/p&gt;
&lt;p&gt;Pickle是python标准库提供的一个模块，它能将任意对象存储到一个文件中，
并还能从这个文件中恢复这个对象，比如：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pickle&lt;/span&gt;

&lt;span class="n"&gt;fruitlist&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;apple&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;mango&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;carrot&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;file.ob&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#将对象 fruitlist 存储到文件file.ob中&lt;/span&gt;
&lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fruitlist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;fruitlist&lt;/span&gt;
&lt;span class="c"&gt;#从文件中读取对象&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;storedlist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;storedlist&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;异常处理（Exceptions）&lt;/h3&gt;
&lt;p&gt;python 中也采用try…catch 类似的语句来捕获错误。看一个例子：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Enter something --&amp;gt; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;EOFError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Why did you do an EOF on me?&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;KeyboardInterrupt&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;You cancelled the operation.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;You entered {0}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; 
&lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;This statement must be printed&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把有可能引发错误的语句放在 try 块中，except子句则用来处理有可能发生的错误和异常。
except子句可以处理单一的错误或异常，也可以是一组包括在圆括号内的错误/异常。
如果没有给出错误或异常的名称，它会处理所有的错误和异常。
如果一个错误或异常没有被处理，那么python 将会终止程序并打印出错误信息。
else 子句在没有错误或异常出现的情况下才会被执行。
finally子语句则保证不管是有无异常出现它都会执行。我不禁意淫，如果C++中的异常处理也有这样一个语句块就美妙了
——把资源释放的代码放到这个语句块中间那是再好不过了。&lt;/p&gt;
&lt;p&gt;可以用 raise 语句来抛出异常，如 raise EOFError。 raise 语句类似C++ 中的
throw 语句。同样能被raise的异常和错误必须是直接或间接继承自 Exception类。&lt;/p&gt;
&lt;h3&gt;后记&lt;/h3&gt;
&lt;p&gt;a byte of python 是本不错的 python介绍书。对，是一本介绍书，而不是入门书。
够精简，也够易懂，你大可以花大半天一口气看完这本书，使你对python 有一个大致的了解。
看完这本书，python对不对你的胃口，应该就清楚了。这之后再慎重的决定要不要更深入的学习一下
python 。老实说，这本书我是认为不值得写什么笔记的，但它却让我完全喜欢上了python
，让我决定要深入学习一下它。但近来琐事缠身，是抽不出时间来系统的学习python 的。
至于何时能安排出比较系统的时间来学习 python？一两个月之后，又或许是半年之后，亦未可知。
于是才有了写点笔记的打算，留待真正开始学习python的时候能够快速的温习一下。&lt;/p&gt;
&lt;p&gt;参考：a byte of python –v1.92(for python 3.0)&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          周四 03 五月 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b05.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="python"></category><category term="笔记"></category></entry><entry><title>Python 基础入门笔记(4)</title><link href="http://www.roading.org//develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b04.html" rel="alternate"></link><updated>2012-05-02T17:12:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-05-02:/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b04.html</id><summary type="html">&lt;p&gt;作为一门面向对象语言，类和对象是 python的一个重要的概念。关于什么是面向对象和什么是面向对象过程，这里不做赘言。
面向对象基本思想上python 并没有和C++有太大异同，这里主要对一些语法和细节上的东西做一些记录。但 python 与 C++
在对象的范围上有很大不同， python的对象定义更广义——&lt;strong&gt;python认为万物皆对象，即便类也是一个对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 python中数据成员被称为字段(fields)，而函数成员被称为方法。依照我一贯的理解，数据成员用来描述对象的属性，而函数成员可以被看作对象的行为。&lt;/p&gt;
&lt;p&gt;python中对象的字段既可以是其它类型的对象&lt;strong&gt;也可以是与自己相同类型的对象&lt;/strong&gt;。这种对象的自包含看上去很奇怪，理论上这一点是无法实现的
——如果一个A类型的对象包含了另一个A类型的对象，那么被A类型包含的那个对象也应该包含一个A类型的对象，这种包含关系将无止境。
而python之所以支持，这不得不说 python的另一特性——&lt;strong&gt;在 python中变量实质上是一个对对象的引用，而不是对象本身。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面定义了一个简单的类,之后的文字将围绕这个例子来展开。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;population&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;                 &lt;span class="c"&gt;#标记1&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;           &lt;span class="c"&gt;#标记2&lt;/span&gt;
        &lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;population&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__del__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;population&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sayHi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I&amp;#39;m&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    
    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;                &lt;span class="c"&gt;#标记3&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;howMany&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;            
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The population is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;population&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;&lt;strong&gt;类变量和实例变量&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Person类中标记1定义了一个类变量，所谓类变量是指这个变量是属于类的，等同于C++中类的静态数据成员。类变量的引用应通过类名进行,如
Person.population .&lt;/p&gt;
&lt;p&gt;实例变量指的是这个变量是属于实例的，如标记2所在行中的name。在类的成员函数中所有的类变量应通过类名引用，而所有的成员变量应通过
self引用,否则将定义一个新的变量或引起引用错误。&lt;/p&gt;
&lt;h3&gt;__init__方法和__del__方法&lt;/h3&gt;
&lt;p&gt;__init__方法用来对对象的初始化，一些初始化操作应该放在这个方法中。它与C++中的构造函数作用类似。
__init__方法在实例化一个新对象被实例化时调用。另外实例化一个新对象时，实参列表是被传给__init__调用。如
Person 类的对象创建应当是这样的： p=Person('Adoo')——__init__除 self外只有一个参数。&lt;/p&gt;
&lt;p&gt;__del__方法则在一个对象被删除时调用，因为垃圾收集器的原因这个方法的调用时机并不能被确定。如果想显式调用它，那么用一条
del 语句删除相应的对象。&lt;/p&gt;
&lt;h3&gt;方法(Methods)&lt;/h3&gt;
&lt;p&gt;python中成员函数的第一个参数是一个特殊的参数，它引用对象本身，一般将之命名为self 。
这个self 其实完全相当于C++ 中的 this 指针。self在成员函数的调用时与C++中this一样不需要被显示赋值，
编译器会自动将调用成员函数的对象作为第一个参数。如&lt;code&gt;obj.func(arg)&lt;/code&gt;这样的调用实际上被转化为类似&lt;code&gt;obj.func(object1,arg)&lt;/code&gt;的调用了。&lt;/p&gt;
&lt;p&gt;howMany函数实际上是一个静态方法，它属于类的方法而不是属于对象的的方法，这好比C++中的静态函数。定义方式，可以注意标签3。
这里howMany是没有参数的，但假如它有参数的话，它的第一个参数也不会被当作对象的引用，它没有self引用。
一个静态方法的定义除了可以在函数之前加@staticmethod 标签，还可以通过这样的形式：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;howMany&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt; 
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The population is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;population&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;howMany&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;staticmethod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;howMany&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要注意的几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类中的所有成员默认是公有的，但是所有以双下划线开头命名的成员被认为是为私有成员。&lt;/li&gt;
&lt;li&gt;关于继承，私有成员不会被继承。python支持单继承也支持多继承。
    在类名后面用一对圆括号将基类名括起来，表示该类是一个继承自基类的类。
    如果是多继承则将基类之间用逗号隔开。&lt;/li&gt;
&lt;li&gt;还是关于继承，如果继承类没有定义自己的__init__方法，那么会继承基类的__init__方法，如果继承类定义了__init__方法，那么在继承类的__init__方法中基类的__init__方法并不会被自动调用，必须显示调用它，这是与C++不同的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：a byte of python –v1.92(for python 3.0)&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          周三 02 五月 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b04.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="python"></category><category term="面向对象"></category><category term="笔记"></category></entry><entry><title>Python 基础入门笔记(3)——内建数据结构</title><link href="http://www.roading.org//develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b03.html" rel="alternate"></link><updated>2012-05-01T15:11:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-05-01:/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b03.html</id><summary type="html">&lt;p&gt;Python 有四个内建的数据结构——list、tuple、dictionary、set。&lt;/p&gt;
&lt;h3&gt;列表（List）&lt;/h3&gt;
&lt;p&gt;list 是一个可以在其中存储一系列项目的数据结构。list
的项目之间需用逗号分开，并用一对中括号括将所有的项目括起来，以表明这是一个
list 。下例用以展示 list 的一些基本操作：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#定义一个 list 对象 shoplist：&lt;/span&gt;
&lt;span class="n"&gt;shoplist&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;mango&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;apple&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;bananaa&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="c"&gt;#获得一个 shoplist 的长度&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Shoplist have&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shoplist&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;items&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#访问shoplist中的对象&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The 3rd item in shoplist is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;shoplist&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="c"&gt;#往 shoplist 中插入对象&lt;/span&gt;
&lt;span class="n"&gt;shoplist&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;pear&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#从 shoplist 中删除一个项目&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;shoplist&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="c"&gt;#对 shoplist 进行排序&lt;/span&gt;
&lt;span class="n"&gt;shoplist&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;#遍历整个shoplist中的项目&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;These items are :&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;shoplist&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shoplist&lt;/span&gt; &lt;span class="n"&gt;have&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt;
&lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="n"&gt;rd&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;shoplist&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;bananaa&lt;/span&gt;
&lt;span class="n"&gt;These&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;apple&lt;/span&gt; &lt;span class="n"&gt;bananaa&lt;/span&gt; &lt;span class="n"&gt;pear&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于上面的代码有几点要注意的是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以往 shoplist 中加入任何类型的对象，也就是说，并不要求一个 list
    中的项目具有相同类型。你甚至可以往 shoplist 中插入一个list。&lt;/li&gt;
&lt;li&gt;排序函数作用于本身，
    而不是返回一个副本，这与字符串类型是不同的，因为字符串不可修改。&lt;/li&gt;
&lt;li&gt;print 函数的end关键字参数用来指定输入完成之后的输出，默认是换行符，上面的代码用空格符替代换行符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;元组(Tuple)&lt;/h3&gt;
&lt;p&gt;Tuple 在用法与概念上与 list 没有多大差别，可以将 tuple 看做是一个只读版list。也就是说tuple一经定义便不能被修改——不能添加和删除对象，也不能修改tuple中的对象。&lt;/p&gt;
&lt;p&gt;tuple中的项同样应该用逗号分开，并用圆括号将这些项目括起来以表是是一个tuple。这个圆括号是可选的，也就是说可以用以下两种方式定义一个tuple:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;tuple1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;apple&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;banana&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;tuple2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;apple&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;banana&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不过省掉那对圆括号不见得是什么好的习惯。另外当tuple只有一个项时，第一项之后必须有一个逗号，该情况下应该这样定义&lt;code&gt;mytuple=('apple',)&lt;/code&gt;。这似乎是一个古怪的约束，但是假如没有这个逗号，不带括号定义的tuple就变成了&lt;code&gt;mytuple='apple'&lt;/code&gt;这明显具有二义性。&lt;/p&gt;
&lt;h3&gt;字典(Dictionary)&lt;/h3&gt;
&lt;p&gt;字典可以看做是一组键-值(key-value)对的集合。键必须是唯一的，而每一个键关联着一个值。key必须是一个不可变的对象(如：tuple、数值型、字符串)。还要注意的是，在字典中的键值对并没有以任何方式进行排序。&lt;/p&gt;
&lt;p&gt;一个字典的定义应该照这样的格式&lt;code&gt;d={key1 : value1, key2 : value2, key3:vlue3}&lt;/code&gt;。键和值之间用冒号分隔，而键值对之间用逗号相隔，再用大括号将所有的键值对括起来。一些基本操作如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#字典的定义&lt;/span&gt;
&lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Swaroop&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;swaroop@swaroopch.com&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="s"&gt;&amp;#39;Larry&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;larry@wall.org&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="s"&gt;&amp;#39;Matsumoto&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;matz@ruby-lang.org&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="s"&gt;&amp;#39;Spammer&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;spammer@hotmail.com&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;#通过键来获取值&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Swaroop&amp;#39;s address is&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Swaroop&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="c"&gt;#删除一个键值对&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Swaroop&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="c"&gt;#遍历字典&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;contact {0} at {1}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c"&gt;#往字典中增加一个键值对&lt;/span&gt;
&lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Adoo&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;liuxiaodongxiao@hotmail.com&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;#判断字典中是否存在某键,也可以用 if ab.has_key(&amp;#39;Adoo&amp;#39;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Adoo&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Adoo&amp;#39;s address is&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ab&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Adoo&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出的结果为：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Swaroop&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;swaroop&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;swaroopch&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;
&lt;span class="n"&gt;contact&lt;/span&gt; &lt;span class="n"&gt;Matsumoto&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;matz&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;ruby&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;lang&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;org&lt;/span&gt;
&lt;span class="n"&gt;contact&lt;/span&gt; &lt;span class="n"&gt;Larry&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;larry&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;wall&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;org&lt;/span&gt;
&lt;span class="n"&gt;contact&lt;/span&gt; &lt;span class="n"&gt;Spammer&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;spammer&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;hotmail&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;
&lt;span class="n"&gt;Adoo&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;liuxiaodongxiao&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;hotmail&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;序列(Sequences)&lt;/h3&gt;
&lt;p&gt;上面介绍的三种内建数据结构都是序列，索引操作是序列的一个基本操作。通过下标操作可以直接访问序列中的对象。上面虽然已经演示了下标操作——队列和元组用数字下标，字典用关键字下标。&lt;/p&gt;
&lt;p&gt;序列的下标是从0开始的，上面的例子中只使用了下标为正数的情况，其实下标还可以为负数，如-1,-2,-3…。负数下标表示的意义为反方向的位置，如&lt;code&gt;shoplist[-1]&lt;/code&gt;返回的是shoplist的倒数第一个项目。&lt;/p&gt;
&lt;p&gt;序列不但支持负数下标还支持双下标，这对双下标表示一个区间。如shoplist[0:3]返回的是一个hoplist中从下标为1到下标为3之前的子序列副本。注意这个区间是一对半闭半开的区间。这种操作被称作切片操作(slicing operation)。如果切片操作的第二个下标超出了序列的范围，那么切片操作会到序列的末尾终止。切片操作中的两个下标都有默认值，第一个的默认值为0，第二个的大小为序列的长度。&lt;/p&gt;
&lt;p&gt;还可以给切片操作提供第三个参数，第三个参数代表切片操作的步长，它的默认值是1。步长代表了项与项之间的间距，比方&lt;code&gt;name[0:10:3]&lt;/code&gt;,返回的就是name中下标为0，3，6，9组成的子序列。&lt;/p&gt;
&lt;h3&gt;集合(set)&lt;/h3&gt;
&lt;p&gt;集合是无序简单对象的聚集。当你只关注一个对象是否存在于聚集中，而不管它存在的顺序或在出现的次数时，则适宜用集合。基本功能：判断是否是集合的成员、一个集合是不是另一个集合的子集、获取两个集合的交集等等。实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#定义一个集合,要使用set函数&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;briza&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;russia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;india&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="c"&gt;#判断对象是否在集合中&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;india&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;india is in ?&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;india&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="c"&gt;#往集合中添加对象&lt;/span&gt;
&lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;china&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#从集合中删除对象&lt;/span&gt;
&lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;russia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#求两个集合的交集，也可以使用 s.intersection(sc)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出的结果：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;india&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;True&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;briza&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;india&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考：a byte of python –v1.92(for python 3.0)&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          周二 01 五月 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b03.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="data structure"></category><category term="python"></category><category term="笔记"></category></entry><entry><title>Python 基础入门笔记(2)——函数、模块和包</title><link href="http://www.roading.org//develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b02%e5%87%bd%e6%95%b0%e3%80%81%e6%a8%a1%e5%9d%97%e5%92%8c%e5%8c%85.html" rel="alternate"></link><updated>2012-04-29T15:27:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-04-29:/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b02%e5%87%bd%e6%95%b0%e3%80%81%e6%a8%a1%e5%9d%97%e5%92%8c%e5%8c%85.html</id><summary type="html">&lt;p&gt;函数、模块和包对于代码的复用都有非常重要的意义，当然面向对象中的类其实在代码的复用性上也有举足轻重的地位。前天睡前看了《a byte of python》中关于函数、模块和包的这个部分，今天又查了查官网文档以及网上的其它一些资料，把一些疑惑给解决。现在写一下关于这部分的笔记，用以加强记忆同时以备后用。&lt;/p&gt;
&lt;h3&gt;函数&lt;/h3&gt;
&lt;p&gt;python 中用关键字def来定义函数。一个完整的函数定义应该以关键字def
开始后面紧跟着函数名和用括号括起来的形参列表，并以一个冒号作为该行的结尾，紧跟着则是函数的代码块。实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;printMax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;is maximin&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;is equal to&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;is maximum&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Python同样支持为参数提供一个默认值&lt;/strong&gt;，函数在调用时有默认值的形参是可选的，也就是说这样的参数可以不用给它提供实参。这在很多情况下都非常有用，比方一个窗口的创建函数——拥有很多形参来设定窗口的属性，但通常创建一个窗口可能只有两三个属性需要特别设定，其它都可以用默认值。Python的默认参数与C++的默认参数我感觉是一样的。都要求提供默认值的形参处于形参队列的末尾，换句话说，提供默认值得形参之后不能有不提供默认值的形参。其原因在于在调用函数时，用实参对形参赋值一般都是按位置顺序进行的。&lt;/p&gt;
&lt;p&gt;说到“实参对形参赋值一般是按位置顺序进行的(这样的参数叫做位置参数，译自positional arguments)”，则不能不提一提&lt;strong&gt;关键字参数（Keyword Aruguments）。&lt;/strong&gt;所谓关键字参数是指，可以显示的按形参名赋值实参，而并非根据形参的位置顺序。比方&lt;code&gt;printMax(b=5,a=10)&lt;/code&gt;。当然，这个例子并没有体现出关键字参数的价值，其价值在于可以明确指出参数的角色。比方有一个文件内容拷贝函数&lt;code&gt;copyFile(to,from)&lt;/code&gt; ——将文件 from 中的内容拷贝到文件to中。使用类似的函数的时候，使用者必须记住参数的顺序，但如果支持关键字参数的话，则不必关心位置顺序，将正确的文件名赋值给正确的形参就OK。&lt;/p&gt;
&lt;p&gt;python 中&lt;strong&gt;可变形参(VarArgs Parameters)&lt;/strong&gt;的概念非常清晰，在一个函数之前加上&lt;code&gt;*&lt;/code&gt;号或者&lt;code&gt;**&lt;/code&gt;号就表示这个形参代表了个数不确定的参数，如&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;resultprint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的代码将会输出：15。 函数sum的形参number之前有&lt;code&gt;*&lt;/code&gt;号标记，表明number是一个可变形参，实际代表的参数数目由调用时传入的实参数目决定。原理很简单，一个可变形参，如numbers, 会将从它那一点开始的所有&lt;strong&gt;位置实参(positional arguments)&lt;/strong&gt;收集为一个 numbers列表。形参之前用两个星号&lt;code&gt;**&lt;/code&gt;标记，同样表示一个可变形参，只是双星号的可变形参是将将从它自己开始的位置实参都收集为一个字典(dictionary)。队列(list)和字典(dictionary)都是python提供的基本数据结构。有趣的一点是 python
中的可变形参并不一定要放在形参队列的末尾，这就带来了一种副产品
Keywords-only parameters，请看:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;desc&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;desc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但上面的例子中的 desc形参只能以关键字参数的方式进行调用了。调用方法如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#正确的调用&lt;/span&gt;
&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;desc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The sum of my salary is：&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#错误的调用，实参&amp;#39;The sum of my salary is：&amp;#39;也会被收入numbers中&lt;/span&gt;
&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The sum of my salary is：&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果一个函数没有提供显示的返回语句，python 会隐式的提供一条返回语句
return None 。None 是 python 中的一个特殊类型，表示没有任何东西。&lt;/p&gt;
&lt;h3&gt;模块&lt;/h3&gt;
&lt;p&gt;python既支持python语言写的模块同时也支持多种其它语言写的模块。这儿只看最简单的python写的模块，而不管其它。&lt;strong&gt;一个扩展名为.py的文件其实就是一个python模块&lt;/strong&gt;。模块能被其它程序导入并使用它的功能，例如下面对准库的使用：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#file: C:\Users\Adoo-\Desktop\using_sys.pyimport sys&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The command line arguments are:&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;The PYTHONPATH is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;C:&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;Users&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;Adoo&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;Desktop&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;using_sys&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pyThe&lt;/span&gt; &lt;span class="n"&gt;PYTHONPATH&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Users&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Adoo&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Desktop&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Python32&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Lib&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;idlelib&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;windows&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;SYSTEM32&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;python32&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zip&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Python32&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;DLLs&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Python32&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Python32&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;Python32&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="n"&gt;site&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;packages&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上例中用一条import语句来告诉python我们想使用sys模块。对于一个使用用python
编写的模块而言，当python执行 &lt;strong&gt;import 语句时,python 解释器会从sys.path中列出的路径中查找&lt;/strong&gt;，如果找到了就会执行模块中包含的语句，然后这个模块就可以用了。模块的初始化操作只会在第一次被导入时执行。模块被导入后就可以通过点操作符来使用模块中的函数或变量，如sys.argv或
sys.path。&lt;/p&gt;
&lt;p&gt;要注意，要使用一个模块，必须确保这个模块所在的路径包含在sys.path中。所以，要么将你的模块复制到sys.path列出的路径中的一个去，要么把你的模块路径加入到sys.path中。执行文件所在的当前路径会被自动添加到sys.path中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;form … import 语句：&lt;/strong&gt;用 from sys import argv语句可以直接导入sys模块中的argv变量，而且只导入argv.此时sys中的argv可以直接使用，而不用通过sys.argv的方式引用。使用&lt;code&gt;from sys import *&lt;/code&gt;语句可以导入sys中的所有公有的和非双下划线开头的名字，不过这肯定不是一种好的习惯——容易造成名字冲突，如C++中的using namespace 语句。&lt;/p&gt;
&lt;p&gt;模块中&lt;strong&gt;内置一个&lt;code&gt;__name__&lt;/code&gt;属性&lt;/strong&gt;。如果一个模块是被&lt;code&gt;import&lt;/code&gt; 的, 那么
&lt;code&gt;__name__&lt;/code&gt;的值通常为去除模块扩展名的文件名。如果模块式独立运行的(也就是说它是主模块)&lt;code&gt;__name__&lt;/code&gt;的值将是'&lt;code&gt;__main__'。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;导入一个模块相对来说比较费时，所以 Python提供了一种&lt;strong&gt;以.pyc为扩展名的按字节编译的文件&lt;/strong&gt;.当模块被第一次导入时，如果python具有当前路径的写入权限，.pyc
文件会被创建在与模块文件相同路径下。有.pyc文件将会非常有利，当下次从其它程序再导入这个模块时，会快得多。因为导入模块的一些必要处理已经做好了。另外.pyc文件也是平台无关的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dir()函数返回包含指定模块中所有名字的队列（list）&lt;/strong&gt;，注意用 import 语句导入的名字也在其中。在不提供参数给dir()的情况下，将返回包含当前模块的所有名字的队列。dir()函数其实可以作用于任何对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以用一个del 语句删除一个变量或者名字&lt;/strong&gt;，被&lt;code&gt;del&lt;/code&gt;删除的名字或变量，在之后的语句里将不可以被访问。&lt;/p&gt;
&lt;h3&gt;包&lt;/h3&gt;
&lt;p&gt;包其实就是用文件夹将模块组织起来，不过文件夹下必须要一个__init__.py文件，只有文件夹下有一个名为__init__.py的文件，该文件夹才会被当作一个包看待。但__init__.py文件可以是空的。&lt;/p&gt;
&lt;p&gt;可以用 &lt;code&gt;from…import…&lt;/code&gt;语句来导入包中的相关模块。要注意的一点是，假如有一个名为package的包，那么&lt;code&gt;from package import *&lt;/code&gt;语句并不会如你想象的导入包中所有模块。它只导入在__init__.py中__all__属性中所列出的模块。例如，当__init__.py中__all__的定义如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;__all__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;mould1&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;moudle2&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;moudle3&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么，from package import * 只会导入mould1、moudle2和moudle3三个模块。&lt;/p&gt;
&lt;p&gt;参考：a byte of python –v1.92(for python 3.0) 以及pyhon.org关于python3.2的很小部分文档。以及这篇博客：&lt;a href="http://pydoing.blogspot.com/2011/02/python-package.html"&gt;http://pydoing.blogspot.com/2011/02/python-package.html&lt;/a&gt;&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          周日 29 四月 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/python/python-%e5%9f%ba%e7%a1%80%e5%85%a5%e9%97%a8%e7%ac%94%e8%ae%b02%e5%87%bd%e6%95%b0%e3%80%81%e6%a8%a1%e5%9d%97%e5%92%8c%e5%8c%85.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="python"></category><category term="代码组织"></category><category term="笔记"></category></entry><entry><title>都废</title><link href="http://www.roading.org//essaies/sadcity.html" rel="alternate"></link><updated>2012-04-26T14:31:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-04-26:/essaies/sadcity.html</id><summary type="html">&lt;p&gt;《废都》，便是迷醉于欲望之中，却又无法抽身自救的那么一群人组成。即便是尼姑庵的慧明亦脱不出肉欲
、权欲的高墙。大概世道如此，现实并不是人们掉进了欲望的天坑，反而是，欲望便如已然合围的高墙，人生而就在墙内。不是陷入了，而是逃不出。&lt;/p&gt;
&lt;p&gt;便如《废都》演变到最后，这些人或死了、又或走了。死了的人固然逃出了欲望的樊笼，走了的人却尚未完成自救。诚然、庄之蝶最终放弃了背负了的声名，好似看淡了一切，悄然踏上了驶往南方的火车。而实质却是截然相反的，他并没有逃脱那一切，因他没有做任何一丁点抗争，不过是走到了绝地后的另谋他路罢了。他与周敏最终坐上了同一辆离开西京的火车，离开西京并不是他们幡然醒悟了，而是他们都面临了同样的困境——在追逐欲望的过程中面临了难以挽回的局面。周敏费尽心机也没有保全他在杂志社的工作，而庄之蝶更是跌进了谷底，失去了一切。他们是在这样一种情况下离开的，无需割舍任何一点东西。所以他们今天或许离开了西京，但却保不准哪天要入了南京了。&lt;/p&gt;
&lt;p&gt;庄之蝶外头有那么多女人，却又未必真得了爱情。庄之蝶身材矮小，其貌不扬，要说他的那些女人们三下两次的便都和他上了床是爱情，我是不信的。与其说，她们是爱上了庄之蝶，不如说她们爱上的是“大作家庄之蝶”。反过来看呢，庄之蝶也不过仅是爱上了这些年轻美妙的肉体。阿灿的自毁容貌或许叫庄之蝶内疚与感动了，却也止步于此。唐婉儿最终的处境或许也叫庄之蝶煎熬难受了，不过是因为庄之蝶还有一颗良善之心罢了。我想庄之蝶与唐婉儿、柳月、阿灿之间是并没有一场爱情的，顶多也只是有很多场偷情。&lt;/p&gt;
&lt;p&gt;看罢《废都》，羡慕完庄之蝶的艳福之后、我又对他非常不耻。不耻周敏对他执师之礼，他却上了人家有实无名的老婆？不耻他间接害死了朋友龚靖元。不耻他亏待了赵京五…&lt;/p&gt;
&lt;p&gt;我始终不能明白，庄之蝶是有一颗良善之心的，又为何总做出上述不耻之事?末了，我却明白了，世道如此啊。这威武圣朝，现世亿万民众，或达官显贵，或平民布衣，莫不在这万丈红尘中翻滚，莫不为利欲如此行事。便拿害死了龚靖元说事，乘龚靖元之危买得了他的收藏或许是不道义的。但你见同赵京五谋划这事的时候，赵京五有丝毫内疚？诓骗压价龚小乙的时候，赵京五有丝毫手软？赵京五不是魔头，实在是这种事情在这个时段在这个地方太过平常，所有局中人都为警觉到严重的后果而已。&lt;/p&gt;
&lt;p&gt;庄之蝶是坏人吗？不！我想庄之蝶是个好人，这世道能有一副热肠、能有一颗良心已经是殊为不易。&lt;/p&gt;
&lt;p&gt;临近文末，我仿佛听到了庄之蝶丈母娘的喋喋呓语：都废了、都废了、都废…&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          周四 26 四月 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/essaies/sadcity.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="随笔"></category></entry><entry><title>Python 基础入门笔记(1)</title><link href="http://www.roading.org//develop/python/python-%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%80%e7%ac%94%e8%ae%b01.html" rel="alternate"></link><updated>2012-04-24T17:25:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-04-24:/develop/python/python-%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%80%e7%ac%94%e8%ae%b01.html</id><summary type="html">&lt;h3&gt;内建类型&lt;/h3&gt;
&lt;p&gt;python 中提供的内建类型大概与C++中提供的相仿，却更简洁。&lt;/p&gt;
&lt;p&gt;数值方面的内建类型有整型、浮点型、和复数类型三种。在C++中虽然也有复数类型，但却是由标准库提供的。另外，python中整数的表示就是整形，没有如C++中的长整型短整形之说。浮点数的表示也没有浮点型和双精度型的区分。&lt;/p&gt;
&lt;p&gt;字符串则可以分为字符串(string)和原生字符串(raw string)两种类型。可以如同
C++ 一般用一对双引号来指定一个字符串，如 "This is a
string"。在python中单引号(‘)与双引号(“)拥有相同的功能——一对单引号也可以表示一个字符串，如&lt;code&gt;'This is a string'&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于一个多行的字符串，可以用转义字符来表示，例如&lt;code&gt;'This is the first line.\nThis is the second line.'&lt;/code&gt;，但是python同时提供了一种更友好的方式，用三引号('''或""")来表示一个多行的字符串，如：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39; this is a multi-line string.&lt;/span&gt;
&lt;span class="sd"&gt;this is the second line.&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;what your name ?&amp;quot; I asked.&lt;/span&gt;
&lt;span class="sd"&gt;he said &amp;quot;My name is ***&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面介绍有单引号、双引号、三引号三种引号。当用其中一种来指定一个字符串时，可以在字符串中直接使用另外两种引号，例如上面的多行字符串中可以直接使用
&lt;code&gt;"&lt;/code&gt;，而无需写成 &lt;code&gt;/"&lt;/code&gt;。这是因为字符串可以找到正确的结尾，而不会被提前截断。&lt;/p&gt;
&lt;p&gt;字符串无需再赘言，原生字符串可以在字符串之前加上一个r或者R来表示，例如&lt;code&gt;r'\nThis is a raw string'&lt;/code&gt;。原生字符串不会对字符串进行任何特殊处理，例如&lt;code&gt;r'\nThis is a raw string'&lt;/code&gt;中的&lt;code&gt;\n&lt;/code&gt;不会被转义处理，而是直接代表&lt;code&gt;\&lt;/code&gt;和&lt;code&gt;n&lt;/code&gt;两个字符。&lt;/p&gt;
&lt;p&gt;python 没有char类型。&lt;/p&gt;
&lt;h3&gt;变量&lt;/h3&gt;
&lt;p&gt;python的变量命名规则与C++类似。定义上却有很大不同，定义一个python变量，直接给它赋值就可以了，并不需要声明它的数据类型，变量的类型决定于初始化它的对象类型。C++11中的&lt;code&gt;auto&lt;/code&gt;关键词有类似作用，不过实质上是不一样的。实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&amp;#39; this is a multi-line string.&lt;/span&gt;
&lt;span class="s"&gt;this is the second line.&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;python中一切事物皆为对象，即便是内建类型也是对象，这是与C++不同的。&lt;/p&gt;
&lt;h3&gt;代码书写约定&lt;/h3&gt;
&lt;p&gt;python
隐式约定每一物理行表示一行语句，所以python中的一行语句写完不需以分号结束，虽然在语句末尾加上分号也无伤大雅，但画蛇添足的事多做无益。但是如果要将多行语句写在同一物理行，那么则必须用逗号分开。如果某行语句过长，想写在两行，则可以使用连接符&lt;code&gt;\\&lt;/code&gt;。实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#将多条语句写在同一物理行&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;#将一行语句写在多个物理行。&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;this is a string. &lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;
&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;continue&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当行中使用了圆括号、方括号或波形括号的时候，不需要用&lt;code&gt;\\&lt;/code&gt;来连接多行,这种情况被称为隐式行连接。&lt;/p&gt;
&lt;p&gt;缩进：每行开始的缩进在python中相当重要，python中并不用大括号或者begin、end类似的关键词来界定语句块，缩进才是它的标准。换言之，行首的缩进量决定了语句的分组，同一层级的语句必须要有相同的缩进量。python支持空格符和制表符来表示缩进，但确保只使用其中一种来表示缩进，千万不要混搭使用。&lt;/p&gt;
&lt;h3&gt;表达式&lt;/h3&gt;
&lt;p&gt;python的一些操作符大体上与C++一致，下面罗列几种与C++有差异的操作符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乘法运算&lt;code&gt;*&lt;/code&gt;，对字符串也能进行乘法运算，如&lt;code&gt;'a'*3&lt;/code&gt; 返回&lt;code&gt;'aaa'&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;求幂运算符&lt;code&gt;**&lt;/code&gt;，&lt;code&gt;x**y&lt;/code&gt; 表示求x的y此幂，例如&lt;code&gt;2**3&lt;/code&gt;的返回值为8.&lt;/li&gt;
&lt;li&gt;除法运算&lt;code&gt;/&lt;/code&gt;，与C++不同,整数之间的除法会返回小数，如1/2返回小数0.5而不是0.&lt;/li&gt;
&lt;li&gt;floor division(地板除？)运算符&lt;code&gt;//&lt;/code&gt; ，返回&lt;code&gt;x//y&lt;/code&gt;结果中的整数部分。如&lt;code&gt;6//5&lt;/code&gt;返回1.&lt;/li&gt;
&lt;li&gt;按位异或操作符&lt;code&gt;\^&lt;/code&gt;,如&lt;code&gt;3\^2&lt;/code&gt;返回1，&lt;code&gt;5\^3&lt;/code&gt;返回6。&lt;/li&gt;
&lt;li&gt;按位反转操作符&lt;code&gt;\~&lt;/code&gt;，一元运算。&lt;code&gt;\~x&lt;/code&gt;返回&lt;code&gt;-(x+1)&lt;/code&gt;，也就是说&lt;code&gt;\~5&lt;/code&gt;的结果为-6.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;not&lt;/code&gt;运算符，一元运算，求逻辑非。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;and&lt;/code&gt;运算符，求逻辑与，对应C++中&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;or&lt;/code&gt;运算符，求逻辑或，对应C++中&lt;code&gt;||&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运算符的与表达式的更多介绍: &lt;a href="http://www.python.org/\~gbrandl/build/html/reference/expressions.html"&gt;http://www.python.org/\~gbrandl/build/html/reference/expressions.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;运算符在表达式的优先级列表: &lt;a href="http://www.python.org/\~gbrandl/build/html/reference/expressions.html"&gt;http://www.python.org/\~gbrandl/build/html/reference/expressions.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;控制流&lt;/h3&gt;
&lt;p&gt;python
有一种分支结构语句——if语句。但不存在switch语句。两种循环结构语句——while
和for语句，没有do …while语句。有点奇妙的是所有者三种语句都提供一个可选的else分支语句，没错不仅if语句有else分支，while与for也有else分支。&lt;/p&gt;
&lt;p&gt;if语句中可以将一个嵌套的if…else…if…else语句合并成if…elif…else语句，后者可以很好的替代switch语句。if语句的实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;
&lt;span class="n"&gt;guess&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Enter a number:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt; 
   &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;you guessed it&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="err"&gt;   &lt;/span&gt; 
   &lt;span class="n"&gt;prinnt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;no, it is a little higher than that&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="err"&gt;  &lt;/span&gt;
   &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;no it is a little lower than that&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实际上相当于：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;22&lt;/span&gt;
&lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Enter a number:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;you guessed it&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;no, it is a little higher than that&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;no it is a little lower than that&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要注意两点：
&lt;em&gt;   判断表达式不需要括号;
&lt;/em&gt;   每一个分支语句之前需要冒号。&lt;/p&gt;
&lt;p&gt;python中循环结构的一个比较鲜明的特点就是多了一个else分支，这个else在循环完成后执行。&lt;/p&gt;
&lt;p&gt;while循环的实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;count: {0}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;The while loop is over.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;for循环的实例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;i:{0}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the for loop is over&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从语法上来讲，for与while给了我一些不同的感觉，虽然都是循环控制语句，但给人的感觉是while更趋向于条件控制的循环，而for则更倾向于迭代循环。&lt;/p&gt;
&lt;p&gt;python中也有break与continue语句与C++中的没有区别。要注意的是如果循环是以break语句跳出的话，那么else分支也会被跳过。&lt;/p&gt;
&lt;p&gt;注：这篇笔记我主要重点记录一些 python在语法上与C++的一些异同点，以及我认为自己需要留意的地方，所以他仅仅是一篇笔记。&lt;/p&gt;
&lt;p&gt;参考：a byte of python –v1.92(for python 3.0) 以及pyhon.org关于python3.2的很小部分文档。&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          周二 24 四月 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/python/python-%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%80%e7%ac%94%e8%ae%b01.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="python"></category><category term="笔记"></category></entry><entry><title>文化太监</title><link href="http://www.roading.org//essaies/culture-eunuch.html" rel="alternate"></link><updated>2012-01-07T11:50:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-01-07:/essaies/culture-eunuch.html</id><summary type="html">&lt;p&gt;捡起《北回归线》脱落的最后一页看完，不免有一些默然。这没有什么值得奇怪的地方
，看过的很多书都曾有这样的感觉。但这一次却又有一点不一样，它更像是一种静默中
的歇斯底里。有一种不吐不快，吐了也不能畅快的无力。这他妈的发慌发堵的感觉。&lt;/p&gt;
&lt;p&gt;老实说，看之前我已经做好了领略它到底有多淫秽，多龌龊的打算。毕竟它原是一本西
方的禁书，毕竟它原是一本在一群精力旺盛的兵痞间传阅的黄书，它理当应该很黄色，
应该能让这群士兵在无人的角落都成为单手“炮兵”。一直到看完最后一个字，我才大呼
受骗，这哪可能被当做黄书。它不但不淫秽，简直很纯洁。后来我又醒悟过来，既然是
中文版，必然在出版之前已经完成“净身”。&lt;/p&gt;
&lt;p&gt;受儿时的各类古装局，特别是满清局毒害，使我有这样一个认识：向来执刀给人净身的
人需是太监。我不在意我这个认知是否正确，便如同我不关心出版《北回归线》中文版
的人民出版社是不是太监一般。让我在意的是，我在这其中得出的一个结论——有些东西
，便如同男人裆下那玩意，即便它有多令人恶心、淫秽、邪恶…它依然是那么重要，缺之
不可。展现一副裸体不应该是什么禁忌，将一副男性裸体断根或女性裸体切除乳房才有
违人道。我猜测《北回归线》在中国便受到了如此酷刑。&lt;/p&gt;
&lt;p&gt;《北回归线》是一具生疮流脓的裸体，出版者大概以为这样一个样子太过可怖，因此切
除了他狰狞的阳具，却不知如此一来更丑陋且显虚伪。&lt;/p&gt;
&lt;p&gt;我用支离破碎的时间，看完了这本情节凌乱的书。即使刚刚看完，我却不能将之前后串
联起来。但我能确信的是这确实是一本好书。这并不是一句人云亦云的恭维话，也不是
为了掩盖自己见识浅薄智力低微而闪烁其词的含糊语。看这本书的过程中，便似有一般
小锤悬于心脏之上，它不时就会在你的心房或心室敲打一下，让你不禁颤抖。&lt;/p&gt;
&lt;p&gt;我问自己要不要完整的反刍式的将这本书再看一遍？我想，算了吧。我深知，书中能体
味到的，远不啻如此。虽然我看到的不过皮毛，甚至不足十之一二，虽然这也确实是一
本值得一看的书。合上书本，我并不打算再看一遍了。一如书中所说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;他们所处的世界同每一个地方一样，发生的事情多半是屎尿垃圾，同任何一个垃圾桶
一样脏，只是他们能有幸盖上桶盖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个世界黑暗的角落太多，揭露丑陋、人性、黑暗的作品或作者更不胜枚举。但能点亮
希望光芒的呢？我明白我想要重读的不是展现黑暗的世界，不是冷漠的一瞥，不是感叹
绝望的挣扎。我想要反复阅读的是能道出希望之所在的作品。&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          周六 07 一月 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/essaies/culture-eunuch.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="随笔"></category><category term="北回归线"></category></entry><entry><title>又到离别时</title><link href="http://www.roading.org//essaies/leave.html" rel="alternate"></link><updated>2011-12-10T14:25:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-10:/essaies/leave.html</id><summary type="html">&lt;p&gt;前几天毕业后的工作已经决定下来，前两天《深度探索C++对象模型》的学习也已
经了结。手头事情忙得差不多的时候，一回头不禁感叹，又是一季离别，年后大学
也算结束了。当然，或许你是以拿到毕业证作为一段生涯的句点，那自然不是，这
只能说认知上有些差别。&lt;/p&gt;
&lt;p&gt;说到工作的事，首先要很谢谢熊哥的内荐，免了我舟车劳顿、颠沛奔波的辛苦。虽
然程序不少，但是能仅仅打几通电话、收发几封邮件、写两段代码来决定工作，比
之奔走求职确实是一件轻松太多的事情。我原来已经拿定主意年后南下找工作，不
过既然可以不用奔波，公司又让我满意，我自然安心下来。我虽然一开始就决定明
年才开始求职的行程，不过中途经不住各位同学都已经签约的诱惑。有去试过两家
公司，一家叫深信服，另一家叫龙通。毫无疑问，这是两次失败的经历。&lt;/p&gt;
&lt;p&gt;虽然两次失败的经历对我来说并没有太多的遗憾，但是还是收获有一些经验。深信
服是在笔试的时候被刷的，本来笔试被刷，没有什么可谈，无非自己实力欠缺。但
我却犯了一些天真的错误。其一是笔试迟到了将近半个小时，不过考官还是让我们
进去了，虽然最后时间不缺，但显然对它缺乏重视——实际上我本来不打算参加笔试
的。其二在于，我天真的不把它当一场考试，选择题部分，我甚至没有在显眼的地
方写上我的答案，仅仅在每个错误的选项旁边，写下四五个字的注释，诸如此类随
意的做法，我也不记得试卷上有多少，何况深信服的题量之大，足有十页。考完之
后，我还颇有自信，甚至坚持在熊哥和旺X那里过夜，等待面试通知。&lt;/p&gt;
&lt;p&gt;如果说深信服得到了一些教训的话，龙通的那次面试则是纯粹浪费时间了，通过笔
试后，大概是第四天去长沙参加了龙通的面试，面试我的是两个小伙，估计比我大
不了几岁，和其中一个胖点的相谈甚欢(应该是人力，我却一直和他讲技术)，到另
外一个瘦点的来面具体技术的时候，却把我镇住了——居然边上网找题目，边问我。
问的问题很简单，但我都很慎重的作答。我自信对他所问，都有把握——除了其中两
个。一个为函数指针的使用问题，他问我函数指针使用时需不需要解引用，我答他
可以不用，当我刚开口要说一说为什么可以用也可以不用时。他似乎一副不必改口
的样子，直接告诉我进入下一题，我自然没有抢白解释。另一个问题，他问我用过
什么样的进程间通信方式，我答他我只用过套接字。他又问我进程通信有几种方式
，这题我当时没答上。其实最让人不能接受的问题在于，当我说出期望薪资是5k
的时候，我明显看到那两小子有点轻笑的味道，好像在说我不知天高地厚。姑且不
论5k的薪水到底是多是少，要知道他们宣讲的时候说的待遇是4.8k-6.8k，我说5k
绝对合理，当然后来在网上查了下龙通签人的薪水，估计他们宣讲时的薪水含有不
少水分。后来又问我转不转java，去不去南京，我都表示不会考虑。&lt;/p&gt;
&lt;p&gt;起笔之时，并没有打算讲求职琐事，写到此处，才发觉占了大量篇幅，气氛全无…&lt;/p&gt;
&lt;p&gt;当跑题跑了数公里之外的时候，我们再校正回来。&lt;/p&gt;
&lt;h3&gt;再续离别时&lt;/h3&gt;
&lt;p&gt;散席时，总不必表现的太过伤感，再尽兴的聚会，也总有离席散客之时，但倘若缘
分尚在，情分依旧，欢聚重逢，把酒高欢的时刻总不会少。&lt;/p&gt;
&lt;p&gt;我本来打算想营造点伤感的气氛，但无赖虽然可以预见有一份离别的伤感，但毕竟
这份伤感却还未到来，谁叫我这人只能提前享受快乐，却无法预支悲伤。更何况，
最近这几个月我又过的太过恰意，一段手上有几本欲罢不能的好书，脚下经常能踢
几场酣畅淋漓的爽球，偶尔还可以把酒高歌，有时亦可以静坐垂钓，更甚至，明天
凌晨五点的世纪大战，细哥还会电话叫我起床看球。这样的生活，又哪能期待更多。&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          周六 10 十二月 2011 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/essaies/leave.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="随笔"></category></entry></feed>