<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Adoo's blog</title><link href="http://www.roading.org/" rel="alternate"></link><link href="http://www.roading.org/feed/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.xml" rel="self"></link><id>http://www.roading.org/</id><updated>2011-12-09T22:03:00+08:00</updated><entry><title>《深度探索C++对象模型》笔记汇总</title><link href="http://www.roading.org//develop/cpp/%e3%80%8a%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b%e3%80%8b%e7%ac%94%e8%ae%b0%e6%b1%87%e6%80%bb.html" rel="alternate"></link><updated>2011-12-09T22:03:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-09:/develop/cpp/%e3%80%8a%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b%e3%80%8b%e7%ac%94%e8%ae%b0%e6%b1%87%e6%80%bb.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E6%80%BB%E7%BB%93%E4%BA%A6%E4%B8%BA%E5%BC%95%E8%A8%80.html"&gt;01. 总结——亦为引言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第1章 关于对象(Object Lessons)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E5%AF%B9%E8%B1%A1%E9%9D%A2%E9%9D%A2%E8%A7%82.html"&gt;02. C++对象面面观&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第2章 构造函数语意学(The Semantics of constructors)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%B7%B1%E5%85%A5c%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.html"&gt;03. 深入C++构造函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88copy-constuctor%EF%BC%89.html"&gt;04. 拷贝构造函数(Copy Constructor)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96%E5%92%8C%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97.html"&gt;05. 命名返回值优化和成员初始化队列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第3章 Data语意学（The Semantics of Data）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F.html"&gt;06. C++类对象的大小&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/vc%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%87%86%E5%88%99%EF%BC%88memory-alignment%EF%BC%89.html"&gt;07. VC内存对齐准则（Memory alignment）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98.html"&gt;08. C++对象的数据成员&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第4章 Function语意学（The Semantics of Function）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E4%B9%8B%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.html"&gt;09. C++之成员函数调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0virtual-member-functions.html"&gt;10. C++之虚函数(Virtual Member Functions)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第5章 构造、解构、拷贝 语意学（Semantics of Construction，Destruction，and Copy）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E5%87%A0%E7%82%B9%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html"&gt;11. 几点类设计原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%9E%84%E9%80%A0%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E6%9E%90%E6%9E%84%E8%AF%AD%E6%84%8F%E5%AD%A6.html"&gt;12. 构造、复制、析构语意学&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第6章 执行期语意学（Runting Semantics）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/new-expression%E3%80%81operator-new-%E5%92%8C-placement-new%E4%B8%89%E4%B8%AA%E5%A6%9E%EF%BC%88new%EF%BC%89%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%881%EF%BC%89.html"&gt;13. new expression、operator new 和 placement new——三个“妞（new）”的故事（1）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/new-expression%E3%80%81operator-new-%E5%92%8C-placement-new%E4%B8%89%E4%B8%AA%E5%A6%9E%EF%BC%88new%EF%BC%89%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%882%EF%BC%89.html"&gt;14. new expression、operator new 和 placement new——三个“妞（new）”的故事（2）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/new-expression%E3%80%81operator-new-%E5%92%8C-placement-new%E4%B8%89%E4%B8%AA%E5%A6%9E%EF%BC%88new%EF%BC%89%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%883%EF%BC%89.html"&gt;15. new expression、operator new 和 placement new——三个“妞（new）”的故事（3）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84.html"&gt;16. 对象的构造和析构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E4%B8%B4%E6%97%B6%E6%80%A7%E5%AF%B9%E8%B1%A1temporary-objects.html"&gt;17. 临时性对象(Temporary Objects)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第7章 站在对象模型的类端（On the Cusp of the Object Model）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%A8%A1%E6%9D%BF%E4%BA%8C%E4%BA%8B.html"&gt;18. 模板二事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/eh-rtti.html"&gt;19. EH &amp;amp; RTTI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Inside The C++ Object Model"></category><category term="笔记"></category></entry><entry><title>总结——亦为引言</title><link href="http://www.roading.org//develop/cpp/%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b/%e6%80%bb%e7%bb%93%e4%ba%a6%e4%b8%ba%e5%bc%95%e8%a8%80.html" rel="alternate"></link><updated>2011-12-09T21:39:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-09:/develop/cpp/%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b/%e6%80%bb%e7%bb%93%e4%ba%a6%e4%b8%ba%e5%bc%95%e8%a8%80.html</id><summary type="html">&lt;p&gt;《深度探索C++对象模型》终于在昨天写完了最后一篇笔记，前前后后花费了一个月左右，期间学到了很多，很感激书的作者和译者。之后的日子，可以将精力转回《算法导论》和一些非技术类的书上来了。&lt;/p&gt;
&lt;p&gt;11月11号开始看《深度探索C++对象模型》一书，到二十八号看完，共计花费了十八天。不过到做完全书的笔记则是昨天的事了。期间也算是反复阅读，中英文版本对照，虽然不能说事深掘至微末，但也能算掌握了主络，倒是令我自己满意。&lt;/p&gt;
&lt;p&gt;期间花费的心力精神自不必说，但收获欢欣也实在不少。得益于 Lippman
的大师技艺，书中很多地方使我有拨云见日的豁然，一些原以为晦涩高超的技巧，其真实面目暴力且直接。这本书不厚，但可以深掘的东西实在不少，以至于某些时候，我不得不停下思路，以免难以自拔。&lt;/p&gt;
&lt;p&gt;当然，在这个行业来说，这本书毕竟有点“远古”，读这本书的时候，必须保持着清晰的头脑，不能迷信作者和译者——虽然他们都是值得尊敬的人物。需要抱有怀疑精神，更需要多动手编码验证一番。原书的疏漏笔误之处着实不少，这要多谢译者侯捷一一指正。但或许正因为这个原因，无端膨胀了译者的自信，毕竟指点一个大师的错误是一件如此刺激的事情。这无端膨胀的自信，同样带来了一些问题——一些原本正确之处，被做了错误的更正。可见，于技术学习来说，谨慎谦虚，何其重要。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2011/12/9 By Adoo | Homepage:&lt;/em&gt;&lt;a href="http://www.roading.org"&gt;&lt;em&gt;www.roading.org&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/p&gt;</summary><category term="Inside The C++ Object Model"></category><category term="总结"></category></entry><entry><title>EH &amp; RTTI</title><link href="http://www.roading.org//develop/cpp/eh-rtti.html" rel="alternate"></link><updated>2011-12-08T22:24:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-08:/develop/cpp/eh-rtti.html</id><summary type="html">&lt;h3&gt;异常处理(Exception Handling)&lt;/h3&gt;
&lt;p&gt;C++的 exception handling 有三个主要的语汇组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;div align="left"&gt;
    一个 throw 子句。它在程序的某处丢出一个 exception ，被丢出的
    exception 可以是内建类型，也可以是自定义类型。——抛出 exception 组件。
    &lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;div align="left"&gt;
    一个或多个 catch 子句。 每一个 catch 子句都是一个 exception
    handler。每个子句可以处理一种类型(也包括其继承类)的 exception
    ，在大括号中包含处理代码。——专治各种不服组件。每一个catch
    子句都可以用来处理某种 exception.
    &lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;div align="left"&gt;
    一个 try 区段。用大括号包围一系列语句，这些语句有可能抛出 exception
    ，从而引发 catch 子句的作用。——逮捕各种 exception 组件。
    &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当一个 exception 被抛出后，控制权从函数调用中被释放，寻找一个吻合的 catch
子句，如果&lt;font style="background-color: #ffff00"&gt;各层&lt;/font&gt;调用都没有吻合的
catch 子句，terminate()
将被调用。在控制权被放弃后，堆栈中的每一个函数调用也被出栈，这个过程称为
unwinding the stack (关于 stack unwinding ,可以参考《C++
Primer》第四版之 17.1.2 Stack
Unwinding)，在每一个函数被出栈之前，其局部变量会被摧毁。&lt;/p&gt;
&lt;p&gt;异常抛出有可能带来一些问题，比方在一块内存的 lock 和 unlock
内存之间，或是在 new 和 delete 之间的代码抛出了异常，那么将导致本该进行的
unlock 或 delete 操作不能进行。解决方法之一是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;void&lt;/span&gt;  &lt;span class="n"&gt;mumble&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arena&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
   &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="n"&gt;smLock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;arena&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;  
   &lt;span class="p"&gt;}&lt;/span&gt;  
   &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="n"&gt;smUnLock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;arena&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
      &lt;span class="n"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
      &lt;span class="n"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="p"&gt;}&lt;/span&gt;  
   &lt;span class="n"&gt;smUnLock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;arena&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
   &lt;span class="n"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;在本函数被出栈之前，先截住异常，在 unlock 和 delete
之后再将异常原样抛出。new expression 的调用不用包括在 try
块之内是因为，不论在 new operator
调用时还是构造函数调用时抛出异常，都会在抛出异常之前释放已分配好的资源，所以不用再调用
delete 。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;另一个办法是，将这些资源管理的问题，封装在一个类对象中，由析构函数释放资源，这样就不需要对代码进行上面那样的处理——利用函数释放控制权之前会析构所有局部对象的原理。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;在对单个对象构造过程中抛出异常，会只调用已经构造好的 base class object 或
member class object
的析构函数。同样的道理，适用于数组身上，如果在调用构造函数过程中抛出异常，那么之前所有被构造好的元素的析构函数被调用，对于抛出异常的该元素，则遵循关于单个对象构造的原则，然后释放已经分配好的内存。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;只有在一个 catch 子句评估完毕并且知道它不会再抛出 exception
后，真正的exception object 才会被释放。关于 catch
子句使用引用还是使用对象来捕获异常，省略。&lt;/p&gt;
&lt;/p&gt;

&lt;h3&gt;执行期类型识别（Runtime Type Identification RTTI）&lt;/h3&gt;
&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;RTTI 只支持多态类，也就是说没有定义虚函数是的类是不能进行 RTTI的。&lt;/li&gt;
&lt;li&gt;对指针进行 dynamic_cast 失败会返回 NULL ,而对引用的话，识别会抛出
    bad_cast exception.&lt;/li&gt;
&lt;li&gt;typeid 可以返回类型为 const type_info&amp;amp; ，用以获取类型信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;/p&gt;

&lt;p&gt;关于 1 是因为 RTTI 的实现是通过 vptr 来获取存储在虚函数表中的
type_info* ，事实上为非多态类提供RTTI,也没有多大意义。 2
的原因在于指针可以被赋值为0，以表示 no object，但是引用不行。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;关于3，虽然第一点指出 RTTI 只支持多态类，但 typeid 和 type_info
同样可用于内建类型及所有非多态类。与多态类的差别在于，非多态类的
type_info 对象是静态取得(所以不能叫
“执行期类型识别”)，而多态类的是在执行期获得。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;参考：深度探索C++对象模型&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2011/12/8 By Adoo | Homepage:&lt;/em&gt;&lt;a href="http://www.roading.org"&gt;&lt;em&gt;www.roading.org&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/p&gt;</summary><category term="c++"></category><category term="EH"></category><category term="Inside The C++ Object Model"></category><category term="RTTI"></category></entry><entry><title>模板二事</title><link href="http://www.roading.org//develop/cpp/%e6%a8%a1%e6%9d%bf%e4%ba%8c%e4%ba%8b.html" rel="alternate"></link><updated>2011-12-07T17:00:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-07:/develop/cpp/%e6%a8%a1%e6%9d%bf%e4%ba%8c%e4%ba%8b.html</id><summary type="html">&lt;h3&gt;模板的实例化&lt;/h3&gt;
&lt;p&gt;一个模板只有被使用到，才会被实例化，否则不会被实例化。对于一个实例化后的模板来说，未被调用的成员函数将不会被实例化，只有成员函数被使用时，C++
标准才要求实例化他们。其原因，有两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间和时间效率的考虑，如果模板类中有100个成员函数，对某个特定类型只有2个函数会被使用，针对另一个特定类型只会使用3个，那么如果将剩余的195个函数实例化将浪费大量的时间和空间。&lt;/li&gt;
&lt;li&gt;使模板有最大的适用性。并不是实例化出来的每个类型都支持所有模板的全部成员函数所需要的元算符。如果只实例化那些真正被使用的成员函数的话，那么原本在编译期有错误的类型也能够得到支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以明确的要求在一个文件中将整个类模板实例化：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;template&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;也可以显示指定实例化一个模板类的成员函数：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;template&lt;/span&gt; &lt;span class="n"&gt;float&lt;/span&gt; &lt;span class="n"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;或是针对一个模板函数：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;template&lt;/span&gt; &lt;span class="n"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;模板的错误报告，使用模板并遇到错误的大概都深有体会，那就是一个灾难。&lt;/p&gt;
&lt;/p&gt;

&lt;h3&gt;模板的名称决议&lt;/h3&gt;
&lt;/p&gt;

&lt;p&gt;一开始先要区分两种意义,一种是C++ 标准所谓的“scope of the template
definition”，直译就是“定义模板的范围”。另一种是C++标准所谓的“scope of the
temlate instantiation”，可以直译为“实例化模板的范围”。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;第一种情况：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// scope of the template definition&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  

&lt;span class="n"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;ScopeRules&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
   &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;invariant&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="n"&gt;_member&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;_val&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
   &lt;span class="p"&gt;}&lt;/span&gt;  

   &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;type_dependent&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;_member&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
   &lt;span class="p"&gt;}&lt;/span&gt;  
   &lt;span class="c1"&gt;// ...  &lt;/span&gt;
&lt;span class="nl"&gt;private:&lt;/span&gt;  
   &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;_val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;_member&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;第二种情况:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//scope of the template instantiation  &lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;// ...  &lt;/span&gt;
&lt;span class="n"&gt;ScopeRules&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sr0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;sr0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invariant&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;sr0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_dependent&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;在“scope of the template instantiation ”中 两个foo()都声明在此 scope
中。猜猜sr0.invariant() 中调用的是哪个foo()函数，出乎意料，实际调用的是：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;extern&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;看上去，应该调用：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;extern&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;毕竟，_val 的类型是 int 类型，它们才完全匹配。而 sr0.type_dependent()
中调用的却在我们意料之中，调用的是:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;extern&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;诸上所述,看上去或合理或不合理的选择，原因在于:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;template 之中， 对于一个非成员名字的决议结果是根据这个 name
的使用是否与“用以实例化该模板的参数类型”有关来决定name。如果其使用互不相干，那么就以
“scope of the template dclaration”来决定name
。如果其使用的互相关联，那么就以“scope of the template
instantiation”来决定name.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;

&lt;p&gt;对于上面这一段话我的理解比较粗鲁且直接：在模板中，一个非成员名字的决议在于它适不适合在当前决议，当它完全与实例化模板的参数的类型无关的时候，就可以在当前决议下来；如果有关的话，则认为不适合在当前决议下来，将被推迟到实例化这个模板实例化的时候来决议。为什么以与实例化的类型相关不相关来区别适不适合当前决议？一个与实例化类型无关的名字，如果推迟到实例化的时候来决议，将使模板的设计者无所适从，一个模板的设计者能容忍一个与实例化类型无关的名字在他的模板中表现出当前不具有的含义吗？当然不行，那种场面，估计没有一个模板设计者能够
hold
住。相反，对于一个与实例化类型有关的名字，天生就应该可以根据实例化模板的不同类型表现出不同含义，如果其名字早在模板定义时被决议出来，那就该轮到模板的使用者
hold
不住了。当然所上完全属一家之言，呸，连一家之言都不算，怎么敢自称“家”。如有不同理解，可当我一派胡言，如果你聊发善心，可以对我赐教一二，当聆听受教。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;参考：深度探索C++对象模型&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。&lt;/em&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2011/12/7 By Adoo | Homepage:&lt;/em&gt;&lt;a href="http://www.roading.org"&gt;&lt;em&gt;www.roading.org&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/p&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category><category term="template"></category><category term="template instantiation"></category></entry><entry><title>临时性对象(Temporary Objects)</title><link href="http://www.roading.org//develop/cpp/%e4%b8%b4%e6%97%b6%e6%80%a7%e5%af%b9%e8%b1%a1temporary-objects.html" rel="alternate"></link><updated>2011-12-06T17:48:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-06:/develop/cpp/%e4%b8%b4%e6%97%b6%e6%80%a7%e5%af%b9%e8%b1%a1temporary-objects.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;摘要：本文为《深度探索C++对象模型》第六章——执行期语意学（Runtime
    Semantics）笔记之一，主要内容包括临时性对象的创建和临时性对象的生命周期。&lt;/li&gt;
&lt;li&gt;学习之作难免浅薄，欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。&lt;/li&gt;
&lt;/ul&gt;
&lt;div align="right"&gt;
*2011/12/6 By Adoo | Homepage:*[*www.roading.org*][]

&lt;/div&gt;

&lt;div align="left"&gt;

* * * * *

&lt;/div&gt;

&lt;h3&gt;何时生成临时对象&lt;/h3&gt;
&lt;p&gt;对于一个下面这样的程序片段：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;死板一点来讲，它应当产生一个临时对象用来存储 a+b
的结果，然后以临时对象作为初值调用拷贝构造函数初始化对象c。而实际上编译器更愿意直接调用拷贝构造函数的方式将
a+b
的值放到c中，这样就不需要临时对象，和它的构造函数和拷贝构造函数的调用了。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;更进一步，如果 operator +
的定义符合NRV优化的条件，那么NRV优化的开启，将使得拷贝构造函数的调用和
named object
的析构函数都免了。期间详情可以参见”&lt;a href="http://www.roading.org/?p=544"&gt;NRV优化&lt;/a&gt;”。也就是说对于上面那种情形在我们的代码中是不产生临时对象的。但是对于一个情况非常类似的赋值操作语句，却有很大的差别，那个临时变量是不能省的:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;不能忽略临时对象，反而导致如下结果：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Pseudo C++ code  &lt;/span&gt;
&lt;span class="c1"&gt;// T temp = a + b;  &lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 【1】 1 &lt;/span&gt;

&lt;span class="c1"&gt;// c = temp  &lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 2  &lt;/span&gt;
&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;在代码 1
处，表明以拷贝构造函数或NRV方式将结果保存的临时对象中。为什么不能省略那个临时对象，比如直接这样：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;这不是更高效，更简洁的方式吗？不行，其原因在于，
拷贝构造函数、析构函数以及赋值操作符都可以有使用证提供，没有人能保证，析构函数加拷贝构造函数的组合和赋值操作符具有相同的含义。所以：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;总是比下面的操作更有效率：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;对于一个没有出现目标对象的表达式：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;那么产生一个临时对象来存储运算结果，则是非常必要的。&lt;/p&gt;
&lt;/p&gt;

&lt;h3&gt;临时对象的生命周期&lt;/h3&gt;
&lt;/p&gt;

&lt;p&gt;很多时候，产生临时对象是必不可少的，但是何时摧毁一个临时对象才是最佳行为呢？过早或过晚都不太适合，过早有可能使得程序错误，过晚的话又使得资源没有得到及时回收。对于下面的程序：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&amp;quot;&lt;span class="n"&gt;hello&lt;/span&gt; &amp;quot;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&amp;quot;&lt;span class="n"&gt;world&lt;/span&gt; &amp;quot;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;s3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&amp;quot;&lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;Adoo&lt;/span&gt;&amp;quot;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;s3&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;显然保存 s1+s2
结果的临时对象，如果在与s3进行加法之前析构，将会带来大麻烦。与是C++
标准中有一条：&lt;/p&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;临时性对象的摧毁应当作为造成产生这个临时对象的完整表达式的最后一个步骤。&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;p&gt;完整的表达式，是指涵括的表达式中最外围的那个。我们再看上面那个字符串相加的表达式，当计算完成，而cout还未调用，此时我们析构掉存储最终结果的临时对象，岂不悲剧。其实上面的规定还有两个例外：&lt;/p&gt;
&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;凡含有表达式执行结果的临时性对象，应该保存到 Object
    的初始化操作完成为止。&lt;/li&gt;
&lt;li&gt;如果临时性对象被绑定与一个引用，临时对象将残留，直至被初始化的引用的生命结束，或直到临时对象的生命周期结束——视哪一种情况先达到，对应于这种情况：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&amp;quot;&lt;span class="n"&gt;hello&lt;/span&gt; &amp;quot;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&amp;quot;&lt;span class="n"&gt;world&lt;/span&gt;&amp;quot;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;/p&gt;

&lt;p&gt;注【1】：侯捷认为此处为 Lippman 的错误，他认为应该
temp.&lt;span style="color: blue"&gt;operator&lt;/span&gt;+( a, b );
但我以为是侯捷并没有理解 Lippman 的意思，回顾一下,《深度探索对象模型》2.3
讲到的返回值初始化(Return Value
Initialization)——返回值将作为一个额外的参数提供给函数，来传回函数内部的值，也就是说对于一个
operator + 操作符：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;将转化为：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;所以&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;是&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还是：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;自然不言而喻。&lt;/p&gt;
&lt;/p&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category></entry><entry><title>对象的构造和析构</title><link href="http://www.roading.org//develop/cpp/%e5%af%b9%e8%b1%a1%e7%9a%84%e6%9e%84%e9%80%a0%e5%92%8c%e6%9e%90%e6%9e%84.html" rel="alternate"></link><updated>2011-12-06T13:35:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-06:/develop/cpp/%e5%af%b9%e8%b1%a1%e7%9a%84%e6%9e%84%e9%80%a0%e5%92%8c%e6%9e%90%e6%9e%84.html</id><summary type="html">&lt;p&gt;&lt;em&gt;摘要：本文为《深度探索C++对象模型》第六章——执行期语意学（Runtime
Semantics）笔记之一，主要内容包括三种情况下的对象构造和解构——全局对象、局部静态对象和对象数组。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一般而言，构造函数被安插在对象的定义处，而析构函数被安插在对象生命周期结束前：&lt;/p&gt;
&lt;div align="left"&gt;

wzxhzdk:0

&lt;/div&gt;

&lt;/p&gt;

&lt;p&gt;当代码有一个以上的离开点的时候，析构函数则必须放在对象被构造之后的每一个离开点之前。因此，尽可能将对象定义在接近要使用的地方，可以减少不必要的构造对象和析构对象的代码被插入到自己的代码当中。&lt;/p&gt;
&lt;/p&gt;

&lt;h3&gt;全局对象&lt;/h3&gt;
&lt;/p&gt;

&lt;p&gt;一个全局对象，c++保证它在main()
在第一次使用它之前将其构造，而在main()结束之前，将之析构掉。C
规定一个全局对象只能被一个常量表达式(编译期可知)赋初值。而构造函数显然不是一个常量表达式。虽然全局对象在编译期被即被置为0，但真正的构造工作却需要直到程序激活后才能进行，而这个过程就是所谓的静态初始化。我是这样理解，但我不保证正确，因为全局变量，被放在
data segment (数据段)， data segment
是在编译期已经布置好的，但构造函数的结果在编译期不能评估，因此先将对象的内容设置为0，存储在数据段，而等到程序激活时，这时候就可以通过构造函数对在数据段的全局对象进行初始化了，而这就是所谓的静态初始化。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;静态初始化的对象有一些缺点：如果构造函数支持异常机制，那么遗憾的是对象的构造函数的调用，无法被放置与try块中，我们知道一个没有得到catch的异常默认的调用
terminate ()
函数。也就是说一个全局对象在构造过程中抛出异常，将导致程序的终结，而更悲剧的是，你还无法来捕获并处理这个异常。另一点在于，在不同文件中定义的全局变量，构造顺序有规则吗？我不知道。即使有规则，如果不同的构造顺序对程序有影响的话，那么有多琐碎复杂…&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;Lippman
甚至建议：根本就不要使用那些需要静态初始化的全局对象。真的非要一个全局对象，而且这个对象还需要静态初始化？那么我的方法是，用一个函数封装一个静态局部对象，也是一样的效果嘛。&lt;/p&gt;
&lt;/p&gt;

&lt;h3&gt;局部静态对象(Local Static Object)&lt;/h3&gt;
&lt;/p&gt;

&lt;p&gt;下面一段代码：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Matrix&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;  &lt;span class="n"&gt;identity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Matrix&lt;/span&gt; &lt;span class="n"&gt;mat_identity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;  
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;mat_identity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;因为静态语意保证了 mat_identity 在整个程序周期都存在，而不会在函数
identity() 退出时被析构，所以：&lt;/p&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mat_identity 的构造函数只能被施行一次，虽然 identity()
    可以被调用多次。&lt;/li&gt;
&lt;li&gt;mat_identity 的析构函数只能被施行一次，虽然 identity()
    可以被调用多次。&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;p&gt;那么 mat_identity
的构造函数和析构函数到底在什么时候被调用？答案是，mat_identity
的构造函数只有在第一次被调用时在被施行，而在整个程序退出之时按构造相反的顺序析构局部静态对象。&lt;/p&gt;
&lt;/p&gt;

&lt;h3&gt;对象数组(Array of Objects)&lt;/h3&gt;
&lt;/p&gt;

&lt;p&gt;对于定义一个普通的数组，例如：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="n"&gt;knots&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; 10 &lt;span class="p"&gt;];&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;实际上背后做的工作则是：1.分配充足的内存以存储10个 Point
元素；2.为每个Point
元素调用它们的默认构造函数(如果有的话，且不论是合成的还是显式定义的)。编译器一般以一个或多个函数来完成这个任务。当数组的生命周期结束的时候，则要逐一调用析构函数，然后回收内存，编译器同样一个或多个函数来完成任务。这些函数完成什么功能，大概都能猜得出来。而关于细节，不必要死扣了，每个编译器肯定都有些许差别。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;font color="#d16349"&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;参考：Lippman 的两本书《深度探索C++对象模型》和《C++ Primer》。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。&lt;/em&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;div align="right"&gt;
*2011/12/6 By Adoo | Homepage:*[*www.roading.org*][]

&lt;/div&gt;

&lt;/p&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category></entry><entry><title>new expression、operator new 和 placement new——三个“妞（new）”的故事（3）</title><link href="http://www.roading.org//develop/cpp/new-expression%e3%80%81operator-new-%e5%92%8c-placement-new%e4%b8%89%e4%b8%aa%e5%a6%9e%ef%bc%88new%ef%bc%89%e7%9a%84%e6%95%85%e4%ba%8b%ef%bc%883%ef%bc%89.html" rel="alternate"></link><updated>2011-12-05T15:49:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-05:/develop/cpp/new-expression%e3%80%81operator-new-%e5%92%8c-placement-new%e4%b8%89%e4%b8%aa%e5%a6%9e%ef%bc%88new%ef%bc%89%e7%9a%84%e6%95%85%e4%ba%8b%ef%bc%883%ef%bc%89.html</id><summary type="html">&lt;p&gt;&lt;font face="微软雅黑"&gt;&lt;em&gt;引言：之前虽然一直知道有new expression、operator
new 和 placement new
，但对于这三个“new”,却不甚了了，这些天从《深度探索C++对象模型》读到new
和delete，特意结合《C++
Primer》写下这篇笔记，以作总结。三个虽然都是“妞”（new），但每个妞都不相同各有各的特点，各有各的风味，本文重点在于总结比较这三个
“妞”，但期间也不忘提一提推倒这三个“妞”的哥们——delete。&lt;/em&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h2&gt;placement operator new&lt;/h2&gt;
&lt;p&gt;placement operator new
用来在指定地址上构造对象，要注意的是，它并不分配内存，仅仅是对指定地址调用构造函数。其调用方式如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;point3d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;观其名字可知，它是 operator new
的一个重载版本。它的实现方式异常简单，传回一个指针即可：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;site_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;不必要惊讶于它的简单，《深度探索C++对象模型》中Lippman
告诉我们，它有另一半重要的工作是被扩充而来。我在想，扩充一个类中定义的
placement operator new 还好说，但是要如何扩充一个库中提供的 placement
operator
new呢？毕竟它要放之四海而皆准，我原以为这其中有什么高超的技巧。后来我则坚信根本就没有什么扩充，placement
operator new 也并不强大。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;我先明确调用了 placement operator new ：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;=(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;如我所料，输出结果显示（我在 point 的默认构造函数和 placement operator new
中间各输出一句不同的话），此时 point
的默认构造函数并不会被调用。然后我通过new expression
的方式来间接调用placement operator new：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;这个时候 point 的默认的构造函数被调用了。可见 placement operator new
并没有什么奇特的地方，它与一般的 operator new
不同处在于，它不会申请内存。它也不会在指定的地址调用构造函数，而调用构造函数的的全部原因在于
new expression 总是先调用一个匹配参数的 operator new
然后再调用指定类型的匹配参数的构造函数，而说到底 placement operator new
也是一个 operator new。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;通过一个 placement operator new 构建的一个对象，如果你使用 delete
来撤销对象，那么其内存也被回收，如果想保存内存而析构对象，好的办法是显示调用其析构函数。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;看一份代码：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;fooBar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
   &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;invoked&lt;/span&gt;  
   &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
   &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; 1  
   &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;which&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;invoked&lt;/span&gt;?  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;上述两个类的大小相同，因此将Derived 对象放在 Base
对象中是安全的，但是在最后一句代码中 b.f()调用的是哪一个类的f()。答案是
Base::f() 的。虽然此时b中存储的实际上是一个Derived
对象，但是，通过一个对象来调用虚函数，将被静态决议出来，虚函数机制不会被启用。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;参考：Lippman 的两本书《深度探索C++对象模型》和《C++ Primer》。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;font face="微软雅黑"&gt;欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。&lt;/font&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2011/12/5 By Adoo | Homepage:&lt;/em&gt;&lt;a href="http://www.roading.org"&gt;&lt;em&gt;www.roading.org&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/p&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category></entry><entry><title>new expression、operator new 和 placement new——三个“妞（new）”的故事（2）</title><link href="http://www.roading.org//develop/cpp/new-expression%e3%80%81operator-new-%e5%92%8c-placement-new%e4%b8%89%e4%b8%aa%e5%a6%9e%ef%bc%88new%ef%bc%89%e7%9a%84%e6%95%85%e4%ba%8b%ef%bc%882%ef%bc%89.html" rel="alternate"></link><updated>2011-12-05T15:19:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-05:/develop/cpp/new-expression%e3%80%81operator-new-%e5%92%8c-placement-new%e4%b8%89%e4%b8%aa%e5%a6%9e%ef%bc%88new%ef%bc%89%e7%9a%84%e6%95%85%e4%ba%8b%ef%bc%882%ef%bc%89.html</id><summary type="html">&lt;p&gt;&lt;em&gt;&lt;font face="微软雅黑"&gt;引言：之前虽然一直知道有new expression、operator
new 和 placement new
，但对于这三个“new”,却不甚了了，这些天从《深度探索C++对象模型》读到new
和delete，特意结合《C++
Primer》写下这篇笔记，以作总结。三个虽然都是“妞”（new），但每个妞都不相同各有各的特点，各有各的风味，本文重点在于总结比较这三个
“妞”，但期间也不忘提一提推倒这三个“妞”的哥们——delete。 &lt;/font&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;两个 delete 后的问题&lt;/h3&gt;
&lt;div align="left"&gt;
最近在网上看到两个关于指针 delete 后的问题。第一种情况：

wzxhzdk:0

&lt;/div&gt;

&lt;/p&gt;

&lt;p&gt;第二种情况：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;   &lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;5&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;delete&lt;/span&gt;后对 &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; 进行再赋值居然也可以（他的平台上运行并没有引发什么错误）？
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;在回答这两个问题之前，我们先想想 delete p; 这一语句意味着什么？ p
指向一个地址，以该地址为起始地址保存有一个int
变量（虽然该变量并没有进行初始化），delete p 之后 p
所指向的地址空间被释放，也就是说这个 int 变量的生命结束，但是 p
仍旧是一个合法的指针，它仍旧指向原来的地址，而且该地址仍旧代表着一个合法的程序空间。与
delete
之前唯一的不同是，你已经丧失了那快程序空间的所有权。这带来一个什么样的问题？你租了一间储物室（&lt;span style="color: blue"&gt;int&lt;/span&gt;*
p=&lt;span style="color: blue"&gt;new int &lt;/span&gt;;
），后来退租了（&lt;span style="color: blue"&gt;delete &lt;/span&gt;p;
），但你却保存了出入该储物室的钥匙（指针
p）没有归还。拥有这片钥匙，你或许什么都不做，这自然没有问题。但是：&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;你或许出于好心，又跑过去告诉房东，“Hi！这储物室已经退租了（第一种情况）”。哦噢，会发生什么？我们假设此时这个房子已经有了新的租客。愚笨的房东直接相信了你的话，认为这个储物室空着，把它又租给新的人。于是一间只能给一个人用的储物室，却租给了两个人，再之后各种难以预料的情况就会发生。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;又或许，你很无耻，你虽然退租，但却想用你的钥匙依旧享有储物室的使用权（第二种情况），结果呢，你存在这间储物室的东西可能会被现在的租客丢掉，而你也可能把他的东西丢掉，腾出空间来放你的。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;回到上面的程序上来，毫无疑问的是上面的程序在语法上来讲是合乎规范的，但是暗藏着很大的逻辑错误，不论你对一块已经释放的内存再度
delete ，还是再度给它赋值，都暗含着很大的危险，因为当你 delete
后，就代表着将这块内存归还。而这块被归还的内存很可能已经被再度分配出去，此时不论是你再度
delete
还是重新赋值，都将破坏其它代码的数据，同时你存储在其中的数据也很容易被覆盖。至于报不报错，崩不崩溃，这取决于有一个怎么样的“房东”，聪明且负责的“房东”会阻止你上述的行为——终止你的程序，懒惰的房东，则听之任之。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;上述情况下的指针p
被称为野指针——指向了一块“垃圾内存”，或者说指向了一块不应该读写的内存。避免野指针的好方法是，当一个指针变为野指针的时候，马上赋值为NULL，其缘由在于，你可以很容易的判断一个指针是否为NULL,却难以抉择其是否为野指针。而且，delete
一个空指针，不会做任何操作，因此总是安全的。&lt;/p&gt;
&lt;/p&gt;

&lt;h3&gt;不用一个基类指针指向派生类数组？&lt;/h3&gt;
&lt;/p&gt;

&lt;p&gt;《深度探索C++
对象模型》中指出，不要用一个基类指针指向派生类的数组。因为在他的cfront中的vec_delete是根据被删除指针的类型来调用析构函数——也就是说虚函数机制，在这儿不起作用了。照这样的思路来说，对一个派生类的数组依次调用其基类的析构函数，显然大多时候不能正确析构——派生类一般大于其基类。但是我感兴趣的一点是，这么多年过去了，这样一个不太合理的设计是否有所改进呢？说它不太合理是，以C++编程者的思路，在这样一种情况下，它应该支持多态，而且在这种情况下支持多态并不需要太复杂的机制和代价。我在vc++
2008 和 vc++ 2010 下的结果是：是的，有与cfront不同，它支持多态。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;我的测试代码如下：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
       &lt;span class="n"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
           &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&amp;quot;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&amp;quot;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;private&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;point3d&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;point3d&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&amp;quot;&lt;span class="n"&gt;point3d&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;point3d&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&amp;quot;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;private&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;point3d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;2&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&amp;quot;&lt;span class="n"&gt;pause&lt;/span&gt;&amp;quot;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;输出的结果，也令人满意：&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/12/image_thumb1.png" title="image" /&gt;][]&lt;/p&gt;
&lt;/p&gt;

&lt;/p&gt;

&lt;/p&gt;

&lt;/p&gt;

&lt;/p&gt;

&lt;p&gt;确实调用了派生类的析构函数，而非基类的析构函数。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;即使如此，是否能安心的使用一个基类指针指向派生类数组？我不太安心！——对于基类的析构函数是否为虚函数没有把握。所以最好还是不要把一个基类的指针指向派生类数组。非得这么做？那么我认为
delete 的时候将之类类型转换为派生类就差不多了，可以这样:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;point3d&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;似乎不必要像Lippman说的这样：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ix&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; 0&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;ix&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;elem_count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;ix&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;  
   &lt;span class="n"&gt;Point3d&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt; &lt;span class="n"&gt;ix&lt;/span&gt; &lt;span class="p"&gt;];&lt;/span&gt;  
   &lt;span class="n"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;参考：Lippman 的两本书《深度探索C++对象模型》和《C++ Primer》。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;font face="微软雅黑"&gt;欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。&lt;/font&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2011/12/2 By Adoo | Homepage:&lt;/em&gt;&lt;a href="http://www.roading.org"&gt;&lt;em&gt;www.roading.org&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/12/image_thumb1.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2011/12/image1.png&lt;/p&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category></entry><entry><title>new expression、operator new 和 placement new——三个“妞（new）”的故事（1）</title><link href="http://www.roading.org//develop/cpp/new-expression%e3%80%81operator-new-%e5%92%8c-placement-new%e4%b8%89%e4%b8%aa%e5%a6%9e%ef%bc%88new%ef%bc%89%e7%9a%84%e6%95%85%e4%ba%8b%ef%bc%881%ef%bc%89.html" rel="alternate"></link><updated>2011-12-02T23:35:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-02:/develop/cpp/new-expression%e3%80%81operator-new-%e5%92%8c-placement-new%e4%b8%89%e4%b8%aa%e5%a6%9e%ef%bc%88new%ef%bc%89%e7%9a%84%e6%95%85%e4%ba%8b%ef%bc%881%ef%bc%89.html</id><summary type="html">&lt;p&gt;&lt;em&gt;&lt;font face="微软雅黑"&gt;引言：之前虽然一直知道有new expression、operator
new 和 placement new
，但对于这三个“new”,却不甚了了，这些天从《深度探索C++对象模型》读到new
和delete，特意结合《C++
Primer》写下这篇笔记，以作总结。三个虽然都是“妞”（new），但每个妞都不相同各有各的特点，各有各的风味，本文重点在于总结比较这三个“妞”，但期间也不忘提一提推倒这三个“妞”的哥们——delete。
&lt;/font&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;font face="微软雅黑"&gt;&lt;/font&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;new expression 和 operator new&lt;/h3&gt;
&lt;p&gt;一个看起来很简单的new expression
运算，其实暗含一些步骤，如像这样的一次简单运用：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;5&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;实际上包含着两个步骤：&lt;/p&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;调用一个合适的 operator new 实体分配足够的未类型化的内存。&lt;/li&gt;
&lt;li&gt;调用合适的构造函数初始化这块内存，当然int
    没有构造函数，但是会进行赋值操作： *p=5;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;p&gt;由此可见：new expression 和 operator new
完全不是一回事，但关系不浅——operator new 为 new expression 分配内存。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;摘录一下 《C++ primer》关于对比new expression 和 operator new
的一小段话：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;标准库函数 operator new和 operator delete 的命名容易让人误解。与其他
operator 函数（如 &lt;code&gt;operator=&lt;/code&gt;）不同，这些函数没有重载 new或 delete
expression，实际上，我们不能重定义 new或 delete expression的行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;

&lt;p&gt;这段话有两个要点：1. operator new 和 operator delete 不是new expression
和 delete expression
的重载，它们完全是另外的一个独立的东西，具有不同的语意，这与 operator +
是对+ expression 的重载不同。2. new expression 和 delete expression
是不能被重载的，可以看出它们与普通的 expression 不同。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;operator new
其实也是可以直接利用的，譬如当我们只想分配内存，而不愿意进行初始化的时候，我们就可以直接用
operator new 来进行。用法如下：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;newelements&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;标准库重载有两个版本的 operator new
，分别为单个对象和数组对象服务，单个对象版本的提供给分配单个对象new
expression 调用，数组版的提供给分配数组的 new expression 调用：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;allocate&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt;
&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;allocate&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;&lt;span style="color: green"&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;我们可以分别重载这两个版本，来定义我们自己的分配单个对象或对象数组的内存方式。当我们自己在重载operator
new
时，不一定要完全按照上面两个版本的原型重载，唯一的两个要求是：返回一个void*
类型和第一个参数的类型必须为size_t。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;还要注意的是，在类中重载的 operator new 和 operator delete
是隐式静态的，因为前者运行于对象构造之前，后者运行与对象析构之后，所以他们不能也不应该拥有一个this指针来存取数据。另外，new
expression 默认调用的是单参数的operator
new——上面声明的那种，而其它不同形式的重载，则只能显示调用了。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;delete expression 与 new expression 相对应，而 operator delete 则与
operator new 对应。依上所述，则不难推倒出关于delete expression 和
operator delete之间的关系以及一些特性，此略。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;当使用new expression
来动态分配数组的时候，Lippman在《深度探索C++对象模型》中指出：当分配的类型有一个默认构造函数的时候，new
expression 将调用一个所谓的 vec_new()函数来分配内存，而不是operator new
内存。但我在VC ++ 2010 上测试的结果却是，不论有没有构造函数，new
expression 都是调用operator new
来分配内存，并在此之后，调用默认构造函数逐个初始化它们，而不调用所谓的vec_new()，也许cfront
确实离我们有点遥远。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;参考：Lippman 的两本书《深度探索C++对象模型》和《C++ Primer》。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;font face="微软雅黑"&gt;欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。
&lt;/font&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2011/12/2 By Adoo | Homepage:&lt;/em&gt;&lt;a href="http://www.roading.org"&gt;&lt;em&gt;www.roading.org&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/p&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category></entry><entry><title>构造、复制、析构语意学</title><link href="http://www.roading.org//develop/cpp/%e6%9e%84%e9%80%a0%e3%80%81%e5%a4%8d%e5%88%b6%e3%80%81%e6%9e%90%e6%9e%84%e8%af%ad%e6%84%8f%e5%ad%a6.html" rel="alternate"></link><updated>2011-12-01T22:04:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-01:/develop/cpp/%e6%9e%84%e9%80%a0%e3%80%81%e5%a4%8d%e5%88%b6%e3%80%81%e6%9e%90%e6%9e%84%e8%af%ad%e6%84%8f%e5%ad%a6.html</id><summary type="html">&lt;p&gt;一种所谓的Plain OI’Data声明形式：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;float&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;概念上来讲，对于一段这样的C++代码：
编译器会为之合成一个默认构造函数、复制构造函数、析构函数、赋值操作符。然而实际上编译器会分析这段代码，并给
Point 贴上Plain OI’Data
标签。编译器在此后对于Point的处理与在C中完全一样,也就是说上述的函数都不会被合成。可见概念上应当由编译器合成的函数，并不一定会合成，编译器只有在必要的时候才会合成它们。
由此一来，原本在观念上应该调用这些函数的地方实质上不会调用，而是用其它的方法来完成上面的功能，比方复制控制会用bitwise
copy。&lt;/p&gt;
&lt;/p&gt;

&lt;h2&gt;对象构造语意学&lt;/h2&gt;
&lt;/p&gt;

&lt;p&gt;无继承情况下的对象构造：略。&lt;/p&gt;
&lt;/p&gt;

&lt;h3&gt;单继承体系下的对象构造&lt;/h3&gt;
&lt;/p&gt;

&lt;p&gt;对于简单定义的一个对象：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;很明显它的默认构造函数会被调用（被编译器合成的或用户提供的）。但是一个构造函数究竟做了什么，就显得比较复杂了——编译器给了它很多的隐藏代码。编译器一般会做如下扩充操作^【1】^：&lt;/p&gt;
&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;调用所有虚基类的构造函数，从左到右，从最深到最浅：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果该类被列于成员初始化列表中，任何明确明确指定的参数，都应该被传递过来。若没有列入成员初始化列表中，虚基类的一个默认构造函数被调用（有的话）。&lt;/li&gt;
&lt;li&gt;此外，要保证虚基类的偏移量在执行期可存取，对于使用vbptr来实现虚基类的编译器来说，满足这点要求就是对vbptr的初始化。&lt;/li&gt;
&lt;li&gt;然而，只有在类对象代表着“most-derived
    class”时，这些构造函数才可能会被调用。一些支持这个行为的代码会被放进去^【2】^&lt;font color="#a5a5a5"&gt;(直观点说就是，虚基类的构造由最外层类控制)。
    &lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用所有基类构造函数，依声明顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果该基类被列入了成员初始化队列，那么所有明确指定的参数，应该被传递过来。&lt;/li&gt;
&lt;li&gt;没有列入的话，那么调用其默认构造函数，如果有的话。&lt;/li&gt;
&lt;li&gt;如果该基类是第二顺位或之后的基类，this 指针必须被调整。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正确初始化vptr,如果有的话。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;调用没有出现在初始化成员列表中的member object
    的默认构造函数，如果有的话。&lt;/li&gt;
&lt;li&gt;记录在成员初始化队列中的数据成员初始化操作以声明的顺序被放进构造函数中。&lt;/li&gt;
&lt;/ol&gt;
&lt;/p&gt;

&lt;h3&gt;虚拟继承下的构造抑制&lt;/h3&gt;
&lt;/p&gt;

&lt;p&gt;有如下继承体系：&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/12/image_thumb.png" title="image" /&gt;][]&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;根据c++ 语法，Point 的初始化应有 most-derived class
来施行。也就是说当Vertex3d 为 most-derived class
的时候，应当由它的构造函数来调用Point的构造函数初始化Point
子对象，Vertex3d的子对象的构造函数对于Point的调用则应当抑制。如果没有抑制会怎么样?
当我们定义：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;   &lt;span class="n"&gt;Vertex3d&lt;/span&gt; &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;时，Vertex3d 的构造函数中调用Point
的构造函数、而随之调用它的子对象，Point3d 和
Vertex的构造函数中也调用了Point的构造函数。先不说，对于同一个子对象进行三次初始化是否有效率，更重要的是，这将不可避免的带来错误。由Vertex3d指定的子对象Point的值，会被覆盖掉。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;编译器通常使用一个条件变量来表示是否为most-derived
class,各构造函数根据这个条件变量来决定是否调用虚基类的构造函数，因此通过控制这个条件变量，就可以抑制非most-derived
class调用虚基类的构造函数。当然也有其它的方法来做同样的事。&lt;/p&gt;
&lt;/p&gt;

&lt;h2&gt;对象复制语意学&lt;/h2&gt;
&lt;/p&gt;

&lt;p&gt;设计一个类，并考虑到要以一个对象指定给另一个对象时，有三种选择：&lt;/p&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;什么都不做，采用编译器提供默认行为（bitwise copy
    或者由编译器合成一个）。&lt;/li&gt;
&lt;li&gt;自己提供一个赋值运算符操作。&lt;/li&gt;
&lt;li&gt;明确拒绝将一个对象指定给另一个对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;p&gt;对于第三点，只要将赋值操作符声明为private，且不定义它就可以了。对于第二点，只有在第一点的行为不安全或不正确，或你特别想往其中插入点东西的时候。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;以下四种情况 copy assignment
operator(还是用它的英文名，感觉顺畅点)，不具有bitwise copy
语意，也就是说这些情况下，编译器要合成copy assignment operator
而不能依靠bitwise copy
来完成赋值操作，这四种情况与构造函数、&lt;a href="http://www.roading.org/?p=541"&gt;拷贝构造函数&lt;/a&gt;的情况类似，原因可以参考它们的。四种情况如下：&lt;/p&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;类包含有定义了copy assignment operator 的 class object 成员。&lt;/li&gt;
&lt;li&gt;类的基类有 copy assignment operator 。&lt;/li&gt;
&lt;li&gt;类声明有任何虚函数的时候（问题同样会出现在由继承类对象向基类对象拷贝的时候）。&lt;/li&gt;
&lt;li&gt;当class继承体系中有虚基类时。&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;p&gt;在虚拟继承情况下，copy assignment opertator
会遇到一个不可避免的问题，virtual base class subobject
的复制行为会发生多次，与前面说到的在虚拟继承情况下虚基类被构造多次是一个意思，不同的是在这里不能抑制非most-derived
class 对virtual base class 的赋值行为。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;安全的做法是把虚基类的赋值放在最后，避免被覆盖。&lt;/p&gt;
&lt;/p&gt;

&lt;h2&gt;对象析构语意学&lt;/h2&gt;
&lt;/p&gt;

&lt;p&gt;只有在基类拥有析构函数，或者object member
拥有析构函数的时候，编译器在为类合成析构函数，否则都被视为不需要。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;析构的顺序正好与构造相反：&lt;/p&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;本身的析构函数被执行。&lt;/li&gt;
&lt;li&gt;以声明的相反顺序调用member object 的析构函数，如果有的话。&lt;/li&gt;
&lt;li&gt;重设vptr 指向适当的基类的虚函数表，如果有的话。&lt;/li&gt;
&lt;li&gt;以声明相反的顺序调用上一层的析构函数，如果有的话。&lt;/li&gt;
&lt;li&gt;如果当前类是 most-derived
    class，那么以构造的相反顺序调用虚基类的析构函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注1&lt;/strong&gt;：下面的叙述顺序看似与原书的顺序不一样。实际顺序并没有被调整，很多个“在此之前”的叙述并不适合我，我喜欢很直白的方式，按顺序来。书中的方式在于，从最浅显的步骤入手，然后告诉你，做这步之前，你还该做点什么。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注2：&lt;/strong&gt;这一点上我参考英文版后，感觉侯大大的翻译并没有完全表达Lippman的原意，所以，我以对原文的理解写下这点。Lippman的原文为：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;These constructors, however, may be invoked if, and only if, the class
object represents the "most-derived class." Some mechanism supporting
this must be put into place.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;

&lt;p&gt;侯捷的译文为：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果class object
是最底层（most-derived）的class,其constructors可能被调用；某些用以支持这个行为的机制必须被放进来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;

&lt;p&gt;我认为，Lippman才这一句上要说的是，虚基类的构造函数只能由 most-derived
class调用，而为了支持这一机制，需要插入一些代码来抑制非most-derived
class对虚基类构造函数的调用。同时说一点，5.4的标题个人以为应该译为
“对象的效率”而非“对象的功能”——原标题为：Object Efficency。&lt;/p&gt;
&lt;/p&gt;

&lt;/p&gt;

&lt;p&gt;&lt;em&gt;欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。&lt;/em&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2011/12/1 By Adoo | Homepage:&lt;/em&gt;&lt;a href="http://www.roading.org"&gt;&lt;em&gt;www.roading.org&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/12/image_thumb.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2011/12/image.png&lt;/p&gt;</summary><category term="c++"></category><category term="Inside The C++ Object Model"></category></entry></feed>