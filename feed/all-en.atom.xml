<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Adoo's blog</title><link href="http://www.roading.org/" rel="alternate"></link><link href="http://www.roading.org/feed/all-en.atom.xml" rel="self"></link><id>http://www.roading.org/</id><updated>2012-12-25T03:30:00+08:00</updated><entry><title>未半</title><link href="http://www.roading.org/essaies/less_than_half_of_year.html" rel="alternate"></link><updated>2012-12-25T03:30:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-12-25:essaies/less_than_half_of_year.html</id><summary type="html">&lt;p&gt;来珠海也近半年了，半年来并没有太大的不顺。大概却正因为这顺利，让我恍然
未觉的过了半年。时间过得如此悄无声息，让我战战栗生出了一股惶恐来。每过
一月，或又仅有一旬，当我注意到桌上的台历忘了翻动，又或者电脑上的日期让
我觉得陌生时，我总觉得我应该静下来好好想想，生活是不是驶往我期待的方向。&lt;/p&gt;
&lt;p&gt;我原来想到“半”不免就生出一股沮丧来。半年的时间，便如同朝暮一般，来时的
景象，朋友间的相约，路上的拥挤，犹在眼前。冬夏之替，也只如隔一日。但任
我觉得只是短短的意象，却又是实打实的半年，我只恨这半年没有留下更多点记
忆，能做多点想做的事情。&lt;/p&gt;
&lt;p&gt;若单单是这偶尔感由心生的点点悲哀的话，也不会叫我如何的。便是一觉睡来也
就揭过，如何能令我这心思粗鄙，心间缺少玲珑的人时时挂怀呢？&lt;/p&gt;
&lt;p&gt;叫我忧心的却另有其它几样小事。&lt;/p&gt;
&lt;p&gt;我来时极想做的几件事一件也没能做成，极想看的几本书一本也没有去看。前几
日又恰巧读到了知堂的一段笔记——“转瞬仲冬，学术无进，而马齿渐增，不觉恧
然”——这是多么和我相像的一种心情。我所虑的又不止于此。我原来像做的事、
想看的书，半年之后依旧，只是时间已过半年。我只怕十年八载之后，依旧如现
在这般想法，然后感叹十年转瞬。我太怕在安逸中老去，忘却了我来这世界的初
衷，相反，我倒更愿意哪怕在困境中前行，却能一直砥砺品行，让自己铭记最初
的想法。&lt;/p&gt;
&lt;p&gt;知堂那段话让我心生共鸣之外，也令我“不觉恧然”，他那段日记大概十三四岁所
记，而这样的道理，我却明白的晚了许多。&lt;/p&gt;
&lt;p&gt;除却知堂那段话，却又有一段零碎的梦也触动了我的神经。这段梦是近断时间做
的，哪天晚上也记不得了，这梦可说平凡无奇，却又有些怪诞不经。我梦见了不
知是回到了小学，还是初中时代，端坐在教室读书，周身同学连我在内，却并没
有回归童颜，都是一副大人模样。这样不讲逻辑的事情，出现在梦中，本是在平
常不过，但我坚信，它是要叫我明白逝者如斯，不可回追的道理，也是要叫我明
白，物是人非，沧海桑田的残酷。&lt;/p&gt;
&lt;p&gt;下午，我再无法抑制这种情感的上升，于是打开了编辑器。编辑器中有一条“未
半”的标题、一条“2012-12-16 07：30”的时间戳、一句“我来珠海也近半年了”的
开头。十七号写下一个“未半”的标题，一是心里感叹半年过得太快，但距离半年
尚差几日，可以说是“未半”。再则，若是倒过来看，“半”也就成了“未”，掺杂点
未来的意为，也能带股生气来。今日已是二十五，半年也足足有了，无所谓“未
半”了。我于是又慎重的关了编辑器，拿出笔和纸，记下上文。&lt;/p&gt;
&lt;p&gt;十二月二十五日于莲山巷。&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Tue 25 December 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.orgessaies/less_than_half_of_year.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="随笔"></category></entry><entry><title>载酒买花年少事，浑不似，旧心情</title><link href="http://www.roading.org//essaies/lonely.html" rel="alternate"></link><updated>2012-09-14T00:00:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-09-14:/essaies/lonely.html</id><summary type="html">&lt;p&gt;当我打开记事本想写点什么的时候，写一个怎样的题目却让我犯难。难在我
并无什么特别的要求，标题党？我不需要夺人眼球。做点概括？我也并没有
要具体写点什么东西。我想大概这篇短文并不需要一个标题。不过，鉴于这
个世界有这么多长着脑袋却并没有什么用处的脑残们，我认为我的这篇短文
也配拥有一个标题，尽管它或许并没有太大的用处。&lt;/p&gt;
&lt;p&gt;好在我并不是太纠结的人。随意从桌头抽出一本书，然后随意翻开一页，从
里面取一句，足矣。老实说，我不太喜欢宋词——长短句，浅唱低吟，听着好
听，但更像是为诉苦叫春量身定做的，你若读这两种题材的词句，总能分外
打动人心。不过，说来世界总是奇妙的，随便挑捡的这句话，却也能称了我
的心情。&lt;/p&gt;
&lt;p&gt;写这篇短文我打算了很久，迟迟不能动笔的原因在于，我每天在上班之前十
五分钟的想法，被八个钟头的编程抹去。而晚上，有太多事情排不上号，而
这甚至连事情都算不上。一天的大部分时间里，我大概和我面前的那台机器
一般无二，但沉重的心情总在梦醒时分汹涌而来。我不是感情细腻的家伙，
也尽管一再坚信自己能忍耐寂寞、孤独与不被承认。但却越来越发觉，这个
世界存在着人类挣脱不掉的孤独，你安心忍耐也好，你拼命挣扎也罢，它总
能抓住机会爆发。&lt;/p&gt;
&lt;p&gt;会有这么一段日子，我们有太多想做的事情，却没有时间去做了。上半年为
还这样告诫自己：“诸般烦恼，只因想的太多，做的太少。”一个背身的功夫，
有太多的事情，不是不去做，而是你迟缓的脚步再难跟上时间的步伐。时间
慢慢会教会人，或者说逼迫人做一些取舍，你只能叹息，还是叹息。时间也
会做出一些决定，你或者接受，或者反抗了之后接受。&lt;/p&gt;
&lt;p&gt;生活总会有许多意想不到的困难，我当然明白这一切，待再回头时不过是一
抹轻笑，并不能算得了多大的难处。只是假如硬要在浮华的世界中寻找清静，
却并不容易真的得到内心的安宁。&lt;/p&gt;
&lt;p&gt;大概每个人都需要一个哑巴辛格当朋友，他总用睿智的眼神告诉你他能理解
你所说，却从不言语。&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Fri 14 September 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/essaies/lonely.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="随笔"></category></entry><entry><title>都废</title><link href="http://www.roading.org//essaies/sadcity.html" rel="alternate"></link><updated>2012-04-26T14:31:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-04-26:/essaies/sadcity.html</id><summary type="html">&lt;p&gt;《废都》，便是迷醉于欲望之中，却又无法抽身自救的那么一群人组成。即便是尼姑庵的慧明亦脱不出肉欲
、权欲的高墙。大概世道如此，现实并不是人们掉进了欲望的天坑，反而是，欲望便如已然合围的高墙，人生而就在墙内。不是陷入了，而是逃不出。&lt;/p&gt;
&lt;p&gt;便如《废都》演变到最后，这些人或死了、又或走了。死了的人固然逃出了欲望的樊笼，走了的人却尚未完成自救。诚然、庄之蝶最终放弃了背负了的声名，好似看淡了一切，悄然踏上了驶往南方的火车。而实质却是截然相反的，他并没有逃脱那一切，因他没有做任何一丁点抗争，不过是走到了绝地后的另谋他路罢了。他与周敏最终坐上了同一辆离开西京的火车，离开西京并不是他们幡然醒悟了，而是他们都面临了同样的困境——在追逐欲望的过程中面临了难以挽回的局面。周敏费尽心机也没有保全他在杂志社的工作，而庄之蝶更是跌进了谷底，失去了一切。他们是在这样一种情况下离开的，无需割舍任何一点东西。所以他们今天或许离开了西京，但却保不准哪天要入了南京了。&lt;/p&gt;
&lt;p&gt;庄之蝶外头有那么多女人，却又未必真得了爱情。庄之蝶身材矮小，其貌不扬，要说他的那些女人们三下两次的便都和他上了床是爱情，我是不信的。与其说，她们是爱上了庄之蝶，不如说她们爱上的是“大作家庄之蝶”。反过来看呢，庄之蝶也不过仅是爱上了这些年轻美妙的肉体。阿灿的自毁容貌或许叫庄之蝶内疚与感动了，却也止步于此。唐婉儿最终的处境或许也叫庄之蝶煎熬难受了，不过是因为庄之蝶还有一颗良善之心罢了。我想庄之蝶与唐婉儿、柳月、阿灿之间是并没有一场爱情的，顶多也只是有很多场偷情。&lt;/p&gt;
&lt;p&gt;看罢《废都》，羡慕完庄之蝶的艳福之后、我又对他非常不耻。不耻周敏对他执师之礼，他却上了人家有实无名的老婆？不耻他间接害死了朋友龚靖元。不耻他亏待了赵京五…&lt;/p&gt;
&lt;p&gt;我始终不能明白，庄之蝶是有一颗良善之心的，又为何总做出上述不耻之事?末了，我却明白了，世道如此啊。这威武圣朝，现世亿万民众，或达官显贵，或平民布衣，莫不在这万丈红尘中翻滚，莫不为利欲如此行事。便拿害死了龚靖元说事，乘龚靖元之危买得了他的收藏或许是不道义的。但你见同赵京五谋划这事的时候，赵京五有丝毫内疚？诓骗压价龚小乙的时候，赵京五有丝毫手软？赵京五不是魔头，实在是这种事情在这个时段在这个地方太过平常，所有局中人都为警觉到严重的后果而已。&lt;/p&gt;
&lt;p&gt;庄之蝶是坏人吗？不！我想庄之蝶是个好人，这世道能有一副热肠、能有一颗良心已经是殊为不易。&lt;/p&gt;
&lt;p&gt;临近文末，我仿佛听到了庄之蝶丈母娘的喋喋呓语：都废了、都废了、都废…&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Thu 26 April 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/essaies/sadcity.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="随笔"></category></entry><entry><title>文化太监</title><link href="http://www.roading.org//essaies/culture-eunuch.html" rel="alternate"></link><updated>2012-01-07T11:50:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-01-07:/essaies/culture-eunuch.html</id><summary type="html">&lt;p&gt;捡起《北回归线》脱落的最后一页看完，不免有一些默然。这没有什么值得奇怪的地方
，看过的很多书都曾有这样的感觉。但这一次却又有一点不一样，它更像是一种静默中
的歇斯底里。有一种不吐不快，吐了也不能畅快的无力。这他妈的发慌发堵的感觉。&lt;/p&gt;
&lt;p&gt;老实说，看之前我已经做好了领略它到底有多淫秽，多龌龊的打算。毕竟它原是一本西
方的禁书，毕竟它原是一本在一群精力旺盛的兵痞间传阅的黄书，它理当应该很黄色，
应该能让这群士兵在无人的角落都成为单手“炮兵”。一直到看完最后一个字，我才大呼
受骗，这哪可能被当做黄书。它不但不淫秽，简直很纯洁。后来我又醒悟过来，既然是
中文版，必然在出版之前已经完成“净身”。&lt;/p&gt;
&lt;p&gt;受儿时的各类古装局，特别是满清局毒害，使我有这样一个认识：向来执刀给人净身的
人需是太监。我不在意我这个认知是否正确，便如同我不关心出版《北回归线》中文版
的人民出版社是不是太监一般。让我在意的是，我在这其中得出的一个结论——有些东西
，便如同男人裆下那玩意，即便它有多令人恶心、淫秽、邪恶…它依然是那么重要，缺之
不可。展现一副裸体不应该是什么禁忌，将一副男性裸体断根或女性裸体切除乳房才有
违人道。我猜测《北回归线》在中国便受到了如此酷刑。&lt;/p&gt;
&lt;p&gt;《北回归线》是一具生疮流脓的裸体，出版者大概以为这样一个样子太过可怖，因此切
除了他狰狞的阳具，却不知如此一来更丑陋且显虚伪。&lt;/p&gt;
&lt;p&gt;我用支离破碎的时间，看完了这本情节凌乱的书。即使刚刚看完，我却不能将之前后串
联起来。但我能确信的是这确实是一本好书。这并不是一句人云亦云的恭维话，也不是
为了掩盖自己见识浅薄智力低微而闪烁其词的含糊语。看这本书的过程中，便似有一般
小锤悬于心脏之上，它不时就会在你的心房或心室敲打一下，让你不禁颤抖。&lt;/p&gt;
&lt;p&gt;我问自己要不要完整的反刍式的将这本书再看一遍？我想，算了吧。我深知，书中能体
味到的，远不啻如此。虽然我看到的不过皮毛，甚至不足十之一二，虽然这也确实是一
本值得一看的书。合上书本，我并不打算再看一遍了。一如书中所说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;他们所处的世界同每一个地方一样，发生的事情多半是屎尿垃圾，同任何一个垃圾桶
一样脏，只是他们能有幸盖上桶盖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个世界黑暗的角落太多，揭露丑陋、人性、黑暗的作品或作者更不胜枚举。但能点亮
希望光芒的呢？我明白我想要重读的不是展现黑暗的世界，不是冷漠的一瞥，不是感叹
绝望的挣扎。我想要反复阅读的是能道出希望之所在的作品。&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Sat 07 January 2012 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/essaies/culture-eunuch.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="随笔"></category><category term="北回归线"></category></entry><entry><title>又到离别时</title><link href="http://www.roading.org//essaies/leave.html" rel="alternate"></link><updated>2011-12-10T14:25:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-10:/essaies/leave.html</id><summary type="html">&lt;p&gt;前几天毕业后的工作已经决定下来，前两天《深度探索C++对象模型》的学习也已
经了结。手头事情忙得差不多的时候，一回头不禁感叹，又是一季离别，年后大学
也算结束了。当然，或许你是以拿到毕业证作为一段生涯的句点，那自然不是，这
只能说认知上有些差别。&lt;/p&gt;
&lt;p&gt;说到工作的事，首先要很谢谢熊哥的内荐，免了我舟车劳顿、颠沛奔波的辛苦。虽
然程序不少，但是能仅仅打几通电话、收发几封邮件、写两段代码来决定工作，比
之奔走求职确实是一件轻松太多的事情。我原来已经拿定主意年后南下找工作，不
过既然可以不用奔波，公司又让我满意，我自然安心下来。我虽然一开始就决定明
年才开始求职的行程，不过中途经不住各位同学都已经签约的诱惑。有去试过两家
公司，一家叫深信服，另一家叫龙通。毫无疑问，这是两次失败的经历。&lt;/p&gt;
&lt;p&gt;虽然两次失败的经历对我来说并没有太多的遗憾，但是还是收获有一些经验。深信
服是在笔试的时候被刷的，本来笔试被刷，没有什么可谈，无非自己实力欠缺。但
我却犯了一些天真的错误。其一是笔试迟到了将近半个小时，不过考官还是让我们
进去了，虽然最后时间不缺，但显然对它缺乏重视——实际上我本来不打算参加笔试
的。其二在于，我天真的不把它当一场考试，选择题部分，我甚至没有在显眼的地
方写上我的答案，仅仅在每个错误的选项旁边，写下四五个字的注释，诸如此类随
意的做法，我也不记得试卷上有多少，何况深信服的题量之大，足有十页。考完之
后，我还颇有自信，甚至坚持在熊哥和旺X那里过夜，等待面试通知。&lt;/p&gt;
&lt;p&gt;如果说深信服得到了一些教训的话，龙通的那次面试则是纯粹浪费时间了，通过笔
试后，大概是第四天去长沙参加了龙通的面试，面试我的是两个小伙，估计比我大
不了几岁，和其中一个胖点的相谈甚欢(应该是人力，我却一直和他讲技术)，到另
外一个瘦点的来面具体技术的时候，却把我镇住了——居然边上网找题目，边问我。
问的问题很简单，但我都很慎重的作答。我自信对他所问，都有把握——除了其中两
个。一个为函数指针的使用问题，他问我函数指针使用时需不需要解引用，我答他
可以不用，当我刚开口要说一说为什么可以用也可以不用时。他似乎一副不必改口
的样子，直接告诉我进入下一题，我自然没有抢白解释。另一个问题，他问我用过
什么样的进程间通信方式，我答他我只用过套接字。他又问我进程通信有几种方式
，这题我当时没答上。其实最让人不能接受的问题在于，当我说出期望薪资是5k
的时候，我明显看到那两小子有点轻笑的味道，好像在说我不知天高地厚。姑且不
论5k的薪水到底是多是少，要知道他们宣讲的时候说的待遇是4.8k-6.8k，我说5k
绝对合理，当然后来在网上查了下龙通签人的薪水，估计他们宣讲时的薪水含有不
少水分。后来又问我转不转java，去不去南京，我都表示不会考虑。&lt;/p&gt;
&lt;p&gt;起笔之时，并没有打算讲求职琐事，写到此处，才发觉占了大量篇幅，气氛全无…&lt;/p&gt;
&lt;p&gt;当跑题跑了数公里之外的时候，我们再校正回来。&lt;/p&gt;
&lt;h3&gt;再续离别时&lt;/h3&gt;
&lt;p&gt;散席时，总不必表现的太过伤感，再尽兴的聚会，也总有离席散客之时，但倘若缘
分尚在，情分依旧，欢聚重逢，把酒高欢的时刻总不会少。&lt;/p&gt;
&lt;p&gt;我本来打算想营造点伤感的气氛，但无赖虽然可以预见有一份离别的伤感，但毕竟
这份伤感却还未到来，谁叫我这人只能提前享受快乐，却无法预支悲伤。更何况，
最近这几个月我又过的太过恰意，一段手上有几本欲罢不能的好书，脚下经常能踢
几场酣畅淋漓的爽球，偶尔还可以把酒高歌，有时亦可以静坐垂钓，更甚至，明天
凌晨五点的世纪大战，细哥还会电话叫我起床看球。这样的生活，又哪能期待更多。&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Sat 10 December 2011 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/essaies/leave.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="随笔"></category></entry><entry><title>《深度探索C++对象模型》笔记汇总</title><link href="http://www.roading.org//develop/cpp/%e3%80%8a%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b%e3%80%8b%e7%ac%94%e8%ae%b0%e6%b1%87%e6%80%bb.html" rel="alternate"></link><updated>2011-12-09T22:03:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-09:/develop/cpp/%e3%80%8a%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b%e3%80%8b%e7%ac%94%e8%ae%b0%e6%b1%87%e6%80%bb.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E6%80%BB%E7%BB%93%E4%BA%A6%E4%B8%BA%E5%BC%95%E8%A8%80.html"&gt;01. 总结——亦为引言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第1章 关于对象(Object Lessons)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E5%AF%B9%E8%B1%A1%E9%9D%A2%E9%9D%A2%E8%A7%82.html"&gt;02. C++对象面面观&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第2章 构造函数语意学(The Semantics of constructors)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%B7%B1%E5%85%A5c%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.html"&gt;03. 深入C++构造函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88copy-constuctor%EF%BC%89.html"&gt;04. 拷贝构造函数(Copy Constructor)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96%E5%92%8C%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97.html"&gt;05. 命名返回值优化和成员初始化队列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第3章 Data语意学（The Semantics of Data）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F.html"&gt;06. C++类对象的大小&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/vc%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%87%86%E5%88%99%EF%BC%88memory-alignment%EF%BC%89.html"&gt;07. VC内存对齐准则（Memory alignment）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98.html"&gt;08. C++对象的数据成员&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第4章 Function语意学（The Semantics of Function）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E4%B9%8B%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.html"&gt;09. C++之成员函数调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/c%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0virtual-member-functions.html"&gt;10. C++之虚函数(Virtual Member Functions)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第5章 构造、解构、拷贝 语意学（Semantics of Construction，Destruction，and Copy）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E5%87%A0%E7%82%B9%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html"&gt;11. 几点类设计原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%9E%84%E9%80%A0%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E6%9E%90%E6%9E%84%E8%AF%AD%E6%84%8F%E5%AD%A6.html"&gt;12. 构造、复制、析构语意学&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第6章 执行期语意学（Runting Semantics）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/new-expression%E3%80%81operator-new-%E5%92%8C-placement-new%E4%B8%89%E4%B8%AA%E5%A6%9E%EF%BC%88new%EF%BC%89%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%881%EF%BC%89.html"&gt;13. new expression、operator new 和 placement new——三个“妞（new）”的故事（1）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/new-expression%E3%80%81operator-new-%E5%92%8C-placement-new%E4%B8%89%E4%B8%AA%E5%A6%9E%EF%BC%88new%EF%BC%89%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%882%EF%BC%89.html"&gt;14. new expression、operator new 和 placement new——三个“妞（new）”的故事（2）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/new-expression%E3%80%81operator-new-%E5%92%8C-placement-new%E4%B8%89%E4%B8%AA%E5%A6%9E%EF%BC%88new%EF%BC%89%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%883%EF%BC%89.html"&gt;15. new expression、operator new 和 placement new——三个“妞（new）”的故事（3）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84.html"&gt;16. 对象的构造和析构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E4%B8%B4%E6%97%B6%E6%80%A7%E5%AF%B9%E8%B1%A1temporary-objects.html"&gt;17. 临时性对象(Temporary Objects)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第7章 站在对象模型的类端（On the Cusp of the Object Model）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/%E6%A8%A1%E6%9D%BF%E4%BA%8C%E4%BA%8B.html"&gt;18. 模板二事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.roading.org/develop/cpp/eh-rtti.html"&gt;19. EH &amp;amp; RTTI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Fri 09 December 2011 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/cpp/%e3%80%8a%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b%e3%80%8b%e7%ac%94%e8%ae%b0%e6%b1%87%e6%80%bb.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="Inside The C++ Object Model"></category><category term="笔记"></category></entry><entry><title>总结·亦为引言</title><link href="http://www.roading.org//develop/cpp/%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b/%e6%80%bb%e7%bb%93%e4%ba%a6%e4%b8%ba%e5%bc%95%e8%a8%80.html" rel="alternate"></link><updated>2011-12-09T21:39:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-09:/develop/cpp/%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b/%e6%80%bb%e7%bb%93%e4%ba%a6%e4%b8%ba%e5%bc%95%e8%a8%80.html</id><summary type="html">&lt;p&gt;《深度探索C++对象模型》终于在昨天写完了最后一篇笔记，前前后后花费了一个
月左右，期间学到了很多，很感激书的作者和译者。之后的日子，可以将精力转
回《算法导论》和一些非技术类的书上来了。&lt;/p&gt;
&lt;p&gt;11月11号开始看《深度探索C++对象模型》一书，到二十八号看完，共计花费了十
八天。不过到做完全书的笔记则是昨天的事了。期间也算是反复阅读，中英文版本
对照，虽然不能说事深掘至微末，但也能算掌握了主络，倒是令我自己满意。&lt;/p&gt;
&lt;p&gt;期间花费的心力精神自不必说，但收获欢欣也实在不少。得益于 Lippman
的大师技艺，书中很多地方使我有拨云见日的豁然，一些原以为晦涩高超的技巧，
其真实面目暴力且直接。这本书不厚，但可以深掘的东西实在不少，以至于某些
时候，我不得不停下思路，以免难以自拔。&lt;/p&gt;
&lt;p&gt;当然，在这个行业来说，这本书毕竟有点“远古”，读这本书的时候，必须保持着
清晰的头脑，不能迷信作者和译者——虽然他们都是值得尊敬的人物。需要抱有怀
疑精神，更需要多动手编码验证一番。原书的疏漏笔误之处着实不少，这要多谢
译者侯捷一一指正。但或许正因为这个原因，无端膨胀了译者的自信，毕竟指点
一个大师的错误是一件如此刺激的事情。这无端膨胀的自信，同样带来了一些问
题——一些原本正确之处，被做了错误的更正。可见，于技术学习来说，谨慎谦虚，
何其重要。&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Fri 09 December 2011 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/cpp/%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b/%e6%80%bb%e7%bb%93%e4%ba%a6%e4%b8%ba%e5%bc%95%e8%a8%80.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="Inside The C++ Object Model"></category></entry><entry><title>EH &amp; RTTI</title><link href="http://www.roading.org//develop/cpp/eh-rtti.html" rel="alternate"></link><updated>2011-12-08T22:24:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-08:/develop/cpp/eh-rtti.html</id><summary type="html">&lt;h3&gt;异常处理(Exception Handling)&lt;/h3&gt;
&lt;p&gt;C++的 exception handling 有三个主要的子句组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个throw子句。它在程序的某处丢出一个exception，被丢出的exception可以是内建类
    型，也可以是自定义类型。——抛出exception组件。&lt;/li&gt;
&lt;li&gt;一个或多个 catch 子句。 每一个 catch 子句都是一个 exception handler。每个子句
    可以处理一种类型(也包括其继承类)的exception，在大括号中包含处理代码。——专治各
    种不服组件。每一个catch子句都可以用来处理某种exception。&lt;/li&gt;
&lt;li&gt;一个 try 区段。用大括号包围一系列语句，这些语句有可能抛出exception，从而引发
    catch 子句的作用。——逮捕各种 exception 组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当一个 exception 被抛出后，控制权从函数调用中被释放，寻找一个吻合的catch子句，如
果各层调用都没有吻合的catch子句，&lt;code&gt;terminate()&lt;/code&gt;将被调用。在控制权被放弃后，堆栈中
的每一个函数调用也被出栈，这个过程称为unwinding the stack(关于 stack unwinding ,
可以参考《C++ Primer》第四版之 17.1.2 Stack Unwinding)，在每一个函数被出栈之前,其
局部变量会被摧毁。&lt;/p&gt;
&lt;p&gt;异常抛出有可能带来一些问题，比方在一块内存的lock和unlock内存之间，或是在new和
delete之间的代码抛出了异常，那么将导致本该进行的unlock或delete操作不能进行。解决
方法之一是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt;  &lt;span class="nf"&gt;mumble&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arena&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
   &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="n"&gt;smLock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;arena&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
      &lt;span class="c1"&gt;// ...  &lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;  
   &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="n"&gt;smUnLock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;arena&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
      &lt;span class="n"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
      &lt;span class="n"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="p"&gt;}&lt;/span&gt;  
   &lt;span class="n"&gt;smUnLock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;arena&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
   &lt;span class="n"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在函数被出栈之前，先截住异常，在unlock和delete之后再将异常原样抛出。new expression
的调用不用包括在try块之内是因为，不论在new operator调用时还是构造函数调用时抛出异
常，都会在抛出异常之前释放已分配好的资源，所以不用再调用delete 。&lt;/p&gt;
&lt;p&gt;另一个办法是，将这些资源管理的问题，封装在一个类对象中，由析构函数释放资源，这样就
不需要对代码进行上面那样的处理——利用函数释放控制权之前会析构所有局部对象的原理。&lt;/p&gt;
&lt;p&gt;在对单个对象构造过程中抛出异常，会只调用已经构造好的base class object或member class
 object的析构函数。同样的道理，适用于数组身上，如果在调用构造函数过程中抛出异常，那
 么之前所有被构造好的元素的析构函数被调用，对于抛出异常的该元素，则遵循关于单个对象
 构造的原则，然后释放已经分配好的内存。&lt;/p&gt;
&lt;p&gt;只有在一个catch子句评估完毕并且知道它不会再抛出exception后，真正的exception object
才会被释放。关于 catch子句使用引用还是使用对象来捕获异常，省略。&lt;/p&gt;
&lt;h3&gt;执行期类型识别（Runtime Type Identification RTTI）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;RTTI 只支持多态类，也就是说没有定义虚函数是的类是不能进行 RTTI的。&lt;/li&gt;
&lt;li&gt;对指针进行&lt;code&gt;dynamic_cast&lt;/code&gt;失败会返回NULL ,而对引用的话，识别会抛出
    &lt;code&gt;bad_cast exception&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;typeid 可以返回&lt;code&gt;const type_info&amp;amp;&lt;/code&gt;，用以获取类型信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于1是因为RTTI的实现是通过vptr来获取存储在虚函数表中的&lt;code&gt;type_info*&lt;/code&gt; ，事实上为非多
态类提供RTTI,也没有多大意义。 2的原因在于指针可以被赋值为0，以表示 no object，但是
引用不行。关于3，虽然第一点指出RTTI只支持多态类，但&lt;code&gt;typeid&lt;/code&gt;和&lt;code&gt;type_info&lt;/code&gt;同样可用于
内建类型及所有非多态类。与多态类的差别在于，非多态类的&lt;code&gt;type_info&lt;/code&gt;对象是静态取得(所
以不能叫“执行期类型识别”)，而多态类的是在执行期获得。&lt;/p&gt;
&lt;p&gt;参考：深度探索C++对象模型&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Thu 08 December 2011 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/cpp/eh-rtti.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="EH"></category><category term="Inside The C++ Object Model"></category><category term="RTTI"></category></entry><entry><title>模板二事</title><link href="http://www.roading.org//develop/cpp/%e6%a8%a1%e6%9d%bf%e4%ba%8c%e4%ba%8b.html" rel="alternate"></link><updated>2011-12-07T17:00:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-07:/develop/cpp/%e6%a8%a1%e6%9d%bf%e4%ba%8c%e4%ba%8b.html</id><summary type="html">&lt;h3&gt;模板的实例化&lt;/h3&gt;
&lt;p&gt;一个模板只有被使用到，才会被实例化，否则不会被实例化。对于一个实例化
后的模板来说，未被调用的成员函数将不会被实例化，只有成员函数被使用时，
C++标准才要求实例化他们。其原因，有两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间和时间效率的考虑，如果模板类中有100个成员函数，对某个特定类型
    只有2个函数会被使用，针对另一个特定类型只会使用3个，那么如果将剩
    余的195个函数实例化将浪费大量的时间和空间。&lt;/li&gt;
&lt;li&gt;使模板有最大的适用性。并不是实例化出来的每个类型都支持所有模板的全
    部成员函数所需要的运算符。如果只实例化那些真正被使用的成员函数的话，
    那么原本在编译期有错误的类型也能够得到支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以明确的要求在一个文件中将整个类模板实例化：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nx"&gt;template&lt;/span&gt; &lt;span class="nb"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以显示指定实例化一个模板类的成员函数：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nx"&gt;template&lt;/span&gt; &lt;span class="nx"&gt;float&lt;/span&gt; &lt;span class="nx"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;X&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="nx"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或是针对一个模板函数：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nx"&gt;template&lt;/span&gt; &lt;span class="nx"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="nx"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Point3d&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;模板的错误报告，使用模板并遇到错误的大概都深有体会，那就是一个灾难。&lt;/p&gt;
&lt;h3&gt;模板的名称决议&lt;/h3&gt;
&lt;p&gt;一开始先要区分两种意义,一种是C++ 标准所谓的“scope of the template
definition”，直译就是“定义模板的范围”。另一种是C++标准所谓的“scope of 
the temlate instantiation”，可以直译为“实例化模板的范围”。&lt;/p&gt;
&lt;p&gt;第一种情况：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// scope of the template definition&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;ScopeRules&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
   &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;invariant&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="n"&gt;_member&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;_val&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
   &lt;span class="p"&gt;}&lt;/span&gt;

   &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;type_dependent&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;_member&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
   &lt;span class="p"&gt;}&lt;/span&gt;  
   &lt;span class="c1"&gt;// ...  &lt;/span&gt;
&lt;span class="nl"&gt;private:&lt;/span&gt;  
   &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;_val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;_member&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二种情况:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//scope of the template instantiation  &lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;// ...  &lt;/span&gt;
&lt;span class="n"&gt;ScopeRules&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sr0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;sr0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invariant&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;sr0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_dependent&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在“scope of the template instantiation ”中 两个foo()都声明在此 scope
中。猜猜sr0.invariant() 中调用的是哪个foo()函数，出乎意料，实际调用的
是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看上去，应该调用：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;毕竟，_val 的类型是 int 类型，它们才完全匹配。而 sr0.type_dependent()
中调用的却在我们意料之中，调用的是:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;诸上所述,看上去或合理或不合理的选择，原因在于:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;template 之中， 对于一个非成员名字的决议结果是根据这个 name
的使用是否与“用以实例化该模板的参数类型”有关来决定name。如果其使用互
不相干，那么就以“scope of the template dclaration”来决定name。如果其
使用的互相关联，那么就以“scope of the template
instantiation”来决定name.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于上面这一段话我的理解比较粗鲁且直接：在模板中，一个非成员名字的决议
在于它适不适合在当前决议，当它完全与实例化模板的参数的类型无关的时候，
就可以在当前决议下来；如果有关的话，则认为不适合在当前决议下来，将被推
迟到实例化这个模板实例化的时候来决议。为什么以与实例化的类型相关不相关
来区别适不适合当前决议？一个与实例化类型无关的名字，如果推迟到实例化的
时候来决议，将使模板的设计者无所适从，一个模板的设计者能容忍一个与实例
化类型无关的名字在他的模板中表现出当前不具有的含义吗？当然不行，那种场
面，估计没有一个模板设计者能够hold住。相反，对于一个与实例化类型有关的
名字，天生就应该可以根据实例化模板的不同类型表现出不同含义，如果其名字
早在模板定义时被决议出来，那就该轮到模板的使用者hold不住了。当然所上完
全属一家之言，呸，连一家之言都不算，怎么敢自称“家”。如有不同理解，可当
我一派胡言，如果你聊发善心，可以对我赐教一二，当聆听受教。&lt;/p&gt;
&lt;p&gt;参考：深度探索C++对象模型&lt;/p&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Wed 07 December 2011 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/cpp/%e6%a8%a1%e6%9d%bf%e4%ba%8c%e4%ba%8b.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="c++"></category><category term="Inside The C++ Object Model"></category><category term="template instantiation"></category></entry><entry><title>临时性对象(Temporary Objects)</title><link href="http://www.roading.org//develop/cpp/%e4%b8%b4%e6%97%b6%e6%80%a7%e5%af%b9%e8%b1%a1temporary-objects.html" rel="alternate"></link><updated>2011-12-06T17:48:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-12-06:/develop/cpp/%e4%b8%b4%e6%97%b6%e6%80%a7%e5%af%b9%e8%b1%a1temporary-objects.html</id><summary type="html">&lt;h3&gt;何时生成临时对象&lt;/h3&gt;
&lt;p&gt;对于一个下面这样的程序片段：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;死板一点来讲，它应当产生一个临时对象用来存储a+b的结果，然后以临时对
象作为初值调用拷贝构造函数初始化对象c。而实际上编译器更愿意直接调用
拷贝构造函数的方式将a+b的值放到c中，这样就不需要临时对象，和它的构造
函数和拷贝构造函数的调用了。&lt;/p&gt;
&lt;p&gt;更进一步，如果operator +的定义符合NRV优化的条件，那么NRV优化的开启，
将使得拷贝构造函数的调用和named object的析构函数都免了。期间详情可
以参见”&lt;a href="http://www.roading.org/?p=544"&gt;NRV优化&lt;/a&gt;”。也就是说对于上面那种情形在我们的代码中是不产生
临时对象的。但是对于一个情况非常类似的赋值操作语句&lt;code&gt;c = a+b&lt;/code&gt;，却有很
大的差别，那个临时变量是不能省的&lt;/p&gt;
&lt;p&gt;不能忽略临时对象，反而导致如下过程：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Pseudo C++ code  &lt;/span&gt;
&lt;span class="c1"&gt;// T temp = a + b;  &lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// @1 [^注1]&lt;/span&gt;

&lt;span class="c1"&gt;// c = temp  &lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// @2  &lt;/span&gt;
&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在代码@1处，表明以拷贝构造函数或NRV方式将结果保存的临时对象中。为什
么不能省略那个临时对象，比如直接这样：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这不是更高效，更简洁的方式吗？不行，其原因在于，拷贝构造函数、析构
函数以及赋值操作符都可以由使用者提供，没有人能保证，析构函数加拷贝
构造函数的组合和赋值操作符具有相同的含义。所以：&lt;code&gt;T c=a+b&lt;/code&gt;总是比
&lt;code&gt;c = a + b&lt;/code&gt;更有效率。&lt;/p&gt;
&lt;p&gt;对于一个没有出现目标对象的表达式&lt;code&gt;a + b&lt;/code&gt;,那么产生一个临时对象来存储
运算结果，则是非常必要的。&lt;/p&gt;
&lt;h3&gt;临时对象的生命周期&lt;/h3&gt;
&lt;p&gt;很多时候，产生临时对象是必不可少的，但是何时摧毁一个临时对象才是最
佳行为呢？过早或过晚都不太适合，过早有可能使得程序错误，过晚的话又
使得资源没有得到及时回收。对于下面的程序：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="nf"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;world &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;s3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;by Adoo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;s3&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;显然保存&lt;code&gt;s1+s2&lt;/code&gt;结果的临时对象，如果在与s3进行加法之前析构，将会带来
大麻烦。于是C++标准中有一条：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;临时性对象的摧毁应当作为造成产生这个临时对象的完整表达式的最后
一个步骤。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整的表达式，是指涵括的表达式中最外围的那个。我们再看上面那个字符
串相加的表达式，当计算完成，而cout还未调用，此时我们析构掉存储最终
结果的临时对象，岂不悲剧。其实上面的规定还有两个例外：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;凡含有表达式执行结果的临时性对象，应该保存到Object的初始化操作
    完成为止。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果临时性对象被绑定与一个引用，临时对象将残留，直至被初始化的
    引用的生命结束，或直到临时对象的生命周期结束——视哪一种情况先达
    到，对应于这种情况：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:注1"&gt;
&lt;p&gt;侯捷认为此处为 Lippman 的错误，他认为应该为
&lt;code&gt;temp.operator + ( a, b )&lt;/code&gt;但我以为是侯捷并没有理解Lippman的意思，回
顾一下,《深度探索对象模型》2.3讲到的返回值初始化(Return Value 
Initialization)——返回值将作为一个额外的参数提供给函数，来传回函数内
部的值，也就是说对于一个 operator + 操作符
&lt;code&gt;T T::operator+ (const T&amp;amp; right)&lt;/code&gt;将转化为
&lt;code&gt;void T::operator+ (T &amp;amp;result ,const T&amp;amp; right)&lt;/code&gt;所以&lt;code&gt;temp=a+b&lt;/code&gt;是
&lt;code&gt;a.operator+( temp, b )&lt;/code&gt;还是&lt;code&gt;temp.operator+( a, b )&lt;/code&gt;自然不言而喻。&amp;#160;&lt;a class="footnote-backref" href="#fnref:注1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
          &lt;p style= "text-align:right;"&gt;&lt;em&gt;
          Tue 06 December 2011 By &lt;a href="http://www.roading.org/pages/about-me.html"&gt;Adoo&lt;/a&gt;
          (&lt;a href = "http://www.roading.org/pages/message.html"&gt;Contact me&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
          &lt;p style="text-align:right;"&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
          (&lt;a href="http://www.roading.org/develop/cpp/%e4%b8%b4%e6%97%b6%e6%80%a7%e5%af%b9%e8%b1%a1temporary-objects.html"&gt;本文原链&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
        </summary><category term="c++"></category><category term="Inside The C++ Object Model"></category><category term="笔记"></category></entry></feed>