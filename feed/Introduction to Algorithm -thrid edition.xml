<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Adoo's blog</title><link href="http://www.roading.org/" rel="alternate"></link><link href="http://www.roading.org/feed/Introduction%20to%20Algorithm%20-thrid%20edition.xml" rel="self"></link><id>http://www.roading.org/</id><updated>2012-04-15T22:23:00+08:00</updated><entry><title>算法导论——B-trees</title><link href="http://www.roading.org//algorithm/introductiontoalgorithm/%e7%ae%97%e6%b3%95%e5%af%bc%e8%ae%bab-trees.html" rel="alternate"></link><updated>2012-04-15T22:23:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-04-15:/algorithm/introductiontoalgorithm/%e7%ae%97%e6%b3%95%e5%af%bc%e8%ae%bab-trees.html</id><summary type="html">&lt;p&gt;B-trees(叫“B树”还是“B-树”？我还是用它的英文名吧)，是一种为磁盘或其它辅存设备而设计的平衡树。它与红黑树有些类似，但是在节省IO操作上比红黑树表现的更好。很多数据库系统会用B-trees
或它的变形来存储信息。&lt;/p&gt;
&lt;p&gt;B-trees
的特点是，一个结点可以有n个关键字，这些关键字把一段数据划分成n+1段，对应n+1个孩子，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="0" src="http://www.roading.org/wp-content/uploads/2012/04/0.png" title="0" /&gt;&lt;/p&gt;
&lt;h3&gt;B-trees的定义&lt;/h3&gt;
&lt;p&gt;一棵 B-trees T具有如下属性(设其根结点为T.root):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Every node &lt;em&gt;x&lt;/em&gt; has the following fields:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;x.n&lt;/em&gt;, the number of keys currently stored in node &lt;em&gt;x&lt;/em&gt;,&lt;/li&gt;
&lt;li&gt;the x.n keys themselves, stored in nondecreasing order, so that
    x.&lt;em&gt;key&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; ≤ x.&lt;em&gt;key&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt; ≤ ··· ≤ &lt;em&gt;x.key&lt;sub&gt;x.n&lt;/sub&gt;.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;x.leaf&lt;/em&gt; , a boolean value that is TRUE if &lt;em&gt;x&lt;/em&gt; is a leaf and FALSE
    if &lt;em&gt;x&lt;/em&gt; is an internal node.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.Each internal node &lt;em&gt;x&lt;/em&gt; also contains &lt;em&gt;x.n+1&lt;/em&gt; pointers x.&lt;em&gt;c&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;,
x.&lt;em&gt;c&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;, ..., x.&lt;em&gt;c&lt;sub&gt;x.&lt;/sub&gt;&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;+1&lt;/sub&gt; to its children. Leaf nodes have no
children, so their &lt;em&gt;c&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt; fields are undefined.&lt;/p&gt;
&lt;p&gt;The keys x.&lt;em&gt;key&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt; separate the ranges of keys stored in each
subtree: if &lt;em&gt;k&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt; is any key stored in the subtree with root x.&lt;em&gt;c&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;
, then&lt;/p&gt;
&lt;p&gt;&lt;em&gt;k&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; ≤ x.&lt;em&gt;key&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;≤&lt;em&gt;k&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt; ≤x. &lt;em&gt;key&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt; ≤··· ≤x. &lt;em&gt;key&lt;sub&gt;x.&lt;/sub&gt;&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sub&gt; ≤
&lt;em&gt;k&lt;/em&gt;&lt;sub&gt;&lt;em&gt;x.n+1&lt;/em&gt;&lt;/sub&gt;.&lt;/p&gt;
&lt;p&gt;All leaves have the same depth, which is the tree's height &lt;em&gt;h&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;There are lower and upper bounds on the number of keys a node can
contain. These bounds can be expressed in terms of a fixed integer &lt;em&gt;t&lt;/em&gt;
≥ 2 called the &lt;strong&gt;&lt;em&gt;minimum degree&lt;/em&gt;&lt;/strong&gt; of the B-tree:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every node other than the root must have at least &lt;em&gt;t&lt;/em&gt; - 1 keys.
    Every internal node other than the root thus has at least &lt;em&gt;t&lt;/em&gt;
    children. If the tree is nonempty, the root must have at least one
    key.&lt;/li&gt;
&lt;li&gt;Every node can contain at most 2&lt;em&gt;t&lt;/em&gt; - 1 keys. Therefore, an
    internal node can have at most 2&lt;em&gt;t&lt;/em&gt; children. We say that a node
    is &lt;strong&gt;&lt;em&gt;full&lt;/em&gt;&lt;/strong&gt; if it contains exactly 2&lt;em&gt;t&lt;/em&gt; - 1 keys.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;创建一棵空&lt;em&gt;B-trees&lt;/em&gt;&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TREE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;CREATE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ALLOCATE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;NODE&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leaf&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; 0
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;/p&gt;

&lt;h3&gt;搜索操作:&lt;/h3&gt;
&lt;/p&gt;

&lt;p&gt;搜索操作与二叉搜索树的搜索有点类似，两点不同之处在于：一是结点中可能有多个key，二是往下走的时候有可能有多个子路。这些不同只在于选路的时候多做点判断罢了。下面为伪码：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TREE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;SEARCH&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt;1
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; ≤ &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyi&lt;/span&gt;
     &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; 1
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; ≤ &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyi&lt;/span&gt; 
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leaf&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;NIL&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TREE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;SEARCH&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;h3&gt;&lt;span style="font-family: georgia"&gt;插入操作&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;

&lt;p&gt;参照二叉搜索树的插入操作，其实B-trees
的整体插入思路也类似。但是要注意一点，如果要插入的目标结点已经满了(即关键字的数目为2t-1)，这个时候并不能直接插入，因为直接插入就会破坏B-trees
的结点性质。解决之道为，将这个已经满了的结点以其第t个关键字为界一分为二，并把第t个关键字抽取出来插入到父结点相应位置。并不能等到确定了要插入的目的结点再决定分不分裂，而是在下降的过程中遇到满结点就应当分裂，这样就可以保证要分裂的时候父结点总不是满的。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;分裂结点的伪码：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TREE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;SPLIT&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;CHILD&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ALLOCATE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;NODE&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt; 
    &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leaf&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leaf&lt;/span&gt;
    &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; 1
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nb"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; 1 &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; 1
          &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyj&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyj&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leaf&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nb"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; 1 &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;
             &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cj&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cj&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; 
    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; 1
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nb"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; 1 &lt;span class="n"&gt;downto&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; 1
          &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cj&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;1 &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cj&lt;/span&gt; 
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;1 &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nb"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;downto&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt;
         &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyj&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;1  &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyj&lt;/span&gt; 
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyi&lt;/span&gt;  &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyt&lt;/span&gt;     &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; 1
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;插入结点的伪码：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TREE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;INSERT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; 2&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; 1
          &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ALLOCATE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;NODE&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
          &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
          &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leaf&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;
          &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; 0
          &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;
          &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TREE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;SPLIT&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;CHILD&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 1&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TREE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;INSERT&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;NONFULL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TREE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;INSERT&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;NONFULL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;在非满根结点插入关键字的伪码(供上面B-Tree-INSERT 使用的一个辅助函数)：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TREE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;INSERT&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;NONFULL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;
 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leaf&lt;/span&gt;
     &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; ≥ 1 &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyi&lt;/span&gt;       
         &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyi&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;1 &lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyi&lt;/span&gt;   
         &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; 1
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyi&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;1 &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;1
 &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; ≥ 1 &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyi&lt;/span&gt;
            &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; 1
    &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; 1
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; 2&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; 1
        &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TREE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;SPLIT&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;CHILD&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keyi&lt;/span&gt; 
        &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; 1
    &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TREE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;INSERT&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;NONFULL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;h3&gt;删除操作&lt;/h3&gt;
&lt;/p&gt;

&lt;p&gt;删除操作要比插入操作更复杂一点，因为删除一个关键字的时候，这个关键字不但可以在叶子结点，也可以在内部结点。算法导论的叙述虽然很严密与细致,但却对解题思路的骨架并不突出。这一段笔记我试着抛开算导，完全按我自己的思路来组织，而不是被他牵着鼻子走。（稳妥起见，你应该同时参照原书）：&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;从&lt;em&gt;B-trees&lt;/em&gt;
中删除关键字&lt;em&gt;key&lt;/em&gt;无非两种情况，从一个叶子结点中删除或是从一个非叶子结点中删除。我很难想到一种好的办法可以直接删除一个非叶子结点中的关键字，又维持&lt;em&gt;B-trees&lt;/em&gt;的属性。转念一想，能否把从非叶子结点中删除转化为从一个叶子结点中删除呢？当然能的，既然是一棵树，如果我们把问题从其所在的结点转移到其子结点，那么问题最终总能转移到叶子结点上。在具体考虑如何把从非叶子结点中删除关键字转化为从叶子结点中删除关键字之前，我们先要论证一下从叶子结点中删除一个关键字是否足够简单。如果从叶子结点中删除一个关键字比从非叶子结点中删除一个关键字更加复杂，那么就得不偿失了。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;从叶子结点中删除一个关键字也可以分为两种情况:1.该叶子结点中的关键字的数目大于&lt;em&gt;t-1&lt;/em&gt;,此时可以直接进行删除;2.叶子结点中的关键字数目恰巧等于&lt;em&gt;t-1&lt;/em&gt;,这时直接删除会破坏&lt;em&gt;B-trees&lt;/em&gt;的属性，而且破坏之后再进行修正也看得出来不是容易事。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;到这里我们遇到了窘境，如果叶子结点中关键字的数目等于&lt;em&gt;t-1&lt;/em&gt;,那么从中删除一个关键字很复杂，那么如果我们避免这种情况出现呢？便如同进行插入操作时有意的为分裂结点的操作，避免出现其父结点是满的情况一样。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;span style="font-family: helvetica; color: #333333"&gt;到此为止，我们有了初步的算法模型骨架，分为三步：1.定位要删除的关键字所在的结点；2.将删除问题下降到叶子结点；3.从叶子结点直接删除关键字。再完善其具体细节就可以得到以下算法模型：&lt;/span&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;由根结点出发定位被删除关键字所在的结点，在整个下降过程中，应保证每一次下降的&lt;span style="color: #0080c0"&gt;目的结点&lt;/span&gt;的关键字的数目至少为&lt;em&gt;t&lt;/em&gt;(保证下降到叶子的时候&lt;em&gt;关键字&lt;/em&gt;的数目大于&lt;em&gt;t-1&lt;/em&gt;)。如果下降过程中遇到关键字的数目为&lt;em&gt;t-1&lt;/em&gt;的目的结点&lt;em&gt;x&lt;/em&gt;，那么可以具体如下做：&lt;/p&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果&lt;em&gt;x&lt;/em&gt;有一个相邻的兄弟&lt;em&gt;y&lt;/em&gt;且其关键字的数目大于&lt;em&gt;t-1，&lt;/em&gt;，那么可以从父结点下降一个合适的关键字给&lt;em&gt;ｘ&lt;/em&gt;，并从&lt;em&gt;y&lt;/em&gt;上升一个关键字给父结点，并妥善设置好相关孩子指针。&lt;/li&gt;
&lt;li&gt;如果&lt;em&gt;x&lt;/em&gt;的两个相邻的兄弟关键字的的数目都为&lt;em&gt;t-1&lt;/em&gt;，那么将&lt;em&gt;x&lt;/em&gt;与其任意一相邻的兄弟合并，并从父结点下降相关关键字到合并的结点中间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果&lt;em&gt;key&lt;/em&gt;所在的结点是内部结点，设该结点为&lt;em&gt;x&lt;/em&gt;，那么将问题下降到其子一级并保证第1点，递归处理其子一级。具体做法：&lt;/p&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若&lt;em&gt;key&lt;/em&gt;的前驱所在结点的最少有&lt;em&gt;t&lt;/em&gt;个关键字，那么可用其前驱替换掉key，问题就从删除key转变为删除&lt;em&gt;key&lt;/em&gt;的前驱，并且下降了一级。&lt;/li&gt;
&lt;li&gt;若&lt;em&gt;key&lt;/em&gt;的后继所在的结点最少有&lt;em&gt;t&lt;/em&gt;个关键字,那么同体可以用&lt;em&gt;key&lt;/em&gt;的后继替换&lt;em&gt;key&lt;/em&gt;，问题得到转换并下降一级。&lt;/li&gt;
&lt;li&gt;如果&lt;em&gt;key&lt;/em&gt;的前驱和后继所在的结点关键字数目都为&lt;em&gt;t-1&lt;/em&gt;,那么令&lt;em&gt;x&lt;/em&gt;合并这任意两个相邻的结点之一，并将&lt;em&gt;key&lt;/em&gt;降下来，作为中间关键字，问题也得到下降。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是叶子，直接删除。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/p&gt;

&lt;p&gt;参考：introduction to algorithm –third edition&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。&lt;/em&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2012/4/15 by Adoo | homepage:&lt;/em&gt;&lt;a href="http://www.roading.org/"&gt;&lt;em&gt;www.roading.org&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/p&gt;</summary><category term="B-trees"></category><category term="Introduction to algorithm"></category></entry><entry><title>算法导论——赫夫曼编码</title><link href="http://www.roading.org//algorithm/introductiontoalgorithm/%e7%ae%97%e6%b3%95%e5%af%bc%e8%ae%ba%e8%b5%ab%e5%a4%ab%e6%9b%bc%e7%bc%96%e7%a0%81.html" rel="alternate"></link><updated>2012-03-28T16:01:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-03-28:/algorithm/introductiontoalgorithm/%e7%ae%97%e6%b3%95%e5%af%bc%e8%ae%ba%e8%b5%ab%e5%a4%ab%e6%9b%bc%e7%bc%96%e7%a0%81.html</id><summary type="html">&lt;p&gt;赫夫曼编码(huffman
codes)是一种非常有用的数据压缩方法，通常能将数据压缩20%\~90%。从具体问题出发，假设我们有一包含10000个字符的文件，这些字符仅由6个不同的字符组成，就设这6个字符分别为“abcdef”，下面的表给出了这6个字符在整个文件中的占比，和两种不同的编码方式。&lt;/p&gt;
&lt;hr /&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;                         &lt;span class="n"&gt;a&lt;/span&gt;     &lt;span class="n"&gt;b&lt;/span&gt;     &lt;span class="n"&gt;c&lt;/span&gt;     &lt;span class="n"&gt;d&lt;/span&gt;     &lt;span class="n"&gt;e&lt;/span&gt;      &lt;span class="n"&gt;f&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Frequency (in thousands)   45    13    12    10    9      5
  Fixed-length codeword      000   001   010   011   100    101
  Variable-length codeword   0     101   100   111   1101   1100&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;/p&gt;
上例中固定长度的编码方式最少需要三位。那么整个文件的长度大小为300,000
bits，而对于可变长度的编码方式其使用大小为：&lt;/p&gt;
&lt;p&gt;(45 · 1 + 13 · 3 + 12 · 3 + 16 · 3 + 9 · 4 + 5 · 4) · 1,000 = 224,000
bits&lt;/p&gt;
&lt;p&gt;使用第二种编码方式能比第一种方式节约大约25%的空间。上述变长编码的方式实际上是一种名为&lt;strong&gt;前缀编码&lt;/strong&gt;的编码方式。&lt;/p&gt;
&lt;h3&gt;前缀编码&lt;/h3&gt;
&lt;p&gt;如果某种编码方案中，没有一个编码会是其它编码的前缀，则称这种编码方案为前缀编码。有一条已证明的结论，任何由字符编码技术所获得的最佳压缩数据，也可以由前缀编码来获得。&lt;/p&gt;
&lt;p&gt;前缀编码的编码很容易，只需将文件中的字符用对应的编码表示即可。解码也容易完成，因为其性质，可以直接从头至尾按编码与字符的对应关系翻译即可。&lt;/p&gt;
&lt;p&gt;在解码过程中，为了方便和提高效率，可以用一颗二叉树来提供帮助。在这棵二叉树中，0表示往左走，1表示往右走。字符则被放置在树的叶子上。所以从根节点到叶子的路径表示了该字符的编码。这样一颗树对于解码时很有帮助的。下图是上面的例子中的两种编码对应的二叉树：[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb22.png" title="image" /&gt;][]&lt;/p&gt;
&lt;h3&gt;赫夫曼编码&lt;/h3&gt;
&lt;p&gt;赫夫曼编码是指赫夫曼提供的一种构建最优前缀编码的方法。其方法是总选取权重最小的两个结点&lt;em&gt;x&lt;/em&gt;和&lt;em&gt;y&lt;/em&gt;合并成一个结点&lt;em&gt;z&lt;/em&gt;,并用&lt;em&gt;z&lt;/em&gt;代替它们，再从中选出两个权重最小的结点…如是反复。图解：[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image3_thumb.png" title="image" /&gt;][]&lt;/p&gt;
&lt;h3&gt;伪码:&lt;/h3&gt;
&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb24.png" title="image" /&gt;][]&lt;/p&gt;
&lt;h3&gt;赫夫曼编码的正确性&lt;/h3&gt;
&lt;p&gt;证明赫夫曼编码的正确性需证明贪心算法的两要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font face="Georgia"&gt;&lt;font color="#555555" size="2"&gt;具有最优子结构&lt;/font&gt;&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font face="Georgia"&gt;&lt;font color="#555555" size="2"&gt;贪心选择性质&lt;/font&gt;&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ps:&lt;font face="楷体"&gt;本来按照之前些笔记的思路该记下证明过程的。但今天就不写了，我免不了要吐槽几句。一直以来，我是很不喜欢也很少做笔记的，我更愿意的方式是在书旁边的空白处写点理解感想之类的，潦潦草草，信手涂鸦。大一大二的时候因为看技术方面的书籍多是从图书馆借来。特别是《C++
primer》
这本书，被我借了两年，期间续借了又续借。刚开始看书的时候，是很期待从上面看到点什么前辈心得的，当然上面除了很少处的一两段短线之外，并没有什么其它前辈手迹。我有这种心理，因此遗憾之余也并没有介意在书上留下点东西。期间我涂涂画画写了不少东西，起初我不以为意，但后来还了书后，这本书恰巧又被我的同学ZWL借去。我从他手中偶然看到这本书，又随手翻了翻我以前写在其中的小记，个中有不少错误之处，有的是因为笔误，有的是因为刚开始看时理解的浅薄，这令我无比汗颜。我于是想最好还是不要在借来的书上乱写。到不是为了爱惜书籍，虽然，太多人很高尚的认为不要在图书馆中借来的书上写画，但我仍固执的以为，书被翻烂了写烂了才最能体现它的价值。我所顾忌的一是恐误了后来人，二是那些心得，虽然写了，却再难翻看了。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="楷体"&gt;再到后来会偶尔用本子记下一点心得，但确实麻烦难了。因为我看书一直以来的习惯决定了，那些个笔记心得难成体系，太随意了，太散了。如果不是附在原文旁边，我自己翻看，也没觉得有多大用处。另外一点在于，我向来对于笔记本这些东西保存不善，指不定哪天丢了，或撕了——我喜欢用质量差的作业本写字，那些漂亮的笔记本反而让我写不习惯，因此我的笔记本和作业本还有草稿本完全是一路货色。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="楷体"&gt;到看算法导论的时候，我开始萌生了要系统记一记笔记的想法。
我原来写这个笔记的初衷在于，一是要囊括要点，二是能写一些书本之外的理解，更重要的是我想这些笔记能够简明易懂，使我以后不用频频翻看原书。不过发现自己的水平也就能勉强读懂这本书，原来的目的自然只达到了十之一二。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="楷体"&gt;这本书的笔记我还是会将它写完，但有些无谓的地方将不会多浪费笔墨。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="楷体"&gt;每个人都有自己的做事原则，我的原则是做一件事，要有一个明确的理由，放弃一件在做的事也要有一个明确的理由。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2010/3/28 by Adoo | homepage: &lt;a href="http://www.roading.org/"&gt;www.roading.org&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb22.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/03/image22.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image3_thumb.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/03/image31.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb24.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/03/image24.png&lt;/p&gt;</summary><category term="greedy algorithm"></category><category term="huffman codes"></category></entry><entry><title>算法导论——贪心算法</title><link href="http://www.roading.org//algorithm/introductiontoalgorithm/%e7%ae%97%e6%b3%95%e5%af%bc%e8%ae%ba%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95.html" rel="alternate"></link><updated>2012-03-27T16:46:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-03-27:/algorithm/introductiontoalgorithm/%e7%ae%97%e6%b3%95%e5%af%bc%e8%ae%ba%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95.html</id><summary type="html">&lt;p&gt;与动态规划相同贪心算法通过做出一系列选择来构建出问题的最优解，不同的是贪心算法并不会全局考虑各种选择，它只做当前看起来最佳的选择。如君所见，贪心算法企图用每一步的最优解来构建出整个问题的最优解。这并不能保证总能构建出最优解，但它通常能做到。我们可以先看一个具体的问题——活动安排问题。&lt;/p&gt;
&lt;h3&gt;活动安排问题&lt;/h3&gt;
&lt;p&gt;有一系列活动&lt;em&gt;S&lt;/em&gt; = {&lt;em&gt;a&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;em&gt;a&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;, ...,
&lt;em&gt;a&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt;}，它们都要用到同一个舞台，而舞台一次只能举办一个活动。那么要如何安排才能举办最多的活动呢？&lt;/p&gt;
&lt;p&gt;假设活动&lt;em&gt;a&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt; 的开始时间用&lt;em&gt;s&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt; 表示，结束时间用&lt;em&gt;f&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;表示, 有 0 ≤
&lt;em&gt;s&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt; &amp;lt; &lt;em&gt;f&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt; &amp;lt; ∞. 也就是说&lt;em&gt;a&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt; 占用舞台的时间段为[&lt;em&gt;s&lt;sub&gt;i&lt;/sub&gt;,
f&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;).那么安排的活动之间必须满足一个条件，那就是各自的时间段之间没有重叠的部分。&lt;/p&gt;
&lt;p&gt;一个具体的例子（将这些活动按结束时间排好了序）：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;i&lt;/em&gt;      1   2   3   4   5   6   7    8    9    10   11
  &lt;em&gt;s&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;   1   3   0   5   3   5   6    8    8    2    12
  &lt;em&gt;f&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;   4   5   6   7   9   9   10   11   12   14   16&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;/p&gt;
对于这样一个问题，因为能够比较快速的发现其最优子结构，我们会很容易想到用动态规划来解决。——假设&lt;em&gt;a&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;是最优解中的一个元素，那么以&lt;em&gt;a&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;为界可以将问题分成为两个子问题，一个是活动结束时间在&lt;em&gt;a&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;的开始时间之前的所有活动，另一个则是活动开始时间在&lt;em&gt;a&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;结束时间之后的所有活动。可以证明最优解包含这两个子问题的最优解组成的，具体证明可见原书。&lt;/p&gt;
&lt;p&gt;令&lt;em&gt;S&lt;sub&gt;ij&lt;/sub&gt;&lt;/em&gt;代表活动开始时间在&lt;em&gt;a&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;
结束之后而活动结束时间在&lt;em&gt;a&lt;sub&gt;j&lt;/sub&gt;&lt;/em&gt;开始之前的所有活动的集合，用&lt;em&gt;c&lt;/em&gt;[&lt;em&gt;i, j&lt;/em&gt; ]
来代表的&lt;em&gt;Sij&lt;/em&gt;的最优解，那么我们可以获得递归公式：&lt;/p&gt;
&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb18.png" title="image" /&gt;][]&lt;/p&gt;
&lt;p&gt;如果用贪心算法的话，则不用考虑那么多种选择，只需考虑贪心选择——当前最佳的选择。在这个问题上，我们可以总是优先安排结束时间最早而又不与之前安排的任务有冲突的活动，这即是一种贪心选择。但最大的问题在于贪心选择是否是最佳选择？在这里，确实是的，你可以用算导中提到的“粘贴替代”的方法轻易的证明。&lt;/p&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;迭代与递归两种版本的伪码&lt;/h4&gt;
&lt;p&gt;递归版：[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb19.png" title="image" /&gt;][]&lt;/p&gt;
&lt;p&gt;迭代版：&lt;/p&gt;
&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb20.png" title="image" /&gt;][]&lt;/p&gt;
&lt;h4&gt;C++的实现&lt;/h4&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Container&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;greedy_activity_selector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Container&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Container&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;//*&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt; 应当是一个容器，每个元素为一个&lt;span class="n"&gt;pair&lt;/span&gt;对，
    &lt;span class="o"&gt;//*&lt;/span&gt;每个&lt;span class="n"&gt;pair&lt;/span&gt;对包含一个活动的开始时间和结束时间
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                    &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; 存储贪心选择；
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;!&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;h3&gt;贪心算法的基本内容&lt;/h3&gt;
&lt;/p&gt;

&lt;p&gt;贪心算法并不能解决所有最优解问题。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;贪心选择性质(greedy-choice property )和最优子结构(optimal
substructure)是贪心算法的两个关键点。如果一个问题具备以上两种属性，那么就能设计出适合这个问题的贪心算法。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;greedy-choice property&lt;/em&gt;&lt;/strong&gt;: we can assemble a globally optimal
solution by making a locally optimal (greedy) choice. In other words,
when we are considering which choice to make, we make the choice that
looks best in the current problem, without considering results from
subproblems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;

&lt;h4&gt;&lt;a name="IDX-381"&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;/p&gt;

&lt;h4&gt;贪心策略VS动态规划&lt;/h4&gt;
&lt;/p&gt;

&lt;p&gt;就动态规划来说，我们在每一步做出选择，但是这些选择往往会依赖与子问题的解。而贪心算法，总是做出当前看似最佳的选择，它可能会依赖于之前做过的选择，但绝不会依赖于尚未做出的选择或者子问题。一次动态规划通常采用自下而上的方式，不断解决小问题以供大问题使用，而贪心算法则采用自顶而下的方式不断缩小问题的规模。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;一般来讲，对于一个有贪心策略解法的问题，也常常有一个更复杂的动态规划解法。也由于动态规划和贪心策略都利用了最优子结构这一性质，往往容易在贪心算法足以解决问题的情况小使用了动态规划。或者在需要动态规划解决的地方使用贪心策略，这需要我们自行甄别。&lt;/p&gt;
&lt;/p&gt;

&lt;h4&gt;0-1背包和部分背包问题&lt;/h4&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;strong&gt;&lt;em&gt;0-1 knapsack problem&lt;/em&gt;&lt;/strong&gt; is the following. A thief robbing a
store finds &lt;em&gt;n&lt;/em&gt; items; the &lt;em&gt;i&lt;/em&gt;th item is worth &lt;em&gt;v&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt; dollars and
weighs &lt;em&gt;w&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt; pounds, where &lt;em&gt;v&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;w&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt; are integers. He wants
to take as valuable a load as possible, but he can carry at most &lt;em&gt;W&lt;/em&gt;
pounds in his knapsack for some integer &lt;em&gt;W&lt;/em&gt;. Which items should he
take? (This is called the 0-1 knapsack problem because each item must
either be taken or left behind; the thief cannot take a fractional
amount of an item or take an item more than once.)&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;In the &lt;strong&gt;&lt;em&gt;fractional knapsack problem&lt;/em&gt;&lt;/strong&gt;, the setup is the same, but
the thief can take fractions of items, rather than having to make a
binary (0-1) choice for each item. You can think of an item in the 0-1
knapsack problem as being like a gold ingot, while an item in the
fractional knapsack problem is more like gold dust.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;

&lt;p&gt;两个背包问题都有最优子结构，但0-1背包不能用贪心策略来解决，而部分背包可以。对于部分背包来说，因为可以只拿部分，所以不用考虑背包会不会不能塞满，所以总是先拿剩余物品中每镑最值钱的东西会导致全局最优解。而0-1背包则不然，因为物体不能只拿部分，所以可能会导致背包不能完全被利用。下图为一个实例。[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb21.png" title="image" /&gt;][]&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图解： The greedy strategy does not work for the 0-1 knapsack problem.
&lt;em&gt;(a)&lt;/em&gt; The thief must select a subset of the three items shown whose
weight must not exceed 50 pounds. &lt;em&gt;(b)&lt;/em&gt; The optimal subset includes
items 2 and 3. Any solution with item 1 is suboptimal, even though
item 1 has the greatest value per pound. &lt;em&gt;(c)&lt;/em&gt; For the fractional
knapsack problem, taking the items in order of greatest value per
pound yields an optimal solution.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;

&lt;p&gt;0-1背包不能用贪心策略来求解，但动态规划确实使用它的。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;参考： introduction to algorithm –third edition&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。&lt;/em&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2010/3/27 by Adoo | homepage: &lt;a href="http://www.roading.org/"&gt;www.roading.org&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb18.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/03/image18.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb19.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/03/image19.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb20.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/03/image20.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb21.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/03/image21.png&lt;/p&gt;</summary><category term="c++"></category><category term="greedy algorithm"></category><category term="Introduction to algorithm"></category></entry><entry><title>最优二叉查找树</title><link href="http://www.roading.org//algorithm/introductiontoalgorithm/%e6%9c%80%e4%bc%98%e5%84%bf%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91.html" rel="alternate"></link><updated>2012-03-26T11:56:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-03-26:/algorithm/introductiontoalgorithm/%e6%9c%80%e4%bc%98%e5%84%bf%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91.html</id><summary type="html">&lt;p&gt;假如我们要设计一个简单的程序将一段英文翻译成法语，那么就需要为每个英语单词找到对应的法语单词，简单的做法是在单词库中对每个单词进行遍历查找。更快一点的做法是，我们可以将单词库建成一颗平衡二叉搜索树——用英文单词做Key,对应的法语单词做附属信息。第二种方法，虽然可以保证每个单词的查询时间控制在
O(lgn),不过却也有不合理之处。由于单词出现的频率有高有低，于是一些常用单词离根节点很远，而一些很生僻的单词却在根节点附近。可见用一颗平衡二叉搜索树来做这个问题并不是非常高效，在这儿就引出了另一种二叉查找树——最优二叉查找树。&lt;/p&gt;
&lt;h3&gt;问题定义&lt;/h3&gt;
&lt;p&gt;假设给定一组有序的序列 &lt;em&gt;K&lt;/em&gt; = 〈&lt;em&gt;k&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;k&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;, ...,
&lt;em&gt;k&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt;〉，在查找的过程中被查找的键是&lt;em&gt;k&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;的概率是&lt;em&gt;p&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;
。同时因为有一些单词是
&lt;em&gt;K&lt;/em&gt;中不存在的,因此我们用n+1个虚拟键来表示这些不存在于&lt;em&gt;K&lt;/em&gt;中的键，分别为&lt;em&gt;d&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;,
&lt;em&gt;d&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;em&gt;d&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;, ..., &lt;em&gt;d&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt; 。其中 &lt;em&gt;d&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt;代表所有比 &lt;em&gt;k&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;小的键, &lt;em&gt;d&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt;
表示 所有比&lt;em&gt;k&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt;大的键,对于 &lt;em&gt;i&lt;/em&gt; = 1, 2, ..., &lt;em&gt;n&lt;/em&gt; -1, 虚拟键&lt;em&gt;d&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;
表示所有位于 &lt;em&gt;k&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt; 和&lt;em&gt;k&lt;sub&gt;i+1&lt;/sub&gt;&lt;/em&gt;之间的键。对于每一个&lt;em&gt;d&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;,
我们有一个概率&lt;em&gt;q&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;对于每次搜索，非成功，即失败，所以有：&lt;/p&gt;
&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb13.png" title="image" /&gt;][]&lt;/p&gt;
&lt;p&gt;因为对于每个关键字和虚拟键的概率都是已知的，所以我们可以求出一颗二叉搜索树的期望值：[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb14.png" title="image" /&gt;][]&lt;/p&gt;
&lt;p&gt;depth&lt;sub&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sub&gt;
代表结点在树种的深度。而我们的目标就是要建立起一颗搜索期望值最小的二叉树——也就是最优二叉搜索树。&lt;/p&gt;
&lt;h3&gt;动态规划的解法&lt;/h3&gt;
&lt;p&gt;很显然，假如k&lt;sub&gt;i&lt;/sub&gt;是最优二叉搜索树的根节点，那么它的左子树和右子树必然是最优二叉搜索树。由此可见，这个问题拥有最优子结构。&lt;/p&gt;
&lt;p&gt;要注意到，当一棵树成为另一棵树的子树的时候，由于每个结点的深度增加了1，所以搜索期望代价增加量为所有结点的概率总和：[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb15.png" title="image" /&gt;][]&lt;/p&gt;
&lt;p&gt;所以对于一棵根结点为 &lt;em&gt;k&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; 包含有结点&lt;em&gt;k&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;, ...,
&lt;em&gt;k&lt;sub&gt;j&lt;/sub&gt;&lt;/em&gt;的最优二叉搜索树，我们有：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;e&lt;/em&gt;[&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt; ] = &lt;em&gt;p&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; + (&lt;em&gt;e&lt;/em&gt;[&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;r&lt;/em&gt; - 1] + &lt;em&gt;w&lt;/em&gt;(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;r&lt;/em&gt; - 1)) +
(&lt;em&gt;e&lt;/em&gt;[&lt;em&gt;r&lt;/em&gt; + 1, &lt;em&gt;j&lt;/em&gt;] + &lt;em&gt;w&lt;/em&gt;(&lt;em&gt;r&lt;/em&gt; + 1, &lt;em&gt;j&lt;/em&gt;)).&lt;/p&gt;
&lt;p&gt;注意到：&lt;em&gt;w&lt;/em&gt;(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;) = &lt;em&gt;w&lt;/em&gt;(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;r&lt;/em&gt; - 1) + &lt;em&gt;p&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; + &lt;em&gt;w&lt;/em&gt;(&lt;em&gt;r&lt;/em&gt; + 1,
&lt;em&gt;j&lt;/em&gt;)，所以：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;e&lt;/em&gt;[&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt; ] = &lt;em&gt;e&lt;/em&gt;[&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;r&lt;/em&gt; - 1] + &lt;em&gt;e&lt;/em&gt;[&lt;em&gt;r&lt;/em&gt; + 1, &lt;em&gt;j&lt;/em&gt;] + &lt;em&gt;w&lt;/em&gt;(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;如此一来，我们可以建立起递归式了：[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb16.png" title="image" /&gt;][]&lt;/p&gt;
&lt;p&gt;&lt;em&gt;e&lt;/em&gt;[&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt; ]
记录了最优二叉查找树中的期望搜索代价，为了可以建立起二叉搜索树的结构，我们需要一个&lt;em&gt;root&lt;/em&gt;[&lt;em&gt;i&lt;/em&gt;,
&lt;em&gt;j&lt;/em&gt; ]来记录根结点&lt;em&gt;k&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;的下标。&lt;/p&gt;
&lt;p&gt;在下面的伪码中，用表 &lt;em&gt;e&lt;/em&gt;[1 ‥ &lt;em&gt;n&lt;/em&gt; + 1, 0 ‥ &lt;em&gt;n&lt;/em&gt;]来存储&lt;em&gt;e&lt;/em&gt;[&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;]
。第一维需要到&lt;em&gt;n&lt;/em&gt; + 1 而不是 &lt;em&gt;n&lt;/em&gt; 因为有子树只包含虚拟键
&lt;em&gt;d&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt;，我们需要计算和存储 &lt;em&gt;e&lt;/em&gt;[&lt;em&gt;n&lt;/em&gt; + 1, &lt;em&gt;n&lt;/em&gt;].
第二维需要从0开始是因为有子树只包含虚拟键&lt;em&gt;d&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;,
我们需要计算和存储&lt;em&gt;e&lt;/em&gt;[1, 0]. 此外，除了用表&lt;em&gt;root&lt;/em&gt;[&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;
]来记录根结点&lt;em&gt;k&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;的下标外，我们还需要一个表&lt;em&gt;w&lt;/em&gt;[1 ‥ &lt;em&gt;n&lt;/em&gt; + 1, 0 ‥
&lt;em&gt;n&lt;/em&gt;]，来记录&lt;em&gt;w&lt;/em&gt;(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)以提高效率——这样就不必每次都从头计算&lt;em&gt;w&lt;/em&gt;(&lt;em&gt;i&lt;/em&gt;,
&lt;em&gt;j&lt;/em&gt;)了。对于 1 ≤ &lt;em&gt;i&lt;/em&gt; ≤ &lt;em&gt;n&lt;/em&gt;. 且 &lt;em&gt;j&lt;/em&gt; ≥ &lt;em&gt;i&lt;/em&gt;, 我们有：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;w&lt;/em&gt;(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;) = &lt;em&gt;w&lt;/em&gt;(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt; - 1) + &lt;em&gt;p&lt;sub&gt;j&lt;/sub&gt;&lt;/em&gt;+ &lt;em&gt;q&lt;sub&gt;j&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;伪码：[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb17.png" title="image" /&gt;][]&lt;/h4&gt;
&lt;h4&gt;C++的实现: &lt;span style="color: blue"&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;#include&amp;lt;numeric&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;#include&amp;quot;LSC.h&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;optimal_bst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;float&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;float&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;dob_array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;2&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;1&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;dob_array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;2&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;1&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;1&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; !&lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;2&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;1&lt;span class="p"&gt;]=&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;1&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;1&lt;span class="p"&gt;]=&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;1&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;1&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;!&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;1 &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;1&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; !&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;2&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;1&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]=&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;numeric_limits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]=&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;1&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;1&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; !&lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;1&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;1&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;1&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]){&lt;/span&gt;
                    &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]=&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;1&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;1&lt;span class="p"&gt;]=&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;1&lt;span class="p"&gt;][&lt;/span&gt;5&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;delete_dob_array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;2&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;delete_dob_array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;2&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;  &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;float&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;6&lt;span class="p"&gt;]={&lt;/span&gt;0&lt;span class="p"&gt;.&lt;/span&gt;05&lt;span class="p"&gt;,&lt;/span&gt; 0&lt;span class="p"&gt;.&lt;/span&gt;10&lt;span class="p"&gt;,&lt;/span&gt; 0&lt;span class="p"&gt;.&lt;/span&gt;05&lt;span class="p"&gt;,&lt;/span&gt; 0&lt;span class="p"&gt;.&lt;/span&gt;05&lt;span class="p"&gt;,&lt;/span&gt; 0&lt;span class="p"&gt;.&lt;/span&gt;05&lt;span class="p"&gt;,&lt;/span&gt; 0&lt;span class="p"&gt;.&lt;/span&gt;10&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;float&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;5&lt;span class="p"&gt;]={&lt;/span&gt;0&lt;span class="p"&gt;.&lt;/span&gt;15&lt;span class="p"&gt;,&lt;/span&gt; 0&lt;span class="p"&gt;.&lt;/span&gt;10&lt;span class="p"&gt;,&lt;/span&gt; 0&lt;span class="p"&gt;.&lt;/span&gt;05&lt;span class="p"&gt;,&lt;/span&gt; 0&lt;span class="p"&gt;.&lt;/span&gt;10&lt;span class="p"&gt;,&lt;/span&gt; 0&lt;span class="p"&gt;.&lt;/span&gt;20 &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;size&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;5&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;dob_array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;optimal_bst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;delete_dob_array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;上面用到的两个函数dob_array 和 delete_dob_array
是在前一篇笔记&lt;a href="http://www.roading.org/?p=865"&gt;最长公共子序列&lt;/a&gt;中实现的。
此外，我们可以定义一个函数来输出一下树的结构，也就是课后练习15.5-2：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;print_optimal_bst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;1&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;1&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&amp;quot;&lt;span class="n"&gt;k&lt;/span&gt;&amp;quot;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&amp;quot;&lt;span class="n"&gt;k&lt;/span&gt;&amp;quot;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&amp;quot;&lt;span class="s"&gt;&amp;#39;s lefe child is &amp;quot;;&lt;/span&gt;
&lt;span class="s"&gt;        if(r-1&amp;lt;i)&lt;/span&gt;
&lt;span class="s"&gt;            std::cout&amp;lt;&amp;lt;&amp;quot;d&amp;quot;&amp;lt;&amp;lt;r-1&amp;lt;&amp;lt;std::endl;&lt;/span&gt;
&lt;span class="s"&gt;        else&lt;/span&gt;
&lt;span class="s"&gt;            print_optimal_bst(root, i, r-1);    &lt;/span&gt;
&lt;span class="s"&gt;        std::cout&amp;lt;&amp;lt;&amp;quot;k&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="n"&gt;child&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &amp;quot;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;1&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&amp;quot;&lt;span class="n"&gt;d&lt;/span&gt;&amp;quot;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
             &lt;span class="n"&gt;print_optimal_bst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;1&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;&lt;em&gt;欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。&lt;/em&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2010/3/26 by Adoo | homepage:www.roading.org&lt;/em&gt;&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb13.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/03/image13.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb14.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/03/image14.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb15.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/03/image15.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb16.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/03/image16.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/03/image_thumb17.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/03/image17.png&lt;/p&gt;</summary><category term="c++"></category><category term="最优二叉搜索树"></category></entry><entry><title>最长单调子序列问题</title><link href="http://www.roading.org//algorithm/introductiontoalgorithm/%e6%9c%80%e9%95%bf%e5%8d%95%e8%b0%83%e5%ad%90%e5%ba%8f%e5%88%97%e9%97%ae%e9%a2%98.html" rel="alternate"></link><updated>2012-03-22T17:19:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-03-22:/algorithm/introductiontoalgorithm/%e6%9c%80%e9%95%bf%e5%8d%95%e8%b0%83%e5%ad%90%e5%ba%8f%e5%88%97%e9%97%ae%e9%a2%98.html</id><summary type="html">&lt;blockquote&gt;
&lt;h5&gt;Exercises 15.4-5&lt;/h5&gt;
&lt;p&gt;Give an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;)-time algorithm to find the longest monotonically
increasing subsequence of a sequence of &lt;em&gt;n&lt;/em&gt; numbers。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Let X is the sequence of the sequence of n numbers.&lt;/li&gt;
&lt;li&gt;Let Y is the sorted number of the sequence of that n numbers.&lt;/li&gt;
&lt;li&gt;Find the LCS of the X and Y.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color="#333333" face="Helvetica"&gt;这种解法的核心在于问题的转化。求一个序列的最长单调子序列，先由其排序得一个有序的序列。于是问题可以转化为求原序列和有序序列的&lt;a href="http://www.roading.org/?p=865"&gt;最长公共子序列&lt;/a&gt;。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color="#333333" face="Helvetica"&gt;一开始没想出来，网上搜到&lt;a href="http://ripcrixalis.blog.com/"&gt;Rip's
Infernal Majesty&lt;/a&gt;的博客，茅塞顿开。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color="#333333" face="Helvetica"&gt;算法导论接下来的一题要求用&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;
lg &lt;em&gt;n&lt;/em&gt;)-求出最长子序列.原题如下：&lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h5&gt;Exercises 15.4-6: ⋆&lt;/h5&gt;
&lt;p&gt;Give an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; lg &lt;em&gt;n&lt;/em&gt;)-time algorithm to find the longest
monotonically increasing sub-sequence of a sequence of &lt;em&gt;n&lt;/em&gt; numbers.
(&lt;em&gt;Hint:&lt;/em&gt; Observe that the last element of a candidate subsequence of
length &lt;em&gt;i&lt;/em&gt; is at least as large as the last element of a candidate
subsequence of length &lt;em&gt;i&lt;/em&gt; - 1. Maintain candidate subsequences by
linking them through the input sequence.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我头脑愚笨，加上今天确实有些头昏，有答案都没看懂，哎，贴出&lt;a href="http://ripcrixalis.blog.com/"&gt;Rip's Infernal
Majesty&lt;/a&gt;的答案，留待来日慢慢回味。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We can solve the longest increasing subsequence problem using only
arrays and binary search. It processes the sequence elements in order,
for each new X[i], maintaining a candidate sequence S by: &lt;br /&gt;
• if X[i] is larger than the last element in S, add X[i] into S. &lt;br /&gt;
• otherwise, find the smallest element that is larger than X[i], S[k]
&amp;lt; X[k] and X[i] ≤ S[k+1], replace S[k+1] with X[i]. &lt;br /&gt;
After finishing processing all n numbers, the length of S is is length
of LIS of X. &lt;br /&gt;
LIS(X, n) &lt;br /&gt;
1 L = 0 &lt;br /&gt;
2 for &lt;em&gt;i&lt;/em&gt; = 1, 2, … n &lt;br /&gt;
3 binary search for the largest positive &lt;em&gt;j&lt;/em&gt; ≤ L such that X[M[&lt;em&gt;j&lt;/em&gt;]] &amp;lt;
X[&lt;em&gt;i&lt;/em&gt;] (or set &lt;em&gt;j&lt;/em&gt; = 0 if no such value exists) &lt;br /&gt;
4 P[&lt;em&gt;i&lt;/em&gt;] = M[&lt;em&gt;j&lt;/em&gt;] &lt;br /&gt;
5 if &lt;em&gt;j&lt;/em&gt; == L or X[&lt;em&gt;i&lt;/em&gt;] &amp;lt; X[M[j+1]] &lt;br /&gt;
6 M[&lt;em&gt;j&lt;/em&gt;+1] = &lt;em&gt;i&lt;/em&gt; &lt;br /&gt;
7 L = max(L, &lt;em&gt;j&lt;/em&gt;+1) &lt;br /&gt;
The algorithm stores values in two arrays: &lt;br /&gt;
• M[&lt;em&gt;j&lt;/em&gt;] — stores the position &lt;em&gt;k&lt;/em&gt; of the smallest value X[&lt;em&gt;k&lt;/em&gt;] such
that there is an increasing subsequence of length &lt;em&gt;j&lt;/em&gt; ending at X[&lt;em&gt;k&lt;/em&gt;]
on the range &lt;em&gt;k&lt;/em&gt; ≤ &lt;em&gt;i&lt;/em&gt; (note we have &lt;em&gt;j&lt;/em&gt; ≤ &lt;em&gt;k&lt;/em&gt; ≤ &lt;em&gt;i&lt;/em&gt; here). &lt;br /&gt;
• P[&lt;em&gt;k&lt;/em&gt;] — stores the position of the predecessor of X[&lt;em&gt;k&lt;/em&gt;] in the
longest increasing subsequence ending at X[&lt;em&gt;k&lt;/em&gt;]. &lt;br /&gt;
L is the length of the longest increasing sequence. The actual longest
sequence can be found by backtracking through the P array: the last
item of the longest sequence is in X[M[L]], the second-to-last item is
in X[P[M[L]]], etc. Thus, the sequence has the form &lt;br /&gt;
…, X[P[P[M[L]]]], X[P[M[L]]], X[M[L]]. &lt;br /&gt;
Because the algorithm performs a single binary search per sequence
element, its total time can be expressed using as O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;问题来自算法导论，参考博客：&lt;a href="http://ripcrixalis.blog.com/"&gt;Rip's Infernal Majesty&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2010/3/22 by Adoo | homepage:www.roading.org&lt;/em&gt;&lt;/p&gt;
&lt;/p&gt;</summary><category term="LIS"></category></entry><entry><title>扩展数据结构</title><link href="http://www.roading.org//algorithm/introductiontoalgorithm/%e6%89%a9%e5%b1%95%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84.html" rel="alternate"></link><updated>2012-01-05T16:08:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-01-05:/algorithm/introductiontoalgorithm/%e6%89%a9%e5%b1%95%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84.html</id><summary type="html">&lt;p&gt;&lt;em&gt;&lt;font face="黑体"&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div&gt;
摘要：在一般的应用中，极少有可能要构建一种全新的数据结构，大部分情况下会使用一些已有的数据结构，或者已有的数据结构进行扩展，以使得其能支持特殊的功能。当然即便是扩展也需要做一些工作。

&lt;/div&gt;

&lt;div align="right"&gt;
欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。

&lt;/div&gt;

&lt;p&gt;&lt;/font&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div align="right"&gt;
*2012/1/5 By Adoo | Homepage:*[*www.roading.org*][]

&lt;div align="right"&gt;

* * * * *

&lt;/div&gt;

&lt;/div&gt;

&lt;h3&gt;动态顺序统计(Dynamic oder statistics)&lt;/h3&gt;
&lt;p&gt;关于顺序统计这个问题，在&lt;a href="http://www.roading.org/?p=350"&gt;《第九章 中位数和顺序统计量（Medians and Order
Statistic）》&lt;/a&gt;介绍了在&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;)时间内获取一组数据中第
&lt;em&gt;i&lt;/em&gt;小的数据。在算导第十四章介绍了另外一种方式来求第
&lt;em&gt;i&lt;/em&gt;小的数据，它的算法复杂度为&lt;em&gt;O&lt;/em&gt;(lg
&lt;em&gt;n&lt;/em&gt;)，但却要依赖于另外一种数据结构顺序统计树(order statistic tree)。&lt;/p&gt;
&lt;p&gt;顺序统计树，是从红黑树扩展而来。相较于红黑树，一个顺序统计树的结点&lt;em&gt;x，&lt;/em&gt;比一个红黑树的结点要多拥有一个字段
size 。size
为以&lt;em&gt;x&lt;/em&gt;为根结点的子树所包含的所有结点的数目(也包括x本身)。一棵顺序统计树如下图所示：[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/01/image_thumb2.png" title="image" /&gt;][]&lt;/p&gt;
&lt;p&gt;不难得出一条结论：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;font size="2"&gt; x.size=x.left.size+x.right.size+1&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一棵顺序统计树中，可以很轻便的求该树中第 &lt;em&gt;i&lt;/em&gt;小的结点：[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/01/image_thumb3.png" title="image" /&gt;][]&lt;/p&gt;
&lt;p&gt;如左侧伪码所示，先求出 x 结点的排位r,因 x
不小于其左子树的所有结点，所以r=x.left.size+1.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 r 等于 i 自不必说。&lt;/li&gt;
&lt;li&gt;若 r 大于 i ，说明所找的数，排在 x 之前，应从排在x之前的数中找第 i
    小的数。即，从x 的左子树中找第 i 小的数。&lt;/li&gt;
&lt;li&gt;若 r 小于 i ，则应该在比 r 大的数种找第 i-r 小的数，即在 x
    的右子树中找第 i-r 小的数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样也可以在&lt;em&gt;O&lt;/em&gt;(lg &lt;em&gt;n&lt;/em&gt;)的时间内求得指定结点的排位：[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/01/image_thumb4.png" title="image" /&gt;][]&lt;/p&gt;
&lt;p&gt;因为 size
记录的是以当前结点为根结点的子树所包含的所有结点的数目(也包括当前节点本身)，所以左侧伪码通过统计从x到根结点这条路径中本身为右孩子的结点本身以及它们的的左孩子的size
来求得x 的排位。&lt;/p&gt;
&lt;p&gt;顺序统计树以红黑树为基础进行扩展,所以红黑树的原有操作我们都可以继承下来。但是它增加了一个字段size,对于红黑树的删除和插入操作，我们不得不进行一些轻微的升级，以使得size字段总能记录正确的信息。关于红黑树的插入操作，我们可以分为两部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The first phase goes down the tree from the root, inserting the new
node as a child of an existing node. The second phase goes up the
tree, changing colors and ultimately performing rotations to maintain
the red-black properties.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于维持size字段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;in the first phase, we simply increment x.&lt;em&gt;size&lt;/em&gt; for each node &lt;em&gt;x&lt;/em&gt; on
the path traversed from the root down toward the leaves. The new node
added gets a &lt;em&gt;size&lt;/em&gt; of 1. The additional cost of maintaining the
&lt;em&gt;size&lt;/em&gt; fields is &lt;em&gt;O&lt;/em&gt;(lg &lt;em&gt;n&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;&lt;div&gt;
In the second phase, the only structural changes to the underlying
red-black tree are caused by rotations, of which there are at most
two. Moreover, a rotation is a local operation: only two nodes have
their &lt;em&gt;size&lt;/em&gt; fields invalidated. The link around which the rotation is
performed is incident on these two nodes. Referring to the code for
LEFT-ROTATE(&lt;em&gt;T&lt;/em&gt;, &lt;em&gt;x&lt;/em&gt;) in Section 13.2, we add the following lines:&lt;/p&gt;
&lt;p&gt;&lt;/div&gt;
&lt;div&gt;
12 y.&lt;em&gt;size&lt;/em&gt; = x. &lt;em&gt;size&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;/div&gt;
&lt;div&gt;
13 x.&lt;em&gt;size&lt;/em&gt; = x.left.&lt;em&gt;size&lt;/em&gt; + &lt;em&gt;x.right.size&lt;/em&gt; + 1&lt;/p&gt;
&lt;p&gt;&lt;/div&gt;
&lt;div&gt;
&lt;/div&gt;
The change to RIGHT-ROTATE is symmetric.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;近似的原理，我们可以用来在删除操作中维持size字段，此处略。&lt;/p&gt;
&lt;h3&gt;如何扩展数据结构&lt;/h3&gt;
&lt;p&gt;一般我们可以以下面四条规则作为指引来扩展一个数据结构：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;li&gt;
Choosing an underlying data structure
&lt;/li&gt;
&lt;li&gt;
Determining additional information to be maintained in the underlying
data structure.
&lt;/li&gt;
&lt;li&gt;
Verifying that the additional information can be maintained for the
basic modifying operations on the underlying data structure
&lt;/li&gt;
&lt;li&gt;
Developing new operations.
&lt;/li&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一句很好的话:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As with any prescriptive design method, you should not blindly follow
the steps in the order given.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;

&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/01/image_thumb2.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/01/image2.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/01/image_thumb3.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/01/image3.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/01/image_thumb4.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/01/image4.png&lt;/p&gt;</summary><category term="Introduction to algorithm"></category><category term="Order Statistic tree"></category></entry><entry><title>在没有父指针情况下的红黑树插入操作</title><link href="http://www.roading.org//algorithm/introductiontoalgorithm/%e5%9c%a8%e6%b2%a1%e6%9c%89%e7%88%b6%e6%8c%87%e9%92%88%e6%83%85%e5%86%b5%e4%b8%8b%e7%9a%84%e7%ba%a2%e9%bb%91%e6%a0%91%e6%8f%92%e5%85%a5%e6%93%8d%e4%bd%9c.html" rel="alternate"></link><updated>2012-01-02T20:38:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2012-01-02:/algorithm/introductiontoalgorithm/%e5%9c%a8%e6%b2%a1%e6%9c%89%e7%88%b6%e6%8c%87%e9%92%88%e6%83%85%e5%86%b5%e4%b8%8b%e7%9a%84%e7%ba%a2%e9%bb%91%e6%a0%91%e6%8f%92%e5%85%a5%e6%93%8d%e4%bd%9c.html</id><summary type="html">&lt;div&gt;
*&lt;font face="黑体"&gt;*

&lt;div&gt;
摘要：算导红黑树课后练习13.3-6，在没有父指针的情况下实现红黑树插入操作。

&lt;/div&gt;

&lt;div&gt;
同时学习之作难免浅薄，欢迎你与我交流探讨，若有错误疏漏之处，恳请指正。

&lt;/div&gt;

&lt;p&gt;&lt;/font&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;/div&gt;
&lt;div align="right"&gt;
&lt;em&gt;2011/12/31 By Adoo | Homepage:&lt;/em&gt;&lt;a href="http://www.roading.org"&gt;&lt;em&gt;www.roading.org&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;13.3-6 &lt;br /&gt;
Suggest how to implement RB-INSERT efﬁciently if the representation
for red-black trees includes no storage for parent pointers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Solution:&lt;/strong&gt;一个结点中没有父指针的红黑树与一个结点中有父指针的红黑树的差别在于，前者不能轻易回溯至其父节点。而对于插入操作的实现，又需要多次回溯父节点。如果能解决这个问题，问题将迎刃而解。对于插入操作的实现，我的方法是：用栈保存从根节点至插入结点路径中所有的结点。当然在恢复红黑属性的过程中要注意栈的维护，具体细节，看下面伪码：&lt;/p&gt;
&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/01/image_thumb.png" title="image" /&gt;][]&lt;/p&gt;
&lt;style type="text/css"&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;
.csharpcode, .csharpcode pre
{
    font-size: small;
    color: black;
    font-family: consolas, &amp;quot;Courier New&amp;quot;, courier, monospace;
    background-color: #ffffff;
    /*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
    background-color: #f4f4f4;
    width: 100%;
    margin: 0em;
}
.csharpcode .lnum { color: #606060; }&lt;/style&gt;

&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/01/image_thumb1.png" title="image" /&gt;][]&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/01/image_thumb.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/01/image.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2012/01/image_thumb1.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2012/01/image1.png&lt;/p&gt;</summary><category term="Introduction to algorithm"></category><category term="red black trees"></category></entry><entry><title>哈希表（Hash Tables）（2）</title><link href="http://www.roading.org//algorithm/introductiontoalgorithm/%e5%93%88%e5%b8%8c%e8%a1%a8%ef%bc%88hash-tables%ef%bc%89%ef%bc%882%ef%bc%89.html" rel="alternate"></link><updated>2011-11-09T15:59:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-11-09:/algorithm/introductiontoalgorithm/%e5%93%88%e5%b8%8c%e8%a1%a8%ef%bc%88hash-tables%ef%bc%89%ef%bc%882%ef%bc%89.html</id><summary type="html">&lt;p&gt;引文：&lt;/p&gt;
&lt;p&gt;本文参考&lt;em&gt;Introduction To Algorithm ——third
edition&lt;/em&gt;第十一章，置于文首，以表对作者敬意。主要介绍哈希表两种碰撞的解决方法——链表和开放地址法（Open
addressing），开放地址的三种探查方法——线性探查（Linear
probing）、二次探查（Quadratic probing）、双重哈希（Double
hashing），以及完全哈希(Perfect
hashing)。你可以将本文当做一篇算法导论的笔记，也可以将它当作Adoo对算法导论的理解加讲解。若你也在度算法导论或对算法有兴趣，欢迎交流。同时学习之作难免浅薄，恳请有识之士斧正。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2011/11/9 By Adoo | Homepage:&lt;/em&gt;&lt;a href="http://www.roading.org"&gt;&lt;em&gt;www.roading.org&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;解决碰撞&lt;/h2&gt;
&lt;p&gt;解决碰撞无非两种思路：使得一个位置能存储多个元素，此其一；不限定一个元素只能存储到一个位置，既然要去到地方挤不下，那便换个地方，此其二。下文给出对应两种思路将的两种方法。&lt;/p&gt;
&lt;h3&gt;用链表解决碰撞&lt;/h3&gt;
&lt;p&gt;既然要使得一个位置能存储多个元素，我们便将要存储到这一位置的多个元素串成链表，并存储链表头，是为链表解决碰撞法。如图：&lt;/p&gt;
&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/11/image_thumb1.png" title="image" /&gt;][]&lt;/p&gt;
&lt;p&gt;这个方法简单明了，但是效率方面可能要打折扣，如果碰巧诸君不走运，一组元素全哈希到了一个位置，全被放到一个链表中，查找的效率必然可怜（O(n)）。退一步，只要是哈希的不太平均，那么查找的效率也让人有些难受。&lt;/p&gt;
&lt;h3&gt;开放地址（Open addressing）解决碰撞&lt;/h3&gt;
&lt;p&gt;开放地址法意味着:所有的元素都被存储在哈希表中,没有链表,没有存储在哈希表之外的元素；更少的内存，更高的内存利用率——开放地址意味着填满哈希表，另外完全逃离了指针，意味着节省了一笔空间，要明白对于一个很大的哈希表来说，如果使用指针（链表）来解决碰撞，意味着存储指针的空间也非常可观；潜在有更快的查找速度，更少的碰撞的可能（当然这只是潜能）。&lt;/p&gt;
&lt;p&gt;实现开放地址的插入（叫存储更合适一些吧），首先要连续探查哈希表，直到找到一个为空的位置来放入要插入的数。可想而知这个探查的顺序我们不可能1,2,3,…
这样按顺序来探查，这样的话效率怎么可能高的起来，探查的顺序依赖于要插入的Key。把哈希函数扩展到多一个输入——h(key,n)。n表示第n次探查。于是可以有一个序列，来表示要插入的Key
k可以放入的位置的顺序：&lt;/p&gt;
&lt;p&gt;〈&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;k&lt;/em&gt;,0),&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;k&lt;/em&gt;,1), ..., &lt;em&gt;h&lt;/em&gt;(&lt;em&gt;k&lt;/em&gt;,&lt;em&gt;m&lt;/em&gt; - 1)〉 ——称之为探查序列。&lt;/p&gt;
&lt;p&gt;假如函数的选择得当,那么k有机会放到每一个位置，也就是说只要哈希表未满，就可以插入。看一下插入的伪代码：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;HASH&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;INSERT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
1  &lt;span class="nb"&gt;i&lt;/span&gt; ← 0
2  &lt;span class="n"&gt;repeat&lt;/span&gt; &lt;span class="nb"&gt;j&lt;/span&gt; ← &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
3         &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NIL&lt;/span&gt;
4            &lt;span class="n"&gt;then&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; ← &lt;span class="n"&gt;k&lt;/span&gt;
5                 &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;j&lt;/span&gt;
6            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; ← &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; 1
7   &lt;span class="n"&gt;until&lt;/span&gt; &lt;span class="nb"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
8 &lt;span class="n"&gt;error&lt;/span&gt; &amp;quot;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="n"&gt;overflow&lt;/span&gt;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;/p&gt;

&lt;p&gt;对于开放地址的查找，很显然按照其探查顺序去查找就可以，直到找到相等的key。伪代码：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;
    HASH-SEARCH(T, k)
    1  i ← 0
    2  repeat j ← h(k, i)
    3         if T[j] = k
    4            then return j
    5         i ← i + 1
    6    until T[j] = NIL or i = m
    7  return NIL&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;需要注意的是，对于一个开放地址的哈希表，如果要从中删除一个元素，我们不能简单地将存放该元素的位置设置为NIL(用以表示空)，因为如此一来，所有原来因为该位置被占，而存储到其它位置的元素将不能再找到。例如，有一key为k的元素的探查序列为&amp;lt;1,5,6,2,8,3,…&gt;,被存储在位置8，假如我们将存储位置2设置为空，那么在对k进行查找时，我们依次查找1,5,6,2位置，但是因为2为空，程序任务已经查找完成——因为开放地址法总是将元素存储在第一个可以存储的位置的嘛——查找到2终止。要解决这个问题，我们应当将被删除元素的位置设置为“已删除”，而不是“空”。这样我们通过小小修改一下插入程序的代码使之能够在标记为“已删除”的位置插入元素就可以了。&lt;/p&gt;
&lt;/p&gt;

&lt;h3&gt;开放地址的三种探查方式&lt;/h3&gt;
&lt;/p&gt;

&lt;h4&gt;线性探查（Linear Probing）&lt;/h4&gt;
&lt;/p&gt;

&lt;p&gt;线性探查很简单，实际上就是一种遍历的方式来探查可用的位置。哈希函数为：&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;k&lt;/em&gt;,
&lt;em&gt;i&lt;/em&gt;) = (&lt;em&gt;h&lt;/em&gt;'(&lt;em&gt;k&lt;/em&gt;) + &lt;em&gt;i&lt;/em&gt;) mod &lt;em&gt;m&lt;/em&gt; 其中&lt;em&gt;h'(k)&lt;/em&gt;
称为辅助哈希函数。因为第一次探查的位置决定了整个探查顺序，所以所有的key最多之可能有m个探查顺序，可见发生碰撞的概率不小。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;线性探查易于实现，但是随着时间的推移，哈希表中被占用的位置越多，连续被占用的位置也越来越多，碰撞的几率会大大提升，查找的平均时间将会大大增加。这种现象叫做primary
clustering（主要聚集？应该叫扎堆现象比较合适，暂定将primary
clustering翻译为“首要扎堆现象”）。&lt;/p&gt;
&lt;/p&gt;

&lt;h4&gt;二次探查（Quadratic probing）&lt;/h4&gt;
&lt;/p&gt;

&lt;p&gt;二次探查函数形如：[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/11/image_thumb6.png" title="image" /&gt;][]与一次探查类似，首次探查的位置决定了整个探查的顺序，因此对于所有的key也只可能最多用到m种探查顺序，与一次相比的探查比较的好处在于，它的偏移量不是一个常数，而是由一个二次方程决定，这样很大程度上避免了一次探查的首要扎堆现象，所以把二次探查这种现象称之为次要扎堆现象（secondary
clustering）吧。但是要想填满整个哈希表的话，那么在c&lt;sub&gt;1&lt;/sub&gt;，c2的选择上就要斟酌一番了。&lt;/p&gt;
&lt;/p&gt;

&lt;h4&gt;双重哈希（Double hashing）&lt;/h4&gt;
&lt;/p&gt;

&lt;p&gt;注意！CLRS开场便说：双重哈希提供最好的方法之一给开放地址法。其函数形如：&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;k&lt;/em&gt;, &lt;em&gt;i&lt;/em&gt;) = (&lt;em&gt;h&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;(&lt;em&gt;k&lt;/em&gt;) + &lt;em&gt;ih&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;(&lt;em&gt;k&lt;/em&gt;)) mod &lt;em&gt;m&lt;/em&gt;,
它有两个辅助函数&lt;em&gt;h&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; 和
&lt;em&gt;h&lt;/em&gt;2。双重哈希带来的好处是初始探查位置不能决定整个探查序列，因此双重哈希将能使用到O(m&lt;sup&gt;2&lt;/sup&gt;)中探查序列，比之线性探查和二次探查的m种强了很多。但要注意的一点是，要使探查序列能包含整个哈希表，h&lt;sub&gt;2&lt;/sub&gt;应当与表的大小m互质。两种使之互质的方法是：1.使m为一个质数，h&lt;sub&gt;2&lt;/sub&gt;总产生比m小的正整数；2.取m为2的幂，而h&lt;sub&gt;2&lt;/sub&gt;总产生质数。&lt;/p&gt;
&lt;/p&gt;

&lt;h3&gt;完全哈希表&lt;/h3&gt;
&lt;/p&gt;

&lt;p&gt;完全哈希是指在最坏情况下，内存访问次数为O(1)。完全哈希采用二级结构，每一级上都采用全域散列。其实犹如用链表解决碰撞的哈希表那样，只不过完全哈希不是使用链表而是使用一个小的哈希表来实现，且保证在小的哈希表上不发生碰撞。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;关于完全哈希尚有疑惑,不记录太多，以免误人，亦免自误。&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/11/image_thumb1.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2011/11/image1.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/11/image_thumb6.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2011/11/image6.png&lt;/p&gt;</summary><category term="hash tables"></category><category term="Introduction to algorithm"></category></entry><entry><title>哈希表（1）</title><link href="http://www.roading.org//algorithm/introductiontoalgorithm/%e5%93%88%e5%b8%8c%e8%a1%a8%ef%bc%881%ef%bc%89.html" rel="alternate"></link><updated>2011-11-08T22:18:00+08:00</updated><author><name>Adoo</name></author><id>tag:www.roading.org,2011-11-08:/algorithm/introductiontoalgorithm/%e5%93%88%e5%b8%8c%e8%a1%a8%ef%bc%881%ef%bc%89.html</id><summary type="html">&lt;p&gt;引文：&lt;/p&gt;
&lt;p&gt;本文参考&lt;em&gt;Introduction To Algorithm ——third
edition&lt;/em&gt;第十一章，置于文首，以表对作者敬意。主要介绍直接寻址表，哈希表，三种哈希函数
——乘法函数，除法函数，全域函数。你可以将本文当做一篇算法导论的笔记，也可以将它当作Adoo对算法导论的理解加讲解。欢迎提出任何建议。同时学习之作难免浅薄，恳请有识之士斧正。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2011/11/8 By Adoo | Homepage:&lt;/em&gt;&lt;a href="http://www.roading.org"&gt;&lt;em&gt;www.roading.org&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;直接寻址表（Direct-address tables）&lt;/h3&gt;
&lt;p&gt;假设有一组元素，每个元素的Key值都包含在范围U={0,1,2,3,…m-1}中。如果这个值m不是太大，且这一组元素的Key值都不相同，我们用key值来直接决定元素或指向元素指针的存储位置（slot,我将其翻译为位置而不是狭缝，槽或…），这就是直接寻址表。如下图：&lt;/p&gt;
&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/11/image_thumb.png" title="image" /&gt;][]&lt;/p&gt;
&lt;p&gt;从左图看到，对于一个元素Key值为2的元素，指向它的指针被存储在下标为2的位置中。key值为3的被存储在小标为三的位置…&lt;/p&gt;
&lt;p&gt;你也可以直接将元素存储在直接寻址表中，而不是存储它的指针。这一切视情况而定，比方当元素的附属数据比较多的情况下，我想存储它的指针应该更为合理；反之，存储元素本身应该更易管理。&lt;/p&gt;
&lt;p&gt;直接寻指表虽然有逻辑简单，查询存储速度快等优点，但缺点也显而易见：假如U的范围非常大的话，那么建一张这样的直接寻址表的话，不知需内存几何？另外，对于一个U
的范围偏大，而实际的元素个数又很少的话，其内存的利用率就令人发指了。再暴力点，直接给它两个key相同的元素呢？&lt;/p&gt;
&lt;p&gt;…于是我们就引出了哈希表。&lt;/p&gt;
&lt;h3&gt;哈希表（Hash tables）&lt;/h3&gt;
&lt;p&gt;与直接寻址表Key为k的元素存储在位置k不同，哈希表让Key
为k的元素存储在位置为h(k)的位置。我们将h称为哈希函数，将h(k)称为哈希值。而恰是这么一种规则，使得哈希表的大小往往远远小于U的范围大小。因为我们可以定义一个函数值的范围比较适合的哈希函数嘛。再看一张图：&lt;/p&gt;
&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/11/image9_thumb.png" title="image" /&gt;][]&lt;/p&gt;
&lt;p&gt;可以看到左图并非是直接映射，而是按照一定的规则令来映射Key值,这个规则当然就是哈希函数。&lt;/p&gt;
&lt;p&gt;不过可以看到，哈希函数同时带来了一个问题，那就是两个或多个不同的Key有可能被映射到同一个位置，我们把这一问题称为碰撞（collision）,下篇文章会给出解决方案。其实左图中已经给出了一种解决方案——用链表来解决。&lt;/p&gt;
&lt;h3&gt;哈希函数&lt;/h3&gt;
&lt;p&gt;一个好的哈希函数：每一个key都有相等几率哈希到哈希表中m个位置中的一个，独立于任何其它已哈希的Key。但这仅是一种理想情况，难以把握。尽可能的使不同的key哈希到同一个位置。&lt;/p&gt;
&lt;p&gt;key的转换，大部分情况下，我们都是用自然数来作为Key,假如我们的key不是自然数，我们将使用某种方法将它转化为自然数。比如如果key=”pt”可以利用它的ASCALL码将其转换为自然数，比方p(112)+t(116)*2=344.&lt;/p&gt;
&lt;p&gt;下面介绍的三种函数，前两种(除法哈希法，乘法哈希法)为启发式函数（heuristic
function）,第三种（全域哈希法）使用随机技术。实际应用中我们往往使用启发式函数。&lt;/p&gt;
&lt;h4&gt;除法哈希&lt;/h4&gt;
&lt;p&gt;如果我们要把一个Key为k的元素映射到大小为m的哈希表中去，则可以利用m除k的余数来确定位置。那么哈希函数就是：h(k)=&lt;em&gt;k&lt;/em&gt;mod
&lt;em&gt;m。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;关于m的选择我们应当避免一些值，置于这些值是什么，算法导论没有指出，但给了我们一个不错的例子：&lt;/p&gt;
&lt;p&gt;比方，m不应当是2的幂，因为若m=2&lt;sup&gt;p&lt;/sup&gt;,那么h(k)仅仅是k的低p位，也就是说k的哈希值仅依赖于k的低p位而与其他位没有关系。除非低p位的各种排列概率相等，否则最好选择使得哈希值依赖于k的所有位的数。不错的选择是选一个与2的整数次幂不太接近的整数，至于为什么，有待证明。&lt;/p&gt;
&lt;h4&gt;乘法哈希&lt;/h4&gt;
&lt;p&gt;乘法哈希则是令key与一个常小数A(0&amp;lt;A&amp;lt;1)相乘，取其小数部分再与m相乘来获取Key在大小为m的哈希表中的位置。哈希函数为：&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;k&lt;/em&gt;)
= ⌊&lt;em&gt;m&lt;/em&gt;(&lt;em&gt;kA&lt;/em&gt; mod 1)⌋。&lt;/p&gt;
&lt;p&gt;乘法哈希有一个好处是，对于m的选值没有太多的要求。CLRS说一般选择一个值为2的幂的数，究其原因在于，这样方便实现在大部分计算机上实现哈希函数，我相信对于任何一种高级语言实现这样的哈希函数都非常简单，所以这一点，谁管他！&lt;/p&gt;
&lt;p&gt;虽然最佳的A值与数据的特征有关，但是Knuth说[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/11/image_thumb2.png" title="image" /&gt;][]是个不错的值，但其原因，我是想管管不了，估计需要查一番资料，别深究。&lt;/p&gt;
&lt;h4&gt;全域哈希（Universal hashing）&lt;/h4&gt;
&lt;p&gt;假使我们的对手已经模特了我们的哈希规则，很好，它将选择一组数,使得这一组数全部映射到同一位置，这就操蛋了。我们虽有办法解决碰撞的问题（下一篇文章会讲到），但是哈希表的效率将大打折扣，哈希表将变成链表，甚至更慢，完全失去了它的查找优势。问题在于任何一个哈希函数都会有这样一种最坏情况，要彻底解决这个问题并不容易，唯一有效的办法是，我们随机的选一个哈希函数，使之独立于key，这就是全域哈希。&lt;/p&gt;
&lt;p&gt;其基本思想是，在执行之前随即地从一组哈希函数中选择一个作为哈希函数使用。&lt;/p&gt;
&lt;h4&gt;设计全域哈希函数类&lt;/h4&gt;
&lt;p&gt;选一个够大的质数p,且p大于任意一个key。另有两系数a∈{0, 1, ..., &lt;em&gt;p&lt;/em&gt; -
1},b∈{1, 2, ..., &lt;em&gt;p&lt;/em&gt; - 1}.&lt;/p&gt;
&lt;p&gt;哈希函数为[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/11/image_thumb3.png" title="image" /&gt;][]对于任意的a,b可以组成p(p-1)个不同的哈希函数。OK.&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;[&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/11/image_thumb.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2011/11/image.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/11/image9_thumb.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2011/11/image9.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/11/image_thumb2.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2011/11/image2.png
  [&lt;img alt="image" src="http://www.roading.org/wp-content/uploads/2011/11/image_thumb3.png" title="image" /&gt;]: http://www.roading.org/wp-content/uploads/2011/11/image3.png&lt;/p&gt;</summary><category term="hash tables"></category><category term="Introduction to algorithm"></category></entry></feed>