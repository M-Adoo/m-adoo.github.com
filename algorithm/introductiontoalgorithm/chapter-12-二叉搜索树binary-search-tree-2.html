<!DOCTYPE html>
<html lang="en">
<head>
        <title>Chapter 12 二叉搜索树(Binary Search Tree) 2</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="http://www.roading.org/theme/css/main.css" type="text/css" />
        <link href="http://www.roading.org/feed/index.xml" type="application/atom+xml" rel="alternate" title="Adoo's blog Atom Feed" />
        <link href="http://www.roading.org/feed/all.rss" type="application/rss+xml" rel="alternate" title="Adoo's blog RSS Feed" />
</head>
<body id="index" class="home">
        <header id="banner" class="body">
                <div id="siteinfo"><a id="sitename" rel="nofollow" href="http://www.roading.org">Adoo's blog </a><span id="subsitename"> 怀理想主义，行务实之道。</span></div>
<div id="header-search-form">
<gcse:searchbox-only>Loading...</gcse:searchbox-only>
</div>
                <div class="clear"></div>
		<nav>
			<ul id= "nav-pages">
				    <li><a href="http://www.roading.org/pages/about-me.html">About me</a></li>
				    <li><a href="http://www.roading.org/pages/links.html">links</a></li>
				    <li><a href="http://www.roading.org/pages/message.html">Message</a></li>
				    <li><a href = "http://www.roading.org/tweets.html">Tweets</a></li>
				    <li><a href="http://www.roading.org/archives.html">Archive</a></li>
		        </ul>
			<ul id="nav-tags">
       					 <li><a href="http://www.roading.org/tag/bi-ji.html" title="或为读书笔记，或偶有心得">笔记</a></li>
       					 <li><a href="http://www.roading.org/tag/sui-bi.html" title="人生愁几许？难有不悲秋！">随笔</a></li>
			</ul>
			<div class="clear"></div>
			<hr>
<div class="crumbs">
<a href="http://www.roading.org" title ="Back to homepage">Home</a> »
<a href="http://www.roading.org/category/introduction-to-algorithm-third-edition.html">Introduction to Algorithm -third edition</a> »
Chapter 12 二叉搜索树(Binary Search Tree) 2
</div>
		</nav>
	</header><!-- /#banner -->
    <div class="article-page">
	<h1>Chapter 12 二叉搜索树(Binary Search Tree) 2</h1>
	<div class="content">
	      <div class="post-info">
        <abbr class="published" title="2011-12-15T21:39:00">
                周四 15 十二月 2011
        </abbr>
        <address class="article_author">
                By <a class="url fn" href="http://www.roading.org/author/adoo.html">Adoo</a>
        </address>
	    <abbr title="binary search tree&nbsp;&nbsp;笔记&nbsp;&nbsp;算法导论&nbsp;&nbsp;">
	    Tags: 
		<a title="permalink to binary search tree" href="http://www.roading.org/tag/binary-search-tree.html">binary search tree</a>
		<a title="permalink to 笔记" href="http://www.roading.org/tag/bi-ji.html">笔记</a>
		<a title="permalink to 算法导论" href="http://www.roading.org/tag/suan-fa-dao-lun.html">算法导论</a>
	    </abbr>
	<abbr>In <a title="permalink to Introduction to Algorithm -third edition" href="http://www.roading.org/category/introduction-to-algorithm-third-edition.html">Introduction to Algorithm -third edition</a></abbr>
</div><!-- /.post-info -->
	      <h3>前驱和后继(Successor and predecessor)</h3>
<p>所谓前驱和后继(也许这么翻译，并不太正确，姑且这么叫)是指，指定元素在所有元素顺序排列模式下的前一个元素或后一个元素。</p>
<p>要获取一个二叉搜索树中指定结点的后继的直观的办法是，找到所有比指定结点大的结点中最小的。根据二叉搜索树的属性，找比某结点大的元素，可以往两个两个方向走：</p>
<ol>
<li>往右子树方向走，结点右子树的元素都不小于本身；</li>
<li>往父结点方向走，<strong>指定的结点有可能处于其它结点的左子树中</strong>。</li>
</ol>
<p>当指定结点拥有右子树时，那么其后继必存在于其右子树中。因往父结点方向找到的比指定结点大的元素大于指定结点右子树的所有元素。如果指定结点没有右孩子呢？那么沿着父结点的方向找到第一个其做字数包含指定结点的结点，这个结点就是指定结点的后继。</p>
<p>求后继的伪码：</p>
<div class="codehilite"><pre><span class="n">TREE</span><span class="o">-</span><span class="n">SUCCESSOR</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="n">right</span> <span class="err">≠</span> <span class="n">NIL</span>
        <span class="n">then</span> <span class="k">return</span> <span class="n">TREE</span><span class="o">-</span><span class="n">MINIMUM</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span> <span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span><span class="n">x</span><span class="p">.</span><span class="n">p</span>
    <span class="k">while</span> <span class="n">y</span> <span class="err">≠</span> <span class="n">NIL</span> <span class="n">and</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">.</span><span class="n">right</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">p</span>
    <span class="k">return</span> <span class="n">y</span>
</pre></div>
<p>类似的方法可以被我们用来求前驱，这里省略。</p>
<h3>插入和删除操作</h3>
<p>对于插入操作很好解决，从根节点出发，不断比较，一路向下，直到不能再下，就会找到一个合适的位置。下面是伪码：</p>
<div class="codehilite"><pre><span class="n">TREE</span><span class="o">-</span><span class="n">INSERT</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">NIL</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="n">root</span>
    <span class="k">while</span> <span class="n">x</span> <span class="err">≠</span> <span class="n">NIL</span>
        <span class="n">y</span><span class="o">=</span><span class="n">x</span>
            <span class="k">if</span> <span class="n">z</span><span class="p">.</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">key</span>
                <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">.</span><span class="n">left</span>
            <span class="k">else</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">right</span>
    <span class="n">z</span><span class="p">.</span><span class="n">p</span><span class="o">=</span><span class="n">y</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="n">NIL</span>
        <span class="n">T</span><span class="p">.</span><span class="n">root</span><span class="o">=</span><span class="n">z</span>                <span class="c1">// Tree T was empty</span>
    <span class="k">else</span> 
        <span class="k">if</span> <span class="n">z</span><span class="p">.</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="n">key</span>
            <span class="n">y</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">z</span>
        <span class="k">else</span> 
            <span class="n">y</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">z</span>
</pre></div>
<p>至于删除操作，则要麻烦一些，因为删除结点后，我们必须维持搜索二叉树的属性。假定，被删除的结点为z,那么有三种情况:</p>
<ol>
<li>z没有孩子；</li>
<li>z有一个孩子；</li>
<li>z有两个孩子。</li>
</ol>
<p>对于没有孩子和一个孩子这种情况比较容易解决，有一个孩子可以用孩子替代z，一个孩子都没有则用 NIL。麻烦的在于有两个孩子的情况，此时我们必须找到z在其<strong>右子树中(仅仅是右子树范围中，而不是整个树中)</strong>的后继来代替z 。在进行具体操作时，导论上则归纳为四点：</p>
<blockquote>
<ul>
<li>If z has no left child, we replace z by its right child. When z's right child is also NIL, z has no children; when z's right child is not NIL, z has one child.</li>
<li>If z has just one child, it is a left child and we replace z by that child . </li>
<li>Otherwise z has both a left child and a right child. We find z's successor y which lies in z's right subtree and has no left child . We want to splice y out of its current position and have it replace z in the tree.</li>
<li>If y is z's right child (Fig. 12.4c), we replace z by y, maintaining y's right child.</li>
<li>If y is not z's right child,we first replace y by its own right   child, then replace z by y.</li>
</ul>
</blockquote>
<p>我一开始有一点迷惑，为什么要找在右子树中的后继，而不是其真正的后继，好处在哪，更进一步，为什么是后继，而不是其它。</p>
<p>首先，我思考了一下，有怎么样的目标？如果目标单单是维持搜索二叉树的属性的话，那么直接重新建树就好，多么节省脑细胞，显然我们不这样做。我们想找的是一种既能维持搜索二叉树的属性，又手术动得比较小的方式，这无疑比较简单高效，就如我们在做堆的删除工作时，将被删除元素与末尾元素互换的原理一样。</p>
<p>在这之后，我可以总结出这三条：</p>
<ol>
<li>范围可以缩小，要维持搜索二叉树的属性，只需将范围划定在以 z为根节点的子树中即可，因为其它部分的属性并未被破坏。</li>
<li>进一步缩小范围，可以找到一个点来替代z，这样不必要涉及整个子树。什么样的点最适合替代z?z的后继或前驱。秉着关起门来解决自家问题的原则(参照上一条)，对于后继或前驱的选择，应在z的子树中选择，所以这个替代点便变成了右子树中的后继或左子树中的前驱。</li>
<li>另外，不论是右子树中的后继，还是左子树中的前驱，都有一个优点，都最多只有一个孩子。因为拿掉这个结点而带来的问题容易解决。至于，为什么它们最多只有一个孩子？想一想，左子树中的前驱为左子树中的最大值，它的位置应该在哪？一路向右走到底。同样的思路，可以加之遇右子树中的后继。</li>
</ol>
<p>以下是删除操作的伪码：</p>
<div class="codehilite"><pre><span class="n">TREE</span><span class="o">-</span><span class="n">DELETE</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">NIL</span>            
       <span class="n">TRANSPLANT</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">z</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">NIL</span>       
       <span class="n">TRANSPLANT</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
    <span class="k">else</span> <span class="n">y</span> <span class="o">=</span> <span class="n">TREE</span><span class="o">-</span><span class="n">MINIMUM</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
       <span class="k">if</span> <span class="n">y</span><span class="p">.</span><span class="n">p</span> <span class="err">≠</span> <span class="n">z</span>              
          <span class="n">TRANSPLANT</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">y</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>  
          <span class="n">y</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">right</span>
          <span class="n">y</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">y</span>
       <span class="n">TRANSPLANT</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>          
       <span class="n">y</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">left</span>       
       <span class="n">y</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">TRANSPLANT</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">u</span><span class="p">.</span><span class="n">p</span> <span class="o">==</span> <span class="n">NIL</span>       
       <span class="n">T</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">v</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">u</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">left</span>   
       <span class="n">u</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">v</span>
  <span class="k">else</span> <span class="n">u</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">v</span>      
  <span class="k">if</span> <span class="n">v</span> <span class="err">≠</span> <span class="n">NIL</span>
       <span class="n">v</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">p</span>
</pre></div>
<p>注意：伪码中的 TRANSPLANT，只修改 v 与 u的父亲之间的关系，而不修改与u孩子的关系。</p>
<p>关于随机构造搜索二叉树，用给定的一列的元素构造二叉树，假使这列元素是有序的，那么将构造成一根“棍子”，为了规避这种最坏情况的发生，可以采用随机构造二叉树的办法，导论上给出证明，随机构造的搜索二叉树的期望复杂度是O(lgn),精力所限，那个证明我就没有细看了。</p>
<h3>补：关于删除操作为什么不在被删除结点上赋值</h3>
<blockquote>
<p>Many texts, including the ﬁrst two editions of this book, have a
somewhat simpler method of deleting a node from a binary search tree
when both of its children are present. Instead of replacing node
<font face="BatangChe">z</font> by its successor y, we delete node y
but copy its key and satellite data into node
<font face="BatangChe">z</font>. The downside of this approach is that
the node actually deleted might not be the node passed to the delete
procedure. If other components of a program maintain pointers to nodes
in the tree, they could mistakenly end up with “stale” pointers to
nodes that have been deleted. Although the deletion method presented
in this edition of this book is a bit more complicated,it guarantees
that a call to delete node <font face="BatangChe">z</font> deletes
node <font face="BatangChe">z</font> and only node
<font face="BatangChe">z</font>.</p>
</blockquote>
		  <p style= "text-align:right;"><em>
		  周四 15 十二月 2011 By <a class="url fn" href="http://www.roading.org/pages/about-me.html">Adoo</a>
		  (<a href = "http://www.roading.org/pages/message.html">Contact me</a>)</em></p>
		  <p style="text-align:right;"><em>欢迎你与我交流探讨，如有错误疏漏之处，恳请指正。
		  (<a href="http://www.roading.org//algorithm/introductiontoalgorithm/chapter-12-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91binary-search-tree-2.html">本文原链</a>)</em></p>
	    <span class = "left">Share this with your friends:</span>
	    <div id="bdshare" class="bdshare_t bds_tools get-codes-bdshare">
		<a class="bds_tsina"></a>
		<a class="bds_qzone"></a>
		<a class="bds_tqq"></a>
		<a class="bds_douban"></a>
		<a class="bds_taobao"></a>
		<a class="bds_renren"></a>
		<a class="bds_kaixin001"></a>
		<a class="bds_twi"></a>
		<a class="bds_copy"></a>
	    </div>     
	<div class="ds-thread"></div>
	</div>
        <div class="sidebar">
		<div id="relative-articles">
		<h3>Related Posts</h3>
		<ul class="related-articles">
		   <li><a title="斐波那契堆的C++实现" href="http://www.roading.org/algorithm/fibonacci-heaps-in-cpp.html">斐波那契堆的C++实现</a></li>
		   <li><a title="B-树的C++实现" href="http://www.roading.org/algorithm/introductiontoalgorithm/b-%e6%a0%91%e7%9a%84c%e5%ae%9e%e7%8e%b0.html">B-树的C++实现</a></li>
		   <li><a title="B-树的C++实现" href="http://www.roading.org/algorithm/introductiontoalgorithm/b-%e6%a0%91%e7%9a%84c%e5%ae%9e%e7%8e%b0.html">B-树的C++实现</a></li>
		   <li><a title="C++实现红黑树，仿STL封装" href="http://www.roading.org/algorithm/introductiontoalgorithm/c%e5%ae%9e%e7%8e%b0%e7%ba%a2%e9%bb%91%e6%a0%91%ef%bc%8c%e4%bb%bfstl%e5%b0%81%e8%a3%85.html">C++实现红黑树，仿STL封装</a></li>
		   <li><a title="Chapter 13 Red-Black trees (红黑树)" href="http://www.roading.org/algorithm/introductiontoalgorithm/chapter-13-red-black-trees-%e7%ba%a2%e9%bb%91%e6%a0%91.html">Chapter 13 Red-Black trees (红黑树)</a></li>
		   <li><a title="Radix Tree 基数树" href="http://www.roading.org/algorithm/introductiontoalgorithm/radix-tree-%e5%9f%ba%e6%95%b0%e6%a0%91.html">Radix Tree 基数树</a></li>
		   <li class="selected">Chapter 12 二叉搜索树(Binary Search Tree) 2</li>
		   <li><a title="Chapter 12 二叉搜索树(Binary Search Tree) 1" href="http://www.roading.org/algorithm/introductiontoalgorithm/chapter-12-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91binary-search-tree.html">Chapter 12 二叉搜索树(Binary Search Tree) 1</a></li>
		   <li><a title="Solution of CLRS 11.1 exercises" href="http://www.roading.org/algorithm/introductiontoalgorithm/solution-of-clrs-11-1-exercises.html">Solution of CLRS 11.1 exercises</a></li>
		   <li><a title="Chapter 10 Exercises and Problems (2)" href="http://www.roading.org/algorithm/introductiontoalgorithm/chapter-10-exercises-and-problems-2.html">Chapter 10 Exercises and Problems (2)</a></li>
		   <li><a title="Chapter 10 Exercises（1）" href="http://www.roading.org/algorithm/introductiontoalgorithm/chapter-10-exercises%ef%bc%881%ef%bc%89-2.html">Chapter 10 Exercises（1）</a></li>
		</ul>
		</div>
<h3>Contact me</h3>
<div class="social">
	<span style="font-size:15px">I'm here:</span>	
	<a href="http://www.roading.org/feed/index.xml" type="application/atom+xml" title="Atom feed" rel="alternate"><img src="http://www.roading.org/theme/images/icons/rss.png"></img></a>
	<a href="http://twitter.com/Monkey_Adoo" title="@Monkey_Adoo"><img src="http://www.roading.org/theme/images/icons/twitter.png"></img></a>
	<a href="http://weibo.com/boringMonkey" title="@M-Adoo"><img src="http://www.roading.org/theme/images/icons/weibo.png"></img></a>
	<a href="http://douban.com/people/Monkey_Adoo" title="Adoo"><img src="http://www.roading.org/theme/images/icons/douban.png"></img></a>
	<a rea="tomail" title="Adoo@outlook.com" href="mailto:Adoo@outlook.com"><img src="http://www.roading.org/theme/images/icons/email.png"></img></a>
	</div><!-- /.social -->
	</div>
	</div>
<div class="clear"></div>
 <div id="footer">
	<a class="right" href="#banner"  titile="Back to Top" rel="nofollow" title="Back to top">Top↑</a>
	<ul id="footer-nav" class="right">
		<li><a href="http://www.roading.org/pages/about-me.html">About me</a></li>
		<li><a href="http://www.roading.org/pages/links.html">links</a></li>
		<li><a href="http://www.roading.org/pages/message.html">Message</a></li>
		<li><a href="http://www.roading.org/archives.html">Archive</a></li>
	</ul>
	<div class="clear"></div>
	<p>Theme designed by Adoo. Powered by Pelican. &copy; 2011-2012</p>
       </div>
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"adoo"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = 'http://static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- Google Search -->
<script>
  (function() {
    var cx = '014593096765008582725:vpqn4f4zw88';
    var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
	'//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
  })();
</script>
<!-- Google Analytics -->
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-29709820-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>
<!-- 百度分享 -->
<script type="text/javascript" id="bdshare_js" data="type=tools" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
	document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + new Date().getHours();
</script>
<!-- Baidu Button END -->
<!-- Support latex by mathjax -->
<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>